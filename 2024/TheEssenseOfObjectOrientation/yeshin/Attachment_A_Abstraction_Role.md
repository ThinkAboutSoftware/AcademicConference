# 부록 A 추상화 기법

## 추상화 기법

- 추상화는 도메인의 복잡성을 단순화하고 직관적인 멘탈 모델을 만드는 데 사용할 수 있는 가장 기본적인 인지 수단이다.

- 각 추상화 기법은 복잡성을 낮추기 위해 사물의 특정한 면을 감춘다.

  - 분류와 인스턴스화

    - 분류는 객체의 구체적인 세부 사항을 숨기고 인스턴스 간에 공유하는 공통적인 특성을 기반으로 범주를 형성하는 과정이다.

    - 분류의 역은 범주로부터 객체를 생성하는 인스턴스화 과정이다.

  - 일반화와 특수화

    - 일반화는 범주 사이의 차이를 숨기고 범주 간에 공유하는 공통적인 특성을 강조한다.

    - 일반화의 역을 특수화라고 한다.

  - 집합과 분해

    - 집합은 부분과 관련된 세부 사항을 숨기고 부분을 사용해서 저네를 형성하는 과정을 가리킨다.

    - 집합의 반대 과정은 전체를 부분으로 분리하는 분해 과정이다.

- 객체지향의 가장 큰 장점은 동일한 추상화 기법을 프로그램의 분석, 설계, 구현 단계에 걸쳐 일관성있게 적용할 수 있다는 점이다.

## 분류와 인스턴스화

### 개념과 범주

- 객체를 분류하고 범주로 묶는 것은 객체들의 특정 집합에 공통의 개념을 적용하는 것을 의미한다.

- 개념이란 속성과 행위가 유사한 객체에 공통적으로 적용되는 관념이나 아이디어다.

- 세상에 존재하는 객체에 개념을 적용하는 과정을 분류라고 한다.

- 분류는 객체를 특정한 개념을 나타내는 집합의 구성 요소로 포함시킨다.

- 분류는 객체(수많은 개별적인 현상들)를 타입(하나의 개념)에 연관시키는 것이다.

- 분류의 역은 타입에 해당하는 객체를 생성하는 과정으로 인스턴스화 또는 예시라고 한다.

- 객체지향의 세계에서 개념을 가리키는 표준 용어는 타입이다.

- 따라서 타입은 개념과 동의어이며 속성과 행위가 유사한 객체에 공통적으로 적용되는 관념이나 아이디어를 의미한다.

- 이런 관점에서 분류란 객체들을 동일한 타입 또는 범주로 묶는 과정을 의미하므로 객체를 타입의 인스턴스라고 한다.

- 분류는 객체와 타입간의 관계를 나타낸 것이다.

- 어떤 객체가 타입의 정의에 부합할 경우 그 객체는 해당 타입으로 분류, 자동으로 타입의 인스턴스가 된다.

### 타입

- 객체를 타입에 따라 분류하기 위해서는 객체가 타입에 속하는지 여부를 확인할 수 있어야 한다.

- 타입을 객체의 분류 장치로서 적용할 수 있으려면 다음과 같은 세 가지 관점에서의 정의가 필요하다.

  - 심볼: 타입을 가리키는 간략한 이름이나 명칭

  - 내연: 타입의 완전한 정의. 내연의 의미를 이용해 객체가 타입에 속하는지 여부를 확인할 수 있다.

  - 외연: 타입에 속하는 모든 객체들의 집합

### 외연과 집합

- 한 객체가 한 시점에 하나의 타입에만 속하는 것을 단일 분류(single classification), 한 객체가 한 시점에 여러 타입에 속할 경우 다중 분류(multiple classification)이라고 한다.

- 대부분의 객체지향 프로그래밍 언어들은 단일 분류만을 지원한다.

- 이 관점에서 다중 분류와 다중 상속을 혼동해서는 안된다.

  - 다중 상속은 하나의 타입이 다수의 슈퍼타입을 가질 수 있도록 허용하지만 타입 정의를 생략할 수 없다.

  - 다중 분류는 특정한 타입을 정의하지 않고도 하나의 객체가 서로 다른 타입의 인스턴스가 되도록 허용한다.

- 객체를 특정한 타입으로 분류하면 해당 객체는 타입의 집합에 포함된다.

- 객체가 한 집합에서 다른 집합의 원소로 자신이 속하는 타입을 변경할 수 있는 경우를 동적 분류(dynamic classification), 객체가 자신의 타입을 변경할 수 없는 경우는 정적 분류(static classification)이라고 한다.

- 다중 분류와 동적 분류는 서로 배타적인 개념이 아니다.

- 개념적인 관점에서 다중 분류와 동적 분류를 함께 적용하는 것이 실세계의 복잡성을 모델링하는 데 유용하다.

- (작가의 경험에 따르면) 다중 분류와 동적 분류 관점에서 도메인 모델의 초안을 만든 후 실제 구현에 적합하도록 단일 분류와 정적 분류 방식으로 객체들의 범주를 재조정하는 편이 분석과 구현 간의 차이를 메울 수 있는 가장 현실적인 방법이다.

- 디자인 템플렛은 유연성이라는 측면에서 반드시 필요한 경우에만 사용해야 한다.

- 단순함을 위해서는 항상 다중 분류와 동적 분류보다는 단일 분류와 정적 분류를 선택하는 것이 현명하다.

### 클래스

- 클래스는 타입을 구현하는 용도 외에도 코드를 재사용하는 용도로 사용되기도 한다.

- 현재의 객체지향 패러다임은 아리스토텔레스의 분류법을 근간을 형성하는 아이디어를 기반으로 한다.

- 객체들의 카테고리는 객체들이 공유하는 공통적인 특성에 의해 정의된다.

- 본질(essence)이란 한 사물의 가장 핵심적이고 필수불가결한 속성으로 본질적이지 않은 속성을 우연적(accidental) 속성이라고 한다.

- 클래스가 없는 프로토타입 언어에서 분류와 인스턴스화는 프로토타입이라는 객체의 복사를 통해 이뤄진다.

## 일반화와 특수화

### 범주의 계층

- 린네의 계층 구조는 좀 더 세부적인 범주가 계층의 하위에 위치(범주의 특수화)하고 좀 더 일반적인 범주가 계층의 상위에 위치(범주의 일반화)한다.

### 서브타입

- 객체지향의 세계에서 범주는 개념을 의미하고, 개념은 타입을 의미하므로 일반화와 특수화는 계층 구조 안에 존재하는 타입 간의 관계를 의미한다.

- 좀 더 일반적인 타입을 이용해 좀 더 세부적인 타입을 정의함으로써 타입 간의 계층 구조를 구축할 수 있다.

- 어떤 타입이 다른 타입보다 일반적이라면 이 타입을 슈퍼타입(supertype)이라고, 어떤 타입이 다른 타입보다 좀 더 특수하다면 이 타입을 서브타입(subtype)이라고 한다.

- 슈퍼타입은 서브타입의 일반화이고 서브타입은 슈퍼타입의 특수화이다.

- 새로운 범주의 속성은 자신이 정의한 본질적인 속성에 기존 범주의 본질적인 속성을 추가한 것이다.

- 내연의 관점에서 슈퍼타입의 정의가 서브타입의 정의보다 더 일반적이라는 것을 의미한다.

- 내연의 관점에서 일반화와 특수화는 범주 간의 논리적인 추론을 가능하게 한다.

- 어떤 범주에 속하는 다른 객체가 특정 속성을 가지고 있음을 알게 되면 그 범주와 하위 범주에 속하는 다른 객체도 그 속성을 가지고 있을 것이라고 추론할 수 있다.

- 파편화된 사실을 모르더라도 복잡한 세상의 속성을 논리적으로 쉽게 이해할 수 있다.

- 객체의 집합을 나타내는 외연의 관점에서 서브타입은 슈퍼타입의 부분집합으로 표현된다.

- 크레이그 라만은 어떤 타입이 다른 타입의 서브 타입이 되기 위해서는 '100% 규칙'과 'ls-a 규칙'을 준수해야 한다고 말한다.

- 100% 규칙은 타입의 외연과 관련된 규칙이고 ls-a 규칙은 타입의 외연과 관련된 규칙이다.

- 두 타입이 위 두 개의 규칙을 만족시키지 못할 경우 두 타입 간의 일반화 관계는 성립하지 않는다.

  - 100% 규칙

    - 슈퍼타입의 정의가 100% 서브타입에 적용돼야만 한다.

    - 서브타입은 속성과 연관관계 면에서 슈퍼타입과 100% 일치해야 한다.

  - ls-a 규칙

    - 서브타입의 모든 인스턴스는 슈퍼타입 집합에 포함돼야 한다. (subtype is a supertype.)

### 상속

- 프로그램 내의 두 클래스 간에 상속 관계가 존재할 때 이 관계를 반드시 일반화 관계라고 할 수 없다.

- 일반화의 원칙은 한 타입이 다른 타입의 서브타입이 되기 위해 슈퍼타입에 순응(conformance)해야 한다는 것이다.

  - 구조적 순응(structural conformance)

    - 기대 집합은 속성과 연관관계에 관한 것.

    - 타입의 내연과 관련된 100% 규칙을 의미, 즉 서브 타입은 슈퍼타입이 가지고 있는 속성과 연관관계 면에서 100% 일치해야 한다.

    - 서브타입이 슈퍼타입을 대체하더라도 구조에 관한 동일한 기대 집합을 만족시킬 수 있다.

  - 행위적 순응(behavioral conformance)

    - 기대 집합은 행위가 동일한 계약을 기반으로 하는가?

    - 타입의 행위에 관한 것.

    - 서브타입은 슈퍼타입을 행위적으로 대체 가능해야 한다.

    - 리스코프 치환 원칙(Liskov Substitution Principle, LSP)

- 상속의 또 다른 용도는 코드 중복을 방지하고 공통 코드를 재사용하기 위한 언어적 메커니즘을 제공하는 것이다.

- 상속은 서브클래스가 슈퍼클래스를 대체할 수 있는 경우인 서브타이핑(subtyping), 즉 인터페이스 상속(interface inheritance)과 대체할 수 없는 서브클래싱(subclassing), 즉 구현 상속(implementation inheritance)의 두 가지 용도로 사용될 수 있다.

- 서브타이핑의 전제 조건은 대체 가능성이기 때문에 서브타이핑인지 여부를 확인하려면 클라이언트 관점에서 실제로 어떻게 사용되고 있는지를 확인해야 한다.

- 일반화를 위한 서브타이핑은 특정 기대 집합에 대한 서브타입과 슈퍼타입 간의 구조적, 또는 행위적 순응 관계를 의미하며, 대체 가능성을 내포한다.

- 가능한 모든 상속 관계가 서브타이핑의 대체 가능성을 준수하도록 주의 깊게 사용하는 것은 코드를 유연하게 만들고 재사용성을 높이는 한 가지 방법이다.

- 여러 클래스로 구성된 상속 계층에서 수신된 메시지를 이해하는 기본적인 방법은 클래스 간의 위임(delegation)을 사용하는 것이다.

- 어떤 타입의 객체를 특정 객체 타입의 특수화로 만들거나 행동을 공유할 수 있게 만들고 싶은 경우 객체와 객체를 상속 관계를 통해 연결한다.

- 클래스 기반 언어와 프로토타입 기반 언어 모두 위임 메커니즘을 기반으로 메시지를 해석할 수 있는 대상을 선택한다.

- 단지 위임이 클래스를 기준으로 이뤄지는지, 아니면 객체를 기준으로 이뤄지는지 여부가 다를 뿐이다.

## 집합과 분해

### 계층적인 복잡성

- 복잡성은 '계층'의 형태를 띈다.

- 단순한 형태로부터 복잡한 형태로 진화하는 데 걸리는 시간은 그 사이에 존재하는 '안정적인 형태'의 수와 분포에 의존한다.

- 안정적인 형태의 부분으로부터 전체를 구축하는 행위를 집합, 반대로 전체를 부분으로 분할하는 행위를 분해라고 한다.

- 집합은 불필요한 세부 사항을 추상화하고, 분해는 전체와 부분 간의 일관된 계층 구조는 재귀적인 설계를 가능하게 한다.

- 그릇 은유를 통해 사람들은 경계가 존재하지 않는 곳에서도 수월하게 인위적인 집합을 창조할 수 있다.

### 합성 관계

- 객체와 객체 사이의 전체-부분 관계를 구현하기 위해서는 합성 관계를 사용한다.

- 합성 관계는 부분을 전체 안에 캡슐화함으로써 인지 과부하(복잡성)를 방지한다.

- 합성 관계에 비해 단순하고 생명주기와 관련된 어떤 제약도 부과되지 않아 독립적으로 제거될 수 있는 관계를 연관 관계라고 한다.

- 합성 관계는 생명주기 측면에서 연관 관계보다 더 강하게 객체들을 결합한다.

### 패키지

- 소프트웨어의 전체적인 구조를 표현하기 위해 관련된 클래스 집합을 하나의 논리적인 단위로 묶는 구성 요소를 패키지(package) 또는 모듈(Module)이라고 한다.

- 함께 협력하는 응집도 높은 클래스 집합을 하나의 패키지 내부로 모으면 코드를 이해하기 위해 패키지 경계를 넘나들 필요가 적어진다.

- 합성 관계가 내부에 포함된 객체들의 존재를 감춤으로써 내부 구조를 추상화하는 것처럼 패키지는 내부에 포함된 클래스들을 감춤으로써 시슽템의 구조를 추상화한다.
