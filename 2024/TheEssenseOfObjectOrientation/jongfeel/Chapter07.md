## 07 함께 모으기

> 코드와 모델을 밀접하게 연관시키는 것은 코드에 의미를 부여하고 모델을 적절하게 한다 - 에릭 에반스(Eric Evans)[Evans 2003]

마틴 파울러는 < UML Distilled 2판 >[Fowler 1999b]에서 객체지향 설계 안에 존재하는 세 가지 상호 연관된 관점에 관해 설명한다.

**개념 관점(Conceptual Perspective)**

설계는 도메인 안에 존재하는 개념과 개념들 사이의 관계를 표현한다.
이 관점은 사용자가 도메인을 바라보는 관점을 반영한다.

**명세 관점(Specification Perspective)**

도메인을 벗어나 소프트웨어로 초점이 옮겨진다.
객체가 협력을 위해 '무엇'을 할 수 있는가에 초점을 맞춘다.
"구현이 아니라 인터페이스에 대해 프로그래밍 하라[GOF 1994]"를 따르는 것은
명세 관점과 구현 관점을 명확하게 분리하는 것에서 부터 시작된다.

**구현 관점(Implementation Perspective)**

실제 작업을 수행하는 코드와 연관돼 있다.
객체의 책임을 '어떻게' 수행할 것인가에 초점을 맞추며
인터페이스를 구현하는 데 필요한 속성과 메서드를 클래스에 추가한다.

이 세 관점의 순서대로 소프트웨어를 개발한다는 의미가 아니라
각각 다른 관점으로 동일한 클래스를 바라보는 것을 의미한다.

클래스가 은유하는 개념은 도메인 관점을 반영한다.
클래스의 공용 인터페이스는 명세 관점을 반영한다.
클래스의 속성과 메서드는 구현 관점을 반영한다.

예제를 통해 두 가지 목표를 알아본다.
첫 번째 목표는 도메인 모델에서 시작해서 최종 코드까지의 구현 과정을 간략하게 설명한다.
두 번째 목표는 구현 클래스를 개념 관점, 명세 관점, 구현 관점에서 바라보는게 무엇을 의미하는지 설명한다.

### 커피 전문점 도메인

#### 커피 주문

커피 전문점에서 커피를 주문하는 과정을 객체들의 협력 관계로 구현한다.

#### 커피 전문점이라는 세상

커피 전문점 도메인에는
손님, 메뉴 항목, 메뉴판, 바리스타, 커피 객체로 구성된 작은 세상이다.

커피 전문점을 구성하는 범주로
손님 타입, 메뉴 항목 타입, 바리스타 타입, 커피 타입을 보고
타입 간에 어떤 관계가 존재하는지 살펴본다.

하나의 메뉴판 객체는 여러 개의 메뉴 항목 객체로 구성되어 있다.
이를 메뉴판 타입과 메뉴 항목 타입간의 합성 관계로 단순화하면 보기 수월해진다.

손님 타입은 메뉴판 타입을 알고 있어야 하는데
메뉴판 타입은 손님의 일부가 아니므로 합성 관계가 아니라 연관 관계로 표현한다.
연관 관계(association)는 한 타입의 인스턴스가 다른 타입의 인스턴스를 포함하지 않지만 서로 알고 있어야 할 경우이다.

바리스타 타입은 커피를 제조해야 하므로 커피 타입을 알고 있어야 한다.
커피 타입도 바리스타의 일부가 아니므로 합성 관계 보다는 연관 관계로 본다.

```
참고
실제 도메인 모델을 작성하는 단계에서 어떤 관계가 포함 관계이고 어떤 관계가 연관 관계인지는 중요하지 않다.
어떤 타입이 도메인을 구성하느냐와 타입들 사이에 어떤 관계가 존재하는지를 파악해 도메인을 이해하는 것이다.
```

### 설계하고 구현하기

#### 커피를 주문하기 위한 협력 찾기

훌륭한 객체는 훌륭한 협력을 설계할 때만 얻을 수 있다.
협력을 설계할 때는 객체가 메시지를 선택하는 것이 아니라 메시지가 객체를 선택하게 해야 한다.

커피를 주문하라라는 메시지와 이 메시지를 처리하기에 적합한 객체를 선택해야 한다.
커피 전문점을 추상화한 도메인 모델이라는 재료를 통해 책임을 수행하기에 적절한 타입이 존재하는지 살펴본다.
그 후에 책임을 수행할 객체를 그 타입의 인스턴스로 만든다.

어떤 객체가 커피를 주문할 책임을 져야 할지 살펴보면 손님이 된다.
따라서 메시지를 처리할 객체는 손님 타입의 인스턴스이다.

손님은 메뉴 항목을 알지 못한다.
메뉴 항목은 고객의 일부가 아니라 메뉴판의 일부이기 때문이다.
따라서 손님은 자신이 선택한 메뉴 항목을 누군가가 제공해줄 것을 요청해야 한다.
'메뉴 항목을 찾아라'라는 새로운 메시지가 등장한다.

메뉴 항목을 찾을 책임의 할당은 메뉴판 객체에 한다.
메뉴판 객체는 메뉴 항목 객체를 포함하기 때문에 이 책임을 처리할 수 있는 가장 적절한 후보이다.

```
참고

현실속의 메뉴판은 수동적인 존재다.
객체지향의 세계에서는 수동적인 메뉴판은 유효하지 않으며
모든 객체가 능동적이고 자율적인 존재다.
메뉴판은 자기 스스로 메뉴 항목을 찾으므로 
설계자는 '의인화'를 해야 한다.

소프트웨어 안의 메뉴판은 현실 속의 메뉴판이 제공하는 개념을 기반으로 하기 때문에
어떤 일을 수행하는지를 유추하기가 쉽다.
소프트웨어 객체는 현실 속의 객체를 모방하거나 추상화한 것이 아니다.
단지 의미를 쉽게 유추할 수 있도록 '은유'할 뿐이다.
```

손님은 메뉴 항목에 맞는 커피를 제조하라고 요청할 수 있다.
새로운 요청은 새로운 메시지가 필요하다.
자연스럽게 커피를 제조할 책임은 바리스타에게 있다.

```
참고

UML 2.0 표준에서는 협력을 표현하기 위한 용도로 커뮤니케이션 다이어그램(Communication Diagram)을 제공한다.
책에서 설명한 그림과 유사하지만 책에서는 약간 다른 표기법을 사용한다.

의사소통이라는 목적에 부합한다면 용도에 맞게 얼마든지 UML을 수정하고 뒤틀어라.
UML은 의사소통을 위한 표기법이지 꼭 지켜야 하는 법칙이 아니다.
```

바리스타는 특정 메뉴를 제조하는 방법을 아는 전문가이므로
음료를 제조하기 위한 지식은 바리스타의 상태로,
기술은 바리스타의 행동으로 간주할 수 있다.
이런 관점에서 바리스타는 스스로의 판단과 지식에 따라 행동하는 자율적인 존재다.

협력에 필요한 객체의 종류와 책임, 주고받아야 하는 메시지에 대한 대략적인 윤곽이 잡혔다.
이제 메시지를 정제해서 각 객체의 인터페이스를 구현 가능할 정도로 상세하게 정제한다.

![image](https://github.com/jongfeel/BookReview/assets/17442457/4b134483-4fc6-40c8-8f8f-7e282d606b21)

#### 인터페이스 정리하기

각 객체를 협력이라는 문맥에서 떼어내어 수신 가능한 메시지만 추려내면 객체의 인터페이스가 된다.

손님 객체의 인터페이스 안에는 '커피를 주문하라'라는 오퍼레이션이 포함돼야 한다.
메뉴판 객체의 인터페이스는 '메뉴 항목을 찾아라'라는 오퍼레이션을 제공하며,
바리스타 객체의 인터페이스는 '커피를 제조하라'라는 오퍼레이션을,
커피 객체는 '생성하라'라는 오퍼레이션을 제공한다.

객체들의 협력은 실행 시간에 컴퓨터에서 일어나는 상황을 동적으로 묘사한 모델이다.
객체의 타입에서 식별된 오퍼레이션을 타입의 인터페이스로 추가해야 한다.

객체의 타입은 클래스를 이용한다.
인터페이스에 포함된 오퍼레이션은 외부에서 접근 가능하도록 공용(public)으로 선언돼 있어야 한다.

``` java
class Customer {
    public void order(String menuName) {
    }
}

class MenuItem{
}

class Menu {
    public MenuItem choose(String name) {
    }
}

class Barista {
    public Coffee makeCoffee(MenuItem menuItem) {
    }
}

class Coffee {
    public Coffee(MenuItem menuItem) {
    }
}
```

#### 구현하기

Customer가 협력하기 위해서는 Menu, Barista 객체에 접근해야 한다.
객체가 다른 객체에게 메시지를 전송하기 위해서는 객체에 대한 참조를 얻어야 한다.

일단 Customer의 order() 메서드의 인자로 Menu와 Barista 객체를 전달받는 방법으로 참조 문제를 해결한다.
그러면 Customer의 인터페이스를 변경하고 구현을 하면 다음과 같다.

``` java
class Customer {
    public void order(String menuName, Menu menu, Barista barista) {
        MenuItem menuItem = menu.choose(menuName);
        Coffee coffee = barista.makeCoffee(menuItem);
    }
}
```

```
참고

구현하지 않고 머릿속으로만 구상한 설계는 코드로 구현하는 단계에서 대부분 변경된다.
설계 작업은 구현을 위한 스케치를 작성하는 단계로 구현 그 자체는 아니다.
협력을 구상하는 단계에 너무 오랜 시간을 쏟지 말고 최대한 빨리 코드를 구현해서
설계에 이상이 없는지, 설계가 구현 가능한지를 판단해야 한다.
코드를 통한 피드백 없이는 깔끔한 설계를 얻을 수 없다.
```

Menu는 menuItem에 해당하는 MenuItem을 찾아야 하는 책임이 있다.
내부적으로 MenuItem을 관리하고 있어야 하고
choose() 메서드를 통해 MenuItem의 목록에서 이름이 동일한 MenuItem을 찾아서 반환한다.

``` java
class Menu {
    private List<MenuItem> items;

    public Menu(List<MenuItem> items) {
        this.items = items;
    }

    public MenuItem choose(String name) {
        for (MenuItem each : Items) {
            if (each.getName().equals(name)) {
                return each;
            }
        }
        return null;
    }
}
```

``` 
참고

...
객체에게 책임을 할당하고 인터페이스를 결정할 때는 가급적 객체 내부의 구현에 대한 어떤 가정도 하지 말아야 한다.
객체가 어떤 책임을 결정한 후에 책임을 수행하는 데 필요한 객체의 속성을 결정하라.
이것이 객체의 구현 세부사항을 객체의 공용 인터페이스에 노출시키지 않고 인터페이스와 구현을 분리할 수 있는 기본적인 방법이다.
```

```
참고

MenuItem의 인터페이스를 구성하는 오퍼레이션들을 MenuItem을 구현하는 단계에 와서야 식별했다는 점을 눈여겨봐야 한다.
부끄러워해야 할 일이 아니다.
인퍼페이스는 객체가 다른 객체와 직접적으로 상호작용하는 통로다.
인터페이스를 통해 실제로 상호작용을 해보지 않은 채 인터페이스의 모습을 정확하게 예측하는 것은 불가능에 가깝다.

설계를 간단히 끝내고 최대한 빨리 구현에 돌입하라.
머릿속에 객체의 협력 구조가 번뜩인다면 그대로 코드를 구현하기 시작하라.
설계가 제대로 그려지지 않는다면 고민하지 말고 실제로 코드를 작성해가면서 협력의 전체적인 밑그림을 그려보라.
이게 테스트-주도 설계로 코드를 구현하는 방법이다.
테스트 코드를 작성하면서 협력을 설계하는 것이다.
```

### 코드와 세 가지 관점

#### 코드는 세 가지 관점을 모두 제공해야 한다

개념 관점에서 코드를 바라보면
Customer, Menu, MenuItem, Barista, Coffee 클래스가 있다.
클래스들은 커피 전문점 도메인을 구성하는 중요한 개념과 관계를 반영한다는 사실을 쉽게 알 수 있다.

커피를 제조해는 과정을 변경한다면 현실 세계에서 커피를 제조하는 바리스타를 수정해야 한다.
현실 뿐 아니라 소프트웨어 안에서도 Barista 클래스가 커피를 제조할 것이라고 쉽게 유추할 수 있다.

명세 관점은 클래스의 인터페이스를 바라본다.
인터페이스를 수정하면 해당 객체와 협력하는 모든 객체에게 영향을 미칠 수밖에 없다.
객체의 인터페이스는 수정하기 어렵다.
최대한 변화에 안정적인 언터페이스를 만들기 위해서는 인터페이스를 통해 구현과 관련된 세부 사항이 드러나지 않게 해야 한다.
변화에 탄력적인 인터페이스를 만들 수 있는 능력은 객체지향 설계자의 수준을 가늠하는 중요한 척도다.

구현 관점은 클래스의 내부 구현을 바라본다.
메서드의 구현과 속성의 변경은 원칙적으로 외부의 객체에게 영향을 미쳐서는 안 된다.
이것은 메서드와 속성이 철저하게 클래스 내부로 캡슐화돼야 한다는 것을 의미한다.

훌륭한 객체지향 프로그래머는 하나의 클래스 안에 세 가지 관점을 모두 포함하면서도
각 관점에 대응되는 요소를 명확하고 깔끔하게 드러낼 수 있다.

#### 도메인 개념을 참조하는 이유

어떤 메시지를 수신할 객체를 선택하기 위해서는 도메인 개념 중에서 선택해야 한다.
도메인 지식 기반으로 코드의 구조와 의미를 만든다면 시스템의 유지보수성에 커다란 영향을 미친다.

소프트웨어는 변화하고 설계는 변경을 위해 존재한다.
인터페이스와 구현을 분리하는 이유는 변경이 발생했을 때 코드를 좀 더 수월하게 수정하길 간절히 원하기 때문이다.
이때 클래스들이 도메인 개념을 따르면 변화에 쉽게 대응할 수 있다.

#### 인터페이스와 구현을 분리하라

명세 관점은 클래스의 안정적인 측면을 드러내야 한다.
구현 관점을 클래스의 불안정한 측면을 드러내야 한다.
인터페이스가 구현 세부 사항을 노출한다면 작은 변화에도 전체 협력이 요동치는 취약한 설계가 된다.

마틴 파울러는 개념-명세 관점 보다는 명세-구현 관점을 분리하는 것이 중요하다고 주장한다[Fowler 1999b].
프로그래머는 코드를 접하므로 구현 관점을 생각하지만
훌륭한 설계를 결정하는 측면은 명세 관점은 객체의 인터페이스다.
명세 관점으로 설계를 주도하면 설계의 품질이 향상된다.

중요한 건 클래스를 봤을 때도 명세 관점과 구현 관점으로 나눠서 볼 수 있어야 한다.