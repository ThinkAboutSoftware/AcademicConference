## 부록 A 추상화 기법

### 추상화 기법

추상화는 도메인의 복잡성을 단순화하고 직관적인 멘탈 모델을 만드는 데 사용할 수 있는 가장 기본적인 인지 수단이다.

아래 추상화 기법과 종류들을 확인해 본다.
각 추상화 기법은 복잡성을 낮추기 위해 사물의 특정한 측면을 감춘다.

- 분류와 인스턴스화: 객체의 구체적인 세부 사항을 숨기고 인스턴스 간에 공유하는 공통적인 특성을 기반으로 범주를 형성하는 과정이다.
- 일반화와 특수화: 일반화는 범주 사이의 차이를 숨기고 범주 간에 공유하는 공통적인 특성을 강조한다.
- 집합과 분해: 집합은 부분과 관련된 세부 사항을 숨기고 부분을 사용해서 전체를 형성하는 과정을 가리킨다.

### 분류와 인스턴스화

#### 개념과 범주

객체를 분류하고 범주로 묶는 것은 객체들의 특정 집합에 공통의 개념을 적용하는 것을 의미한다.
개념이란 속성과 행위가 유사한 객체에 공통적으로 적용되는 관념이나 아이디어다[Martin 1998].

객체들을 공통적인 특성을 기반으로 범주로 묶고 개념을 적용하는 것은 범주라는 정신적인 렌즈를 통해 세상을 바라보는 것과 유사하다.

세상에 존재하는 객체에 개념을 적용하는 과정을 분류라고 한다[Martin 1998].
분류는 객체를 특정한 개념을 나타내는 집합의 구성 요소로 포함시킨다.
분류를 통해 개별 현상을 하나의 개념으로 다룬다.
이때 '수 많은 개별적인 현상들'을 객체라고 하고, '하나의 개념'을 타입이라고 한다.
분류는 객체를 타입과 연관시키는 것이고, 분류의 역은 타입에 해당하는 객체를 생성하는 과정으로 인스턴스화 또는 예시라고 한다.

#### 타입

객체를 타입에 따라 분류하기 위해서는 객체가 타입에 속하는지 여부를 확인할 수 있어야 한다.

타입을 객체의 분류 장치로서 적용할 수 있으려면 다음과 같은 세 가지 관점에서의 정의가 필요하다[Martin 1998, Larman 2004]

- 심볼: 타입을 가리키는 간략한 이름이나 명칭
- 내연: 타입의 완전한 정의 내연의 의미를 이용해 객체가 타입에 속하는지 여부를 확인할 수 있다.
- 외연: 타입에 속하는 모든 객체들의 집합

#### 외연과 집합

타입의 외연은 타입에 속하는 객체들의 집합으로 표현한다.
집합은 외연을 가리키는 또 다른 명칭이다.
객체들은 동시에 서로 다른 집합에 포함될 수도 있다.

한 객체가 한 시점에 하나의 타입에만 속하는 것을 단일 분류라고 한다.
반면 여러 타입에 속할 경우 다중 분류라고 한다.

대부분 객체지향 프로그래밍 언어들은 단일 분류만을 지원한다.
한 객체는 한 클래스의 인스턴스여야만 하고 동시에 두 개의 클래스의 인스턴스일 수는 없다.
이 관점에서 다중 분류를 다중 상속과 혼동해서는 안 된다[Fowler 2003].

객체가 한 집합에서 다른 집합의 원소로 자신이 속하는 타입을 변경할 수 있다면 이를 동적 분류(dynamic classification)라고 한다.
객체가 자신의 타입을 변경할 수 없다면 이를 정적 분류(static classification)라고 한다.

다중 분류와 동적 분류는 서로 배타적인 개념이 아니다.
개념적인 관점에서 다중 분류와 동적 분류를 함께 적용하는 것이 실세계의 복잡성을 모델링하는 데 유용하다.

다중 분류와 동적 분류는 개념적인 관점에서 도메인을 분석하는 데는 유용하지만
객체지향 프로그래밍 언어의 제약으로 인해 이를 구현으로 옮기기는 쉽지 않다.
도메인 모델의 초안을 만든 후에 실제 구현에 적합하도록 단일 분류와 정적 분류 방식으로
객체들의 범주를 재조정하는 편이 분석과 구현 간의 차이를 메울 수 있는 가장 현실적인 방법이다.

마틴 파울러는
< Analysis Patterns >[Fowler 1996]
< Object-Oriented Methods: Pragmatic Considerations > [Martin 1996]
에서 다중 분류와 동적 분류를 구현할 수 있는 다양한 방식의 '디자인 템플릿'을 소개하고 있다.
유연성이라는 측면에서 반드시 필요한 경우에만 사용하고
단순함을 위해서는 단일 분류와 정적 분류를 선택하는 것이 현명하다.

#### 클래스

타입을 구현하는 보편적인 방법은 클래스를 이용하는 것이다.
타입을 구현한다라는 표현은 클래스와 타입이 동일한 개념이 아니며
추상 클래스, 인터페이스 등을 이용해 타입을 구현할 수 있기 때문이다.

클래스는 객체가 공유하는 본질적인 속성을 정의한다.
동일한 범주에 속하는 객체는 동일한 클래스의 인스턴스여야 한다.

### 일반화와 특수화

#### 범주의 계층

1735년에 카를로스 린네(Carlos Linnaeus)는 생물 분류법에 대한 기념비적인 논문인 < 자연의 체계(System Naturae) >를 발표했다.
린네의 분류 체계는 '계'라는 최상위 단계가 있는 중첩된 계층 구조로
이는 다시 문, 강 목, 과, 속, 종으로 세분화 됐으며 각 단계를 가리키는 라틴어 명칭이 존재한다.

린네의 계층 구조는 좀 더 세부적인 범주가 계층의 하위에 위치하고
좀 더 일반적인 범주가 계층의 상위에 위치한다.
이때 계층의 상위에 위치한 범주를 계층의 하위에 위치한 범주의 일반화라고 하고,
계층의 하위에 위치한 범주는 계층의 상위에 위치한 범주의 특수화라고 한다.

#### 서브타입

어떤 타입이 다른 타입보다 일반적이라면 슈퍼타입(supertype)이라고 한다.
어떤 타입이 다른 타입보다 좀 더 특수하다면 이 타입을 서브타입(subtype)이라고 한다.
슈퍼타입은 서브타입의 일반화이고, 서브타입은 슈퍼타입의 특수화다.

일반화와 특수화의 계층 구조에서 서브타입은 슈퍼타입이 가진 본질저긴 속성과 함께 자신만의 추가적인 속성을 가진다.
내연의 관점에서 슈퍼타입의 정의가 서브타입의 정의보다 더 일반적이라는 것을 의미한다.

크레이그 라만은 어떤 타입이 다른 타입의 서브타입이 되기 위해서는 '100% 규칙'과 'is-a' 규칙을 준수해야 한다고 말한다[Larman 2004].
100% 규칙은 타입의 내연과 관련된 규칙이며, is-a 규칙은 타입의 외연과 관련된 규칙이다.
두 타입이 이 규칙들을 만족하지 못할 경우 두 타입 간에 일반화 관계는 성립하지 않는다.

- 100% 규칙: 슈퍼타입의 정의가 100% 서브타입에 적용돼야만 한다. 서브타입은 속성과 연관관계 면에서 슈퍼타입과 100% 일치해야 한다.
- is-a 규칙: 서브타입의 모든 인스턴스는 슈퍼타입 집합에 포함돼야 한다. 서브타입은 슈퍼타입이다(subtype is a supertype)라는 구문을 만들어서 테스트할 수 있다.

#### 상속

일반화와 특수화 관계를 구현하는 가장 일반적인 방법은 클래스간의 상속을 사용하는 것이다.
모든 상속 관계가 일반화 관계인 것은 아니다.
프로그램 내의 두 클래스 간에 상속 관계가 존재할 때 이 관계를 반드시 일반화 관계라고 할 수는 없다.

일반화의 원칙은 한 타입이 다른 타입의 서브타입이 되기 위해서는 슈퍼타입에 순응(conformance)해야 한다는 것이다.
순응에는 구조적인 순응(structural conformance)과 행위적인 순응(behavioral conformance)의 두 종류가 있다[Cook 1994].
구조적인 순응의 경우 속성과 연관관계에 관한 것이며,
행위적인 순응의 경우 행위가 동일한 계약을 기반으로 하느냐에 관한 것이다.

구조적인 순응은 타입의 내연과 관련된 100% 규칙을 의미한다.
서브타입은 슈퍼타입이 가지고 있는 속성과 연관관계 면에서 100% 일치해야 한다.
따라서 서브타입이 슈퍼타입을 대체하더라도 구조에 관한 동일한 기대 집합을 만족시킬 수 있다.

행위적인 순응은 타입의 행위에 관한 것이며, 서브타입은 슈퍼타입을 행위적으로 대체 가능해야 한다.
행위적인 순응은 리스코프 치환 원칙(Liskov Substitution Principle, LSP)[Martin 2002]이라고 한다.

상속은 서브타이핑(subtyping)과 서브클래싱(subclassing)의 두 가지 용도로 사용될 수 있다.
서브클래스가 슈퍼클래스를 대체할 수 있는 경우 서브타이핑이라고 하고 그렇지 않을 경우는 서브클래싱이라고 한다.
서브타이핑은 설계의 유연성이 목표이고, 서브클래싱은 코드의 중복 제거와 재사용이 목적이다.
서브타이핑은 인터페이스 상속(interface inheritance)라고 하고,
서브클래싱을 구현 상속(implementation inheritance)이라고 한다.

여러 클래스로 구성된 상속 계층에서 수신된 메시지를 이해하는 기본적인 방법은 클래스 간의 위임(delegation)을 사용하는 것이다.
클래스 간의 위임 사슬은 계층 내의 어떤 클래스가 메시지를 처리하거나 최상위 부모 클래스에 위임될 때까지 계속된다.

### 집합과 분해

#### 계층적인 복잡성

허버트 A. 사이먼은 < The Architecture of Complexity >[Simon 1962]에서 호라와 템프스라는 두 명의 시계 제작자와 관련된 우화를 소개한다.
이 우화에서 얻을 수 있는 교훈 두 가지는 다음과 같다.

- 복잡성은 '계층'의 형태를 띤다.
- 단순한 형태로부터 복잡한 형태로 진화하는 데 걸리는 시간은 그 사이에 존재하는 '안정적인 형태'의 수와 분포에 의존한다.

집합의 가치는 많은 수의 사물들의 형상을 하나의 단위로 다뤄 복잡성을 줄인다는 데 있다.
즉, 불필요한 세부 사항을 추상화한다.

집합은 전체의 내부로 불필요한 세부 사항을 감춰주기 때문에 추상화 메커니즘인 동시에 캡슐화 메커니즘이다.

#### 합성 관계

상품 주문의 도메인에서 주문 항목은 반드시 어떤 한 주문의 일부로 생성되므로 주문의 일부여야 한다.
객체와 객체 사이의 전체-부분 관계를 구현하기 위해서는 합성 관계를 사용한다.

합성 관계는 부분을 전체 안에 캡슐화함으로써 인지 과부하를 방지한다.
객체들의 그룹과 관련된 복잡성도 완화된다.

상품과 주문 항목 사이에도 관계가 존재하지만 상품은 주문 항목의 일부가 아니다.
그래서 단순한 물리적 통로가 존재한다는 사실만 나타낸다.
이를 연관 관계라고 한다.

일반적으로 합성 관계로 연결된 객체는 포함하는 객체가 제거되면 내부에 포함된 객체도 함께 제거된다.
연관 관계로 연결된 두 객체는 생명주기와 관련된 제약이 없다.
연관 관계로 연결된 두 객체는 독립적으로 제거될 수 있다.

#### 패키지

소프트웨어의 전체적인 구조를 표현하기 위해 관련된 클래스 집합을 하나의 논리적인 단위로 묶는 구성 요소를 패키지(package) 또는 모듈(module)이라고 한다.

패키지를 이용하면 시스템의 전체적인 구조를 이해하기 위해 한 번에 고려해야 하는 요소의 수를 줄일 수 있다.
개별 클래스가 아닌 클래스의 집합을 캡슐화해서 전체적인 복잡도를 낮출 수 있다.
함께 협력하는 응집도 높은 클래스 집합을 하나의 패키지 내부로 모으면 코드를 이해하기 위해 패키지 경계를 넘나들 필요가 적어진다.