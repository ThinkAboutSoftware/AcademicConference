## 4장 역할, 책임, 협력

> 우리 모두를 합친 것보다 더 현명한 사람은 없다. - 켄 블랜차드(Ken Blanchard)

인간이 어떤 본질적인 특성을 지니고 있느냐가 아니라 어떤 상황에 처해 있느냐가 인간의 행동을 결정한다.
즉, 각 개인이 처해 있는 정황 또는 문맥(context)이 인간의 행동 방식을 결정한다는 것이다.

인간의 행동을 결정하는 문맥은 타인과의 협력이다.
협력이라는 문맥을 무시한 채 각 개인의 반응을 독립적으로 예상하고 관찰하는 것은 무의미하다.
협력에 얼마나 적절한지에 따라 행동의 적합성이 결정되며
협력이라는 문맥이 인간의 행동 방식을 결정하는 것이다.

객체도 마찬가지이다.
객체지향 설계의 전체적인 품질을 결정하는 것은 개별 객체의 품질이 아니라 여러 객체들이 모여 이뤄내는 협력의 품질이다.
협력이 자리를 잡으면 저절로 객체의 행동이 드러나고 객체의 상태가 결정된다.

객체의 모양을 빚는 것은 객체가 참여하는 협력이다.
어떤 협력에 참여하는지가 객체에 필요한 행동을 결정하고,
필요한 행동이 객체의 상태를 결정한다.
개별적인 객체의 행동이나 상태가 아니라 객체들 간의 협력에 집중하라.

### 협력

#### 요청하고 응답하며 협력하는 사람들

협력은 한 사람이 다른 사람에게 도움을 요청할 때 시작된다.
문제를 해결하는데 필요한 지식을 알고 있거나 도움을 받을 수 있는 사람에게 요청하게 된다.
요청을 받은 사람은 일을 처리한 후에 요청한 사람에게 필요한 지식이나 서비스를 제공한다.

#### 누가 파이를 훔쳤지?

앨리스의 이야기: 하트 여왕이 만든 파이를 훔쳐 달아나다 붙잡힌 하트 잭에 대한 공판이 열리는 법정

객체지향 관점에서 재판 장면에 등장하는 모든 등장인물들은 객체이다.
왕
하얀 토끼
모자 장수
이 세 객체는 하트 잭을 재판하기 위해 서로 협력하고 있다.
즉, 하트 잭의 재판이라는 동일한 목적을 달성하기 위해 협력하고 있다.

#### 재판 속의 협력

1. 누군가 왕에게 재판을 요청
2. 왕이 하얀 토끼에게 증인을 부를 것을 요청
3. 하얀 토끼는 모자 장수에게 증인석으로 입장할 것을 요청
4. 모자 장수는 증인석에 입장하는 것으로 응답
5. 왕은 모자 장수에게 증언할 것을 요청
6. 모자 장수는 증언을 통해 왕의 요청에 응답

등장인물들이 특정한 요청을 받아들일 수 있는 이유는 그 요청에 대해 응답하는 데 필요한 지식과 행동 방식을 가지고 있기 때문이다.
요청과 응답은 협력에 참여하는 객체가 수행할 책임을 정의한다.

### 책임

객체지향 세계에서 어떤 객체가 어떤 요청에 대해 응답해줄 수 있거나,
적절한 행동을 할 의무가 있는 경우 해당 객체가 책임을 가진다고 말한다.

크레이그 라만(Craig Larman)은 이렇게 말했다.
"객체지향 개발에서 가장 중요한 능력은 책임을 능숙하게 소프트웨어 객체에 할당하는 것"[Larman 2004]

책임을 어떻게 구현하는가에 대한 문제는 나중에 고려해도 된다.
책임이 확실하지 않은 상태에서 구현 먼저 한다면 변경에 취약하고 다양한 협력에 참여할 수 없는 비자율적인 객체를 낳게 된다.

#### 책임의 분류

크레이그 라만은 책임을 크게 '하는 것'과 '아는 것'의 두 가지 범주로 자세히 분류하고 있다[Larman 2004]

- 하는 것(doing)
  - 객체를 생성하거나 계산을 하는 등의 스스로 하는 것
  - 다른 객체의 행동을 시작시키는 것
  - 다른 객체의 활동을 제어하고 조절하는 것
- 아는 것(knowing)
  - 개인적인 정보에 관해 아는 것
  - 관련된 객체에 관해 아는 것
  - 자신이 유도하거나 개선할 수 있는 것에 관해 아는 것

책임은 객체지향 설계의 품질을 결정하는 가장 중요한 요소다.
명확한 책임이 애플리케이션의 미래를 결정 짓는다.

책임은 외부에서 접근 가능한 공용 서비스의 관점에서 볼 수 있다.
책임은 객체의 외부에 제공해 줄 수 있는 정보(아는 것의 측면)와
외부에 제공해 줄 수 있는 서비스(하는 것의 측면)의 목록이다.
따라서 책임은 객체의 공용 인터페이스(public interface)를 구성한다.

#### 책임과 메시지

객체가 다른 객체에게 주어진 책임을 수행하도록 요청을 보내는 것을 메시지 전송(message-send)이라고 한다.
두 객체간의 협력은 메시지를 통해 이뤄진다.

메시지는 전송하는 객체와 수신하는 객체가 상호 협력하는 문맥을 강조한다.

모자장수: '증언하라'는 책임을 수행, '증언하라'라는 메시지를 수신할 수 있다
왕: '증언하라'는 메시지를 전송, 메시지를 기반으로 왕과 모자 장수 사이의 상호 협력이 가능

책임과 메시지의 수준은 같지 않을 수 있다.
책임을 결정한 후 실제 협력을 정제하면서 이를 메시지로 변환할 때는
하나의 책임이 여러 메시지로 분할되는 것이 일반적이다.

초반 설계는 어떤 객체가 어떤 책임을 가지고 어떤 방식으로 서로 협력해야 하는지에 대한 개요를 아는 것만으로 충분하다.
이 구조가 자리잡기 전까지 구현하는 방법에 대한 고민은 미루는 게 좋다.
협력에 참여하기 위해 메시지를 송수신할 수 있다는 걸 먼저 결정하는 것이 더 중요하다.

객체지향 설계는 어떤 객체가 어떤 책임을 수행해야 하고 어떤 객체로 부터 메시지를 수신할 것인지를 결정하는 것으로 부터 시작한다.
어떤 클래스가 필요하고 어떤 메서드를 포함해야 하는지를 결정하는 건 책임과 메시지에 대한 윤곽을 잡은 후에 시작해도 늦지 않다.

### 역할

#### 책임의 집합이 의미하는 것

재판이라는 협력에서
모자 장수는 '증인' 역할을 수행하고 있고
왕은 '판사' 역할을 수행하고 있다.

어떤 객체가 수행하는 책임의 집합은 객체가 협력 안에서 수행하는 역할을 암시한다.

#### 판사와 증인

판사의 역할을 하는 왕이 앨리스가 증인으로 채택된 시점에 여왕에게 위임한다.
증인 역할을 하던 모자 장수가 퇴장하고 요리사가 등장하고 뒤이어 앨리스가 등장한다.

모자 장수와 요리사가 증언을 하는 재판의 과정은 동일하며 모자 장수가 요리사로 바뀐 것 뿐이다.

앨리스가 증언을 하는 장면에서도 왕은 여왕으로, 증인은 모자 장수와 요리사 자리에 앨리스로 바뀐다.

재판이 이루어지는 과정은 동일하지만 판사와 증인의 역할이 바뀌는 점을 주목해야 한다.

#### 역할이 답이다

등장인물들을 제외한 협력의 과정은 같기 때문에 하나의 협력으로 다루고 싶어진다.

'판사'와 '증인'이라는 역할(role)을 사용하면 세 가지 협력을 모두 포괄할 수 있는 하나의 협력으로 추상화할 수 있다.
역할은 협력 내에서 다른 객체로 대체할 수 있음을 나타내는 일종의 표식이다.
역할은 "이 자리는 해당 역할을 수행할 수 있는 어떤 객체도 대신할 수 있음"을 의미한다.

여기서 역할을 모든 객체가 대체할 수 있는 것은 아니다.
역할을 대체하기 위해서는 각 역할이 수신할 수 있는 메시지를 동일한 방식으로 이해해야 한다.
동일한 역할을 수행할 수 있다는 것은 해당 객체들이 협력 내에서 동일한 책임의 집합을 수행할 수 있다는 걸 의미한다.
이 개념을 제대로 이해하면 객체지향이 제공하는 많은 장점을 얻을 수 있다.

유사한 협력을 추상화하면 인지 과부하가 줄어든다.
다양한 객체들이 협력에 참여할 수 있다면 협력이 유연해지며 재사용성이 높아진다.
역할은 객체지향 설계의 단순성(simplicity), 유연성(flexibility), 재사용성(reusability)을 뒷받침하는 핵심 개념이다.

#### 협력의 추상화

협력의 추상화는 협력의 개수를 줄이면서 구체적인 객체를 추상적인 역할로 대체함으로써 협력의 양상을 단순화한다.
결과적으로 애플리케이션의 설계를 이해하고 기억하기 쉬워진다.

#### 대체 가능성

객체가 역할에 주어진 책임 이외에 다른 책임도 수행할 수 있다.
왕은 판사 역할에서 벗어나면 국정 수행 책임이 있고
모자 장수는 증인의 역할에서 벗어나면 모자를 판매할 책임이 있으며
앨리스는 증인의 역할에서 벗어나면 이야기의 주인공 역할을 해 왔다.

객체는 역할이 암시하는 책임보다 더 많은 책임을 가질 수 있다.
객체의 타입과 역할 사이에 일반화/특수화 관계가 성립하는 것은 일반적이다.

역할의 대체 가능성은 행위 호환성을 의미하고 이는 동일한 책임의 수행을 의미한다.

### 객체의 모양을 결정하는 협력

#### 흔한 오류

시스템에 필요한 데이터를 저장하기 위해 객체가 존재한다는 선입견
객체지향이 클래스와 클래스 간의 관계를 표현하는 시스템의 정적인 측면에 중점을 두는 선입견
두 가지가 있다.

데이터나 클래스를 중심으로 설계하는 이유는 협력이라는 문맥을 고려하지 않고 각 객체를 독립적으로 바라보기 때문이다.
예로 '왕'의 인스턴스를 모델링할 경우 왕의 모습부터 떠올리고 왕의 모습을 기반으로 클래스를 만들기 시작한다.
이 방식이 합리적이고 적절해 보일 수 있지만 실제 동작하는 애플리케이션을 구축하기 위해서는 왕이 참여하는 협력을 우선적으로 고려해야 한다.
중요한 건 왕의 겉모습이 아니다.
재판이라는 협력에서 왕은 '판사'의 역할로 참여해 책임을 수행할 수 있다는 점이 중요하다.

#### 협력을 따라 흐르는 객체의 책임

협력이라는 견고한 문맥이 갖춰지면 초점은 협력을 위해 필요한 책임의 흐름으로 옮겨진다.
협력에 필요한 책임을 결정하고 객체에게 책임을 할당하는 과정을 얼마나 합리적이고 적절하게 수행했는지가 객체지향 설계의 품질을 결정한다.

### 객체지향 설계 기법

역할, 책임, 협력의 관점에서 애플리케이션을 설계하는 유용한 세 가지 기법이 있다.

- 책임-주도 설계(Responsibility-Driven Design) 방법은 협력에 필요한 책임들을 식별하고 적합한 객체에게 책임을 할당하는 방식으로 애플리케이션을 설계한다.
- 디자인 패턴(Design Pattern)은 전문가들이 반복적으로 사용하는 해결 방법을 정의해 놓은 설계 템플릿의 모음이다. 특정 문제 해결을 위해 이미 식별한 역할, 책임, 협력의 모음이다. 이 방법을 안다면 바퀴를 다시 발명할 필요가 없다.
- 테스트-주도 개발(Test-Driven Development)은 테스트를 먼저 작성하고 테스트를 통과하는 구체적인 코드를 추가하면서 애플리케이션을 완성해가는 방식을 따른다. 테스트 주도 개발은 테스트가 아니라 설계를 위한 기법이다. 테스트-주도 개발의 핵심은 테스트 작성이 아니다. 테스트는 별도의 보너스 같은 것이고 실제 목적은 구체적인 코드를 작성해나가면서 역할, 책임, 협력을 식별하고 식별된 역할, 책임, 협력이 적합한지를 피드백받는 것이다.

#### 책임-주도 설계

프로그래밍 과정에서 객체지향 언어 사용이나 UML로 모델링을 해 설게의 밑그림을 그리는 것이
효율적이고 견고한 객체지향 시스템이 보장되는 것은 아니다.
전체 개발 단계에 걸쳐 객체의 역할과 책임, 협력을 도드라지게 만드는 기법과 체계를 따르는 것이 중요하다.
객체지향 시스템을 창조하는 작업은 지속적인 훈련과 견고한 기술, 안정적인 가이드라인을 필요로 한다.

책임-주도 설계[Wirfs-Brock 2003]는 레베카 워프스브록이 고안했다.
이것은 객체의 책임을 중심으로 시스템을 구축하는 설계 방법을 의미한다.

책임-주도 설계는 객체의 책임과 상호작용에 집중한다.
시스템은 스스로 자신을 책임질 수 있는 자율적인 객체이자 다른 객체와 협력하는 객체들로 이뤄진 생태계를 구성한다.

이 기법을 요약하면

- 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악한다.
- 시스템 책임을 더 작은 책임으로 분할한다.
- 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다.
- 객체가 책임을 수행하는 중에 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다.
- 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다.

#### 디자인 패턴

디자인 패턴은 책임-주도 설계의 결과를 표현한다.
패턴은 모범이 되는 설계(example design)[Fowler 2003]다.
앨리스터 코오번에 따르면 이전에 훌륭한 결과물을 모방해 약간의 수정을 거쳐 원하는 결과를 만들어 낸다.[Cockburn 2001]
패턴은 특정 상황에서 설계를 돕기 위해 모방하고 수정할 수 있는 과거의 설계 경험이다.

패턴은 반복해서 일어나는 특정한 상황에서 어떤 설계가 왜(why) 더 효과적인지에 대한 이유를 설명한다.
유명한 책으로 GOF의 < 디자인 패턴 > [GOF 1994]으로 23개의 디자인 패턴을 정리한 책이다.

패턴의 예로 COMPOSITE 패턴이 있는데
패턴의 구성 요소로 클래스와 메서드가 중요한 것이 아니라
'협력'에 참여하는 '역할'과 '책임'이라는 사실이다.

특정 상황에 적용 가능한 디자인 패턴을 알고 있다면 책임-주도 설계의 절차를 순차적으로 따르지 않고
시스템에서 구현할 객체들의 역할과 책임, 협력 관계를 쉽게 포착할 수 있다.

디자인 패턴은 책임-주도 설계의 결과물인 동시에 지름길이다.

#### 테스트-주도 개발

테스트-주도 개발[Beck 2002]은 애자일 방법론의 한 종류인 XP의 기본 프랙티스로 소개된 설계 기법이다.
테스트를 통과하는 코드 작성 후 리팩터링[Fowler 1999]을 통해 중복을 제거하면
작동하는 깔끔한 코드(clean code that works)를 얻을 수 있다.

테스트-주도 개발은 객체에게 어떤 메시지를 전송할 것인지에 대해 먼저 생각해야 한다.
만약 그렇지 않다면 역할, 책임, 협력의 관점에서 객체를 바라보지 못하므로 무의미한 방법일 수 있다.

테스트-주도 개발은 테스트를 작성하는 것이 아니라 책임을 수행할 객체 또는 클라이언트가 기대하는 객체의 역할이
메시지를 수신할 때 어떤 결과를 반환하고 그 과정에서 어떤 객체와 협력할 것인지에 대한 기대를 코드의 형태로 작성하는 것이다.

사전 설계 없이 테스트-주도 개발을 진행하는 개발자들은 
책임-주도 설계의 단계적인 절차와 기법들을 짧은 시간에 감각적으로 수행할 수 있다.
때로는 특정 패턴을 목표로 빠르게 테스트를 작성할 수도 있다.

테스트-주도 개발은 책임-주도 설계를 통해 도달해야 하는 목적을 테스트라는 방법을 통해
더 빠르고 견고한 방법으로 도달할 수 있도록 해주는 최상의 설계 프랙티스이다.

테스트-주도 개발은 객체지향에 대한 깊이 있는 지식을 요구한다.
테스트를 작성하기 위해서는 객체가 수행해야 하는 책임에 관해 생각해야 한다.
스텁(stub)이나 목(mock)을 사용하는 것은 객체와 협력해야 하는 합력에 대해 고민한 결과를 코드로 표현한 것이다.