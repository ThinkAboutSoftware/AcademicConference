# ch03. 관계형 데이터베이스 매핑

## 내용
- 아키텍처 패턴
	- 행 데이터 게이트웨이: 단일 레코드에 대한 게이트웨이 역할을 하는 객체
		- 한 인스턴스가 한 행을 처리
		- 객체지향적 사고방식과 어울림
	- 테이블 데이터 게이트웨이: 테이블에 대한 게이트웨이 역할을 하는 객체
		- 한 인스턴스가 테이블의 모든 행을 처리 
		- 레코드 집합과 잘 어울려 테이블 모듈을 사용하는 경우에 적합
		- 저장 프로시저의 모음으로 사용 가능
	- 간단한 애플리케이션
		- 활성 레코드: 도메인 객체가 테이블과 상호작용
	- 복잡한 애플리케이션
		- 데이터 매퍼: 객체와 테이블간의 매핑을 간접 계층(매퍼)를 통해 격리
	- 객체지향 데이터베이스
		- 생산성 향상
		- 위험성때문에 많이 사용되지 않음
		- 객체지향 DB를 사용하지 않더라도 설계에 도메인 모델이 있다면 O/R 매핑 툴을 도입하는 것이 좋음
- 동작 문제
	- 일관성 문제
		- 로드하는 객체가 많으면 이에 대한 변경사항을 추적하기가 어려움
	- 작업 단위
		- 데이터베이스 매핑 컨트롤러의 동작을 별도의 객체로 팩터링해서 만듬
		- 지연 로드를 통해 성능 개선
- 데이터 읽기
	- 여러 행을 한 번에 읽기(비관적 동시성 제어시 너무 많이 읽는 것을 주의)
	- 조인 쿼리 이용(오히려 성능이 저하될 수 있음)
	- 애플리케이션 프로파일링!!
- 구조적 매핑 패턴
	- 관계 매핑
		- 객체과 RDBMS가 관계를 처리하는데 차이가 있음
			- 참조 방법의 차이(객체는 참조/RDBMS는 외래 키)
			- 여러 개의 객체(행)을 처리하는 방식(객체는 컬렉션/RDBMS는 X)
	- 상속
		- RDBMS에서의 상속 처리는 매핑을 이용
			- 단일 테이블 상속: 한 테이블에 다 넣음
			- 구현 테이블 상속: 각 테이블이 공통된 필드도 갖고 있음
			- 클래스 테이블 상속: 공통 필드를 별도의 테이블의 필드로 뺌
- 매핑
	- 도메인 모델 매핑시 DB를 염두하지 말고 도메인 논리를 간소화 하는데 집중
	- 도메인 모델을 먼저 구성하고 주기적(단기간내에)으로 DB에 통합
	- 스키마가 있는 경우
		- 도메인 논리가 간단
			- DB를 모방하는 게이트 웨이 클래스를 만들고 이 위에 도메인 논리 배치
		- 도메인 논리가 복잡
			- 도메인 모델이 필요, DB 설계와 일치하지 않을 가능성이 높음
			- 도메인 모델을 점진적으로 구축하면서 기존 DB에 저장할 데이터 매퍼를 이용
	- 이중 매핑
		- 데이터 원본마다 하나씩 매핑 계층을 여러 개로 만드는 것이 기본
		- 코드 중복이 심한 경우
			1. 데이터를 인메모리 스키마에서 논리적 데이터 저장소 스키마로 변환
				- 데이터 원본 포맷의 유사성을 극대화하도록 설계
			2. 논리적 데이터 저장소 스키마에서 실제 물리적 데이터 저장소 스키마로 매핑
- 메타데이터 사용
	- 메타데이터 매핑
		- DB의 열이 객체의 필드에 매핑되는 구체적인 방법을 메타데이터 파일에 기록하는 것
	- 쿼리 객체
		- 메타데이터 매핑을 이용해 객체 필드에 대한 정보를 적절한 SQL로 변환
- 데이터베이스 연결
	- 연결 풀
		- 연결을 만드는데 드는 비용 절약
		- 개발자가 연결을 직접 관리하지 않고 풀에 요청
- 기타 주의사항
	- `select *`을 사용하지 않는 것이 좋음