# ch16. 오프라인 동시성 패턴

## 내용

- 낙관적 오프라인 잠금
  - 충돌이 감지되면 트랜잭션을 롤백해 동시 비즈니스 트랜잭션 간의 충돌 방지
  - vs 비관적 오프라인 잠금
    - 비관적 오프라인 잠금은 세션 충돌 가능성이 높다고 간주하고 시스템의 동시성을 제한
    - 낙관적 오프라인 잠금은 세션 충돌 가능성이 낮다고 간주하고 동시 작업 허용
  - 한 세션에서 커밋하려는 변경 내용이 다른 세션의 변경 내용과 충돌하는지 확인
    - 이렇게 획득한 잠금은 해당 트랜잭션안에서만 유효
    - 따라서 비즈니스 트랜잭션은 변경되는 모든 멤버에 대한 낙관적 오프라인 잠금을 획득해야 함
  - 낙관적 오프라인 잠금 구현 방법
    - 시스템의 각 레코드에 버전 번호를 연결
      - 레코드가 로드되면 버전 번호는 다른 모든 세션 상태와 함께 세션에 의해 유지 관리
      - 즉, 낙관적 오프라인 잠금을 얻는다는 것은 세션 데이터에 저장된 버전을 레코드 데이터의 현재 버전과 비교하는 것
      - 버전 번호와 함께 마지막 수정자, 수정시간을 함께 저장하면 동시성 충돌 관리에 유용
        - 낙관적 검사에 버전 번호 대신 수정 타임스탬프를 사용하는 것은 좋지 않음
        - 시스템 클록은 신뢰할 수 없으며, 여러 서버 간에 작업이 조율된 경우 더욱 신뢰하기 어려움
    - SQL의 `where`에 행의 모든 필드를 포함
      - where 절이 복잡해질 수 있고, 이 경우 기본 키 인덱스를 사용하는 방법에 따라 성능에 영향을 줄 수 있음
  - 일관성 없는 읽기 문제는 해결되지 않음
    - 버전 다시 읽기
      - 반복 가능 읽기 이상의 격리 수준에서만 작동
      - 이보다 낮은 격리 수준에서는 버전 증사를 사용
    - 굵은 입자 잠금을 이용
      - 객체 그룹을 하나의 잠금 항목으로 취급해 특정한 일관성 없는 읽기 문제 해결에 도움
  - 트랜잭션이 동적 쿼리의 결과에 의존하는 경우 일관성 없는 읽기 감지가 더 어려움
    - 초기 결과를 저장했다가 커밋시에 동일한 쿼리의 결과와 비교해서 감지 가능
  - 동시성 관리는 기술적 문제이기도 하지만 도메인 문제이기도 함
  - 비즈니스 트랜잭션의 커밋 여부를 마지막 시스템 트랜잭션이 돼서야 알려줌
    - 충돌 여부를 미리 알 수 있으면 유용한 경우가 있음
    - 충돌 여부를 확인할 수 있는 체크 메서드를 제공해 실패가 예상되는 경우 미리 체크
- 비관적 오프라인 잠금
  - 한 시점에 한 트랜잭션만 데이터에 접근할 수 있게 해서 동시 비즈니스 트랜잭션 간 충돌 방지
  - 충돌 가능성이 높은 상황에 적합
    - 낙관적 잠금은 모든 트랜잭션 작업을 완료한 후에야 충돌 여부를 알 수 있음
    - 호흡이 긴 비즈니스 트랜잭션에서 시스템에 대한 신뢰가 떨어짐
  - 작업 시작시 대상 데이터에 대한 잠금을 획득하므로 동시성 제어 문제로 작업이 실패하는 경우가 거의 없음
  - 비관적 오프라인 잠금의 구현
    - 필요한 잠금 유형 결정
      - 배타적 쓰기 잠금(exclusive write lock)
        - 편집하려는 경우에만 잠금 요구
        - 두 비즈니스 트랜잭션이 동일 레코드를 동시에 변경하지 못하게 함
        - 읽기와 관련된 문제는 무시 -> 반드시 최신 데이터를 읽어야 하는 경우 부적합
      - 배타적 읽기 잠금(exclusive read lock)
        - 비즈니스 트랜잭션이 레코드를 로드하려는 경우에도 잠금 요구
        - 항상 최신 데이터를 읽어야 하는 경우 사용
        - 시스템의 동시성을 심각하게 제한할 가능성이 있음
      - 읽기/쓰기 잠금(read/write lock)
        - 배타적 쓰기 잠금과 배타적 읽기 잠금의 장점을 결합
    - 잠금 관리자 작성
      - 잠금 획득 또는 해제하려는 비즈니스 트랜잭션의 요청을 허용/거부
      - 잠그려는 데이터와 잠금의 소유자(비즈니스 트랜잭션)에 대한 정보가 필요
      - 비즈니스 트랜잭션이 고유 식별 개념이 아닐 경우 세션 적용을 고려
      - 잠금 테이블은 오직 하나여야 하며, 메모리에 있는 경우 싱글턴을 사용
      - 클러스터링된 애플리케이션 서버 환경에서는 DB 기반 잠금 관리자가 적합할 수 있음
    - 잠금을 사용할 비즈니스 트랜잭션의 절차(프로토콜) 정의
      - 프로토콜은 잠금 대상과 시기, 잠금 해제 시기, 잠금 획득 실패시 대처 방법 등을 포함
      - 잠금 시기
        - 일반적으로 비즈니스 트랜잭연은 데이터를 로드하기 전에 잠금 획득
        - 비관적 오프라인 잠금 획득 후 해당 항목에 대한 낙관적 검사하는 방법도 있음
      - 잠금 대상
        - 객체나 레코드가 아닌 객체를 찾는데 사용하는 ID 또는 기본 키를 잠그는 것
        - ID 또는 기본 키를 잠궈야 로드하기 전에 잠금을 획득할 수 있음
      - 잠금 해제 시기
        - 간단한 규칙은 비즈니스 트랜잭션이 완료되면 잠금 해제
        - 미리 해제해도 되지만 까다로운 시스템 활동성 문제와 같은 명확한 이유가 아니면 완료 후 해제
      - 잠금 획득 실패시 대처 방법
        - 가장 쉬운 대응은 작업 취소. 트랜잭션 초기에 실패하므로 사용자가 큰 거부감을 느끼지 않음
        - 때문에 가능하면 사용자가 작업을 시작하기 전에 모든 잠금 획득하는 것이 좋음
    - 잠금 세분성(lock granularity)
      - 잠금 관리의 직렬화로 인해 성능 병목현상이 생김
      - 잠금의 수를 줄일수록 병목현상이 적게 발생하므로 굵은 입자 잠금으로 잠금 테이블 경합 완화
- 굵은 입자 잠금(Coarse-Grained Lock)
  - 하나의 잠금으로 여러 관련 객체의 집합을 잠금
  - 잠금 동작 자체를 간소화할 수 있고, 그룹을 잠그기 위해 모든 멤버를 로드할 필요도 없음
  - 객체 그룹을 잠그기 위한 단일 경합 지점을 만들어 이를 통해 하나의 잠금으로 전체 잠금
    - 낙관적 오프라인 잠금의 경우 그룹의 각 항목이 버전을 공유하면 단일 경합 지점을 만들 수 있음
    - 비관적 오프라인 잠금의 경우 그룹의 각 멤버가 일종의 잠금 가능 토근(lockable token)을 공유 획득해야함
- 암시적 잠금(Implicit Lock)
  - 프레임워크나 계층 상위 형식 코드에서 오프라인 잠금을 얻을 수 있게 함
  - 절대 생략할 수 없는 잠금 메커닉을 애플리케이션 프레임워크에서 자동으로 수행
