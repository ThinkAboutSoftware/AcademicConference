### 분리 인터페이스

> 구현과 분리된 별도의 패키지에 인터페이스를 정의한다

<img width="541" alt="image" src="https://github.com/jongfeel/BookReview/assets/17442457/cfd3d7a4-3861-4671-ad18-70d04e75626f">

일반적인 의존성 구조를 위반하고 메서드를 호출해야 하는 경우
분리 인터페이스(Separated Interface)를 사용해 한 패키지에 인터페이스를 정의하고 다른 곳에서 구현할 수 있다.
분리 인터페이스는 `게이트웨이`를 연결할 수 있는 좋은 위치다.

#### 작동 원리

구현은 해당 인터페이스에 의존하지만 그 반대는 해당되지 않는다는 점을 활용한다. (그림 참고)

인터페이스의 구현이 아예 없으면 런타임에 소프트웨어가 제대로 작동하지 않는다.
이 문제는 컴파일 시 둘을 연결하는 별도의 패키지를 사용하거나 구성 시 `플러그인`을 사용해 해결할 수 있다.

인터페이스는 다른 패키지(그림 18.1)에 넣을 수 있다.
구현에 대한 클라이언트가 단 하나이거나 모든 클라이언트가 동일한 패키지에 있는 경우
인터페이스를 클라이언트와 함게 넣는 것이 낫다.
클라이언트 패키지는 자신이 정의하는 인터페이스를 구현하는 다른 모든 패키지와 함께 작업한다는 것을 나타낸다.

**Figure 18.1. Placing the Separated Interface in a third package.**
<img width="670" alt="image" src="https://github.com/jongfeel/BookReview/assets/17442457/ff8d3a3a-98df-4beb-96ac-1aa3308476d5">

인터페이스에서 사용할 언어 기능에 대해서도 고려해야 한다.
자바나 C#같이 인터페이스 구조를 가진 언어는 인터페이스 키워드를 사용한다.
이것이 최선의 방법은 아닐 수 있기 때문에 공통적이고 선택적인 구현 동작을 포함하는 추상 클래스도 인터페이스로 사용하는 데 아주 적합하다.

분리 인터페이스는 구현을 인스턴스화하기가 불편할 수 있다.
별도의 팩터리 객체와 팩터리에 대한 분리 인터페이스를 사용하는 게 방법이다.
이 경우 구현을 팩터리에 바인딩해야 하고 여기에 `플러그인`을 사용한다.
이렇게 하면 의존성이 없어지고 구현 클래스에 대한 결정을 구성 시점까지 연기할 수 있다.

`플러그인`을 사용하고 싶지 않다면 인터페이스와 구현을 모두 인식하는 다른 패키지를 사용해
애플리케이션 시작 시 해당 객체를 인스턴스화 하는 방법이 있다.
분리 인터페이스를 사용하는 객체는 직접 인스턴스화하거나 시작 시 팩터리를 사용해 인스턴스화할 수 있다.

#### 사용 시점

다음의 적용 예를 생각해 볼 수 있다.

- 프레임워크 패키지에 넣은 범용 추상 코드에서 특정한 애플리케이션 코드를 호출해야 한다.
- 한 계층의 코드에서 볼 수 없어야 하는 다른 계층의 코드를 호출해야 한다. (예: 도메인 코드에서 `데이터 매퍼`를 호출하는 경우)
- 다른 개발 그룹에서 개발한 함수를 호출해야 하지만 해당 API에 대한 의존성을 원하지 않는다.

의존성을 제거하려는 경우 또는 여러 독립적 구현을 사용하려는 경우에만 분리 인터페이스를 사용한다.
인터페이스와 구현을 한 곳에 넣고 나중에 분리해야 한다면 필요할 때 까지 연기할 수 있는 간단한 리팩터링이 된다.

직접적인 의존성 관리는 지나친 수준이 되지 않아야 한다.
객체를 생성하기 위한 의존성만 유지하고 이후에는 인터페이스를 사용하는 정도면 충분하다.