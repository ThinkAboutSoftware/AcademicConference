### 서버 세션 상태

> 세션 상태를 직렬화된 형식으로 서버 시스템에 저장한다.

#### 작동 원리

단순한 형식으로 서버 메모리에 세션 객체를 저장한다.
세션 객체를 저장하는 맵을 메모리에 올리고 세션 ID를 키로 사용한다.
클라이언트에서 세션 ID를 받으면 세션 객체를 검색하고 요청을 처리한다.

이 단순한 시나리오는 서버가 작업을 수행할 메모리를 충분히 보유하고 있다고 가정한다.
서버가 클러스터링 되지 않는 한 개의 서버여야 하고
충돌이 발생하면 세션이 손실되서 작업이 취소되도 괜찮을 때여야 한다.

이런 가정을 적용할 수 없는 서버의 경우 간단한 패턴의 여러가지 변형과 복잡한 개념을 추가해 해결 방법을 적용해야 한다.

문제는 세션 객체를 저장하는 데 필요한 메모리 자원을 확보해야 한다.
해결 방법으로 자원을 메모리에 유지하지 않고 지속적 저장소에 메멘토[Gang of Four]로 직렬화하는 것이다.
그러면 서버 세션 상태를 어떤 형식으로 어디에 저장해야 할지 결정하면 된다.

서버 세션 상태를 저장하는 방식으로 이진 형식이 쉬우며 텍스트 형식은 프로그래밍이 필요하다.
직렬화된 그래프가 아주 크면 메모리로 활성화하는 데 오래 걸릴 수 있다.

이진 직렬화에 대한 두 가지 일반적인 문제가 있다.
첫째, 직렬화된 형식은 사람이 알아볼 수가 없다.
둘째, 버전 제어와 관련된 문제가 있을 수 있다. 객체 형식이 바뀌면 기존 직렬화된 형식을 읽지 못할 수 있다.

서버 세션 상태를 저장할 위치를 고려해야 한다.
파일 시스템이나 로컬 데이터베이스를 사용할 수 있지만 클러스터링이나 장애 조치는 지원하지 않을 수 있다.
일반적으로 접근 가능한 공유된 서버와 같은 곳에 저장하면 서버를 활성화하는데 시간이 걸릴 수 있지만
클러스터링과 장애 조치를 지원할 수 있게 된다.
시간은 캐싱을 사용해 크게 줄일 수 있다.

직렬화된 서버 세션 상태를 데이터베이스에 저장하는 데 세션 ID로 인덱싱이 되는 세션 테이블이 필요하고 `직렬화 LOB`가 필요하다.
대형 객체를 다루는 성능은 데이터베이스마다 다르다.

서버 세션 상태의 데이터를 테이블 형식으로 변환하는 시점의 경계는 `데이터베이스 세션 상태`이다.

세션 상태를 데이터베이스에 저장하는 경우 세션을 삭제하는 방법에 대해 고려해야 한다.
오래된 세션을 찾고 삭제하는 데몬을 사용할 수 있지만 세션 테이블에 대한 경합을 악화시킬 수 있다.
세션 테이블을 12개의 데이터베이스 세그먼트로 분할하고 2시간마다 세그먼트를 회전시켜 가장 오래된 세그먼트의 내용을 모두 삭제하고 여기에 새로운 항목을 삽입하는 방법도 있다.

최근 서버에서 이런 기능을 자동으로 처리해주는 서버가 늘어나고 있다.
이런 기능을 사용하면 개발자 입장에서 걱정할 필요가 없다.

##### 자바 구현

http 세션과 상태 저장 세션 빈 두 가지가 있다.
http 세션은 세션 데이터를 웹 서버에 저장하는 간단한 방법이다.
하지만 서버 선호도 문제와 장애 조치 지원이 안된다.
일부 개발사에서 http 세션 데이터를 데이터베이스에 저장하는 기능을 구현하고 있다.

다른 방법으로 상태 저장 세션 빈을 사용하는 것이다.
EJB 서버가 필요하며 EJB 컨테이너는 지속성과 안정성을 위한 모든 기능을 제공해준다.
단점은 서버 선호도(server affinity)를 방지하도록 요구하지 않는다는 것이다.
IBM의 웹스피어는 상태 저장 세션 빈을 DB2의 BLOB으로 직렬화해 여러 애플리케이션 서버가 세션 빈의 상태에 접근할 수 있게 해준다.

상태 비저장 방식의 성능과 장태 저장 빈이 사용하기 수월한 경우 이를 사용해야 한다.
상태 저장 빈의 경우 장애 조치가 어려운 경우나 부하가 높은 상황에서만 성능상의 차이가 나타나는 경우도 있다.

대안으로 엔티티 빈을 사용한다. 그러면 세션 데이터의 `직렬화 LOB`를 저장할 수 있다.

##### .NET 구현

기본 제공 세션 상태 기능을 사용하면 된다.
.NET은 기본적으로 세션 데이터를 서버 프로세스 자체에 저장한다.
또 로컬 저장소나 네트워크 상의 상태 서비스로 변경도 할 수 있다.
세션 상태 서비스가 있기 때문에 웹 서버가 재설정되도 세션 상태 유지가 가능하다.
구성 파일의 서비스 상태와 프로세스 내 상태 사이에서 변경이 일어나므로 애플리케이션은 변경할 필요가 없다.

#### 사용 시점

단순하기 때문에 프로그래밍이 없어도 사용 가능한 경우가 많다.
기본 기능 사용 여부는 인메모리 구현으로 충분한지와 서버 플랫폼에서 제공하는 지원 수준에 따라 달라진다.

기본 기능을 사용하지 않아도 BLOB을 데이터베이스 테이블로 직렬화 하는 작업으로 대체하면 되며
이는 서버 객체를 테이블 형식으로 변환하는 작업에 비하면 훨씬 수월하다.

클러스터링과 장애 조지를 직접 지원해야 하는 경우 프로그래밍 작업이 필요하다.
세션 데이터가 많지 않거나 세션 데이터를 테이블 형식으로 쉽게 변환할 수 있는 경우는 프로그래밍 보다 다른 방법을 사용한다.