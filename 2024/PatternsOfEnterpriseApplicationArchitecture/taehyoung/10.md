# 10장 데이터 원본 아키텍쳐 패턴

# 논의 내용

- 저는 개인적으로, 행 데이터 게이트웨이와 활성 레코드 패턴을 사용하는 웹프레임워크를 기준으로만 일을 하다보니, 이 방식에 매우 익숙한데요 데이터 매퍼가 도메인 모델링과 조합했을 때, 복잡한 비즈니스 로직을 처리하기 좋다고 말하는데, 이게 아직 해보지는 않아서 잘 와닿지는 않는 것 같습니다 둘다 써보신 경험이 있다면, 어떠셨는지 경험이 궁금 합니다

# 내용 & 내 생각

## 테이블 데이터 게이트웨이

- 데이터베이스 테이블에 대한 게이트웨이 역할을 하는 객체이고, 한 인스턴스가 테이블의 모든 행을 처리한다
- 테이블과 매칭 되는 인스턴스 하나를 기준으로 데이터베이스와의 모든 상호작용을 수행 한다
- 테이블 데이터 게이트웨이에서 가장 어려운 부분은 쿼리로부터 정보를 반환하는 방법인데, 데이터 전송 객체를 사용하는 것이 나은 방법이다
- 테이블 데이터 게이트웨이는 데이터베이스 테이블당 하나씩 사용하는 경우가 많은데, 아무 간단한 경우에는 테이블 데이터 게이이트웨이 하나로 모든 테이블의 모든 메서드를 처리하게 할 수도 있다
- 테이블 데이터 게이트웨이는 데이터베이스 테이블이나 레코드 형식이 잘 매핑되므로 가장 간단하게 사용할 수 있는 데이터베이스 인터페이스 패턴이다.

## 행 데이터 게이트웨이

- 데이터 원본의 단일 레코드에 대한 게이트웨이 역할을 하는 객체이고, 행마다 인스턴스 하나가 사용된다
- 게이트웨이는 데이터의 각 행에 대한 인터페이스 역할을 한다.
- 행 데이터 게이트웨이와 활성 레코드 간의 차이를 구분하기 어려운 경우가 많다 라고 하는데, 실제로 지금까지 읽으면서, 행마다 인스턴스 하나가 사용된다는 것을 기준으로 보면 둘다 같은 것이지 않을까? 라는 생각을 했는데, 도메인 논리가 있는지 없는지로 판단할 수 있다 행 데이터 게이트웨이는 데이터베이스 접근 논리만 포함하고 도메인 논리는 포함하지 않아야 한다.
- 그래서 장고의 ORM은 데이터베이스 테이블과 매핑하고 있는 모델 클래스들이 비즈니스 로직을 가지는 Fat model로 설계하는 것을 철학으로 가지고 있기 때문에, Fat model의 형태로 비즈니스 로직을 모델 클래스 내에서 구현한다면, 이는 액티브 레코드 패턴으로 볼 수 있을 것 이다. 반면에, 비즈니스 로직은 별개의 서비스 레이어로 추출하면서, 모델 클래스를 단순히 테이블과 매칭된 게이트웨이로 본다면, 이는 행 데이터 게이트웨이로 볼 수 있을 것 이다
- 트랜잭션 스크립트 패턴과 행 데이터 게이트웨이는 같이 사용하기 좋다고 한다 그 이유를 추측 해보자면, 트랜잭션 스크립트 패턴은 비즈니스 로직을 스크립트 형태의 코드를 작성하는 과정에서 작성하기 때문에, 행 데이터 게이트웨이는 단순히 DB로 부터 값을 가져오기위한 게이트 역할만 하면 되기 때문일 것이다

## 활성 레코드

- 데이터베이스 테이블이나 뷰의 행을 래핑하고, 데이터베이스 접근을 캡슐화하며, 해당 데이터에 대한 도메인 논리를 추가하는 객체
- 객체에는 데이터와 동작이 모두 포함된다. 활성 레코드는 데이터 접근 논리를 도메인 객체에 넣는 가장 합리적인 방식을 사용한다.
- 객체에 데이터와 동작이 모두 포함된다는 얘기는 데이터는 테이블에 저장된 값이라고 할 때, 동작은 클래스 이하의 메소드 라고 볼 수 있고, 즉, 비즈니스 로직 구현을 도메인 모델 메소드 에 구현을 한다는 것으로 이해할 수 있다
- 활성 레코드는 생성, 읽기, 갱신, 삭제와 같은 기본적인 도메인 논리를 처리하는데 적합하다. 그래서 장고의 경우도 이 CRUD 동작을 빠르게 개발하는데 매우 최적화 되어 있다 그거란 활성 레코드의 주된 문제는 활성 레코드 객체가 데이터베이스 테이블과 일대일로 대응되는 동형 스키마일 때만 잘 작동한다는 것이다. 비즈니스 논리가 복잡한 경우 객체의 직접 관계, 컬렉션, 상속 등을 사용하고 싶어 지는데, 이는 활성 레코드에 어울리지 않으며 억지로 적용하다보면 엉망진창이 될 수 있다
- 활성 레코드를 반대하는 의견 중 하나는 활성 레코드가 객체 설계를 데이터베이스 설계와 결합한다는 것이고, 개인적으로 이 때문에 필연적으로 데이터베이스 설계가 매우 중요하고, 설계를 제대로 하지 못했을 때, 애플리케이션 비즈니스 로직 구현 코드가 매우 구현하기 힘들거나, 유지보수하기 힘든 형태로 바뀌게 된다

## 데이터 매퍼

- 객체와 데이터베이스 사이에서 둘 사이는 물론 매퍼 자체에 대한 독립성을 유지하면서 데이터를 옮기는 매퍼의 한 계층이다
- 데이터 매퍼는 인메모리 객체를 데이터베이스로부터 분리하는 소프트웨어 계층이다. 인메모리 객체와 데이터베이스 사이에서 데이터를 전송하고 동시에 둘을 서로 격리하는 것이다. SQL 인터페이스 코드가 불필요한 것은 물론 데이터베이스 스키마에 대해서도 알 필요가 없다.
- 데이터 매퍼의 주 기능은 도메인과 데이터 원본과의 분리이다.
- 도메인 모델과 함께 데이터 매퍼를 사용하면 설계와 구축, 그리고 테스트 프로세스에서 데이터베이스를 고려할 필요가 없다. 데이터 원본인 DB로 부터 직접적으로 소통하는 구간은 데이터 매퍼가 담당하고, 도메인 모델은 데이터 매퍼와의 통신을 하면 되기 떄문이다
- 도메인 모델이 아주 간단하고 도메인 모델 개발자가 데이터베이스도 관리하고 있다면, 도메인 객체가 활성 레코드를 사용해 직접 데이터베이스에 접근하는 것이 합리적이다
- 데이터 매퍼를 사용하는 주된 이유는 데이터베이스 스키마와 객체 모델을 분리해서 발전시킬 수 있기 때문이고, 가장 일반적인 경우가 도메인 모델과 함께 사용하는 경우이다 도메인 객체는 데이터베이스 구조에 대해 알 필요가 없다
- 저자는 도메인 모델을 사용하지 않는다면 데이터 매퍼도 선택하지 않을 것 이라고 하는데, 도메인 모델이 복잡하다면, 도메인 모델 + 데이터 매퍼, 도메인 모델이 복잡하지 않다면, 활성레코드 사용을 말하고 있다 그 이유는 데이터 매퍼를 만들고 관리하는 비용이 들기 때문에, 모든 상황에서 데이터 매퍼를 만들어서 운영하는 게 정답은 아니기 때문이다