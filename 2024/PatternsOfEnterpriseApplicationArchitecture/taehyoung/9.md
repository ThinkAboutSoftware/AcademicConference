# 9장 도메인 논리 패턴

# 논의 내용

1. 회사 업무로 웹 개발을 할 때를 기준으로, 서비스 레이어에서, 본인 혹은 회사의 주된 구현 방식은 어떤지 궁금합니다. 저희 팀에서는 도메인 모델링을 일부 활용하지고 있지만 대부분의 경우는 작업 스크립트 방식으로 내부 로직을 트랜잭션 스크립트 패턴으로 구현하고 있습니다

# 내용 & 내 생각

## 트랜잭션 스크립트

- 비즈니스 논리를 프로시저별로 구성해 각 프로시저가 프레젠테이션의 단일 요청을 처리하게 하는 것을 말한다
- 단순하게 입력을 받고, 데이터베이스에 정보를 얻고, 필요한 작업을 한 후, 결과를 데이터베이스에 저장하는 과정 자체를 하나의 트랜잭션으로 보고, 이것을 프로시저(함수) 단위로 묶어 두고, 실행하는 것을 말한다
- 트랜잭션 스크립트에는 프레젠테이션 논리에 대한 호출을 전혀 포함하지 말아야 하고, 이렇게 되면, 트랜잭션 스크립트 코드를 수정하고, 테스트하기가 수월 해진다. 각각의 책임을 분리한다는 관점에서 트랜잭션 스크립트에서는 하나의 트랜잭션으로 표현될 수 있는 비즈니스 로직에 대한 역할만을 담당하고, 그 결과 값을 받아서, 화면에 어떻게 보여줘야할지에 대한 책임은 프레젠테이션 레이어의 책임으로 보는 것이다. 이렇게 되면, 트랜잭션 스크립트 코드 자체의 수정, 테스트 용이성이 생길 뿐 아니라, 프레젠테이션 레이어 에서도 마찬가지 효과를 가질 수 있게 된다
- 트랜잭션 스크립트의 가장 큰 장점은 구현이 단순하다는 것이다 그래서 작은 규모의 논리가 포함된 애플리케이션에서는 적합한 방법으로 볼 수 있다
- 그러나, 구현이 복잡해질 수록 트랜잭션 스크립트 방식이 맞을지에 대한 고려가 필요하다. 특히 문제가 되는 부분은 트랜잭션 간의 코드 중복이다 이 코드 중복은 적절하게 공통 코드를 뽑아내서 해결하는 형태로 해결할 수 있지만, 이것 역시 상대적으로 덜 복잡한 로직에서 효과적이지 로직이 복잡하면 복잡해질 수록 유지보수가 쉽지 않은 것이 사실이다
- 그래서 책에서는 도메인 모델을 통해서, 이런 복잡성에 대해서 대체를 하자고 말하고 있고, 나도 어느정도 동의하는 바이다 but, 그러나 트랜잭션 스크립트 패턴이 필요할 때는 써주는게 오히려 더 이득이 될 때도 있으니, 적절하게 유연성을 가지고 반영해주는게 좋다고 생각한다
- 책의 수익 인식 코드를 보면, DB로 부터 쿼리하는 부분은 raw sql + 테이블 데이터 게이트웨이를 이용하는데, 내 생각에는 raw query를 쓰던 ORM 프레임워크를 활용하던 그것 자체는 이게 트랜잭션 스크립트 패턴이냐 아니냐에는 그리 중요한 요소 같진 않다

## 도메인 모델

- 애플리케이션에서 도메인 모델을 구현하는 과정은 비즈니스 영역을 모델링하는 객체로 구성된 계층으로 구성하는 과정이다. 즉, 현실세계에서의 문제영역을 코드로 매핑을 하는 것으로 볼 수 있다
- 이 도메인 모델은 결국 객체지향 설계와 거의 똑같은 말로 볼 수 있다
- 도메인 모델에는 2가지가 존재하는데, 단순 도메인 모델과, 리치 도메인 모델 이다. 단순도메인 모델은 데이터베이스 설계와 거의 비슷해보이는 반면, 리치 도메인 모델은 상속, 전략, 다양한 디자인 패턴 등으로 복잡하게 상호 연결된 객체의 연결망을 포함하고, DB 설계와는 다른것으로 볼 수 있다
- 이런 특징들로 인해서, 단순 도메인 모델은 활성 레코드 패턴을 사용할 수 있고, 이것은 django framework의 빠른 개발에 큰 도움을 줬다고 볼 수 있다
- 반면에, 리치 도메인 모델의 경우는 데이터 베이스 테이블과 객체를 매핑시키기 쉽지 않기 때문에 데이터 매퍼 패턴을 사용해야 한다
- 도메인 모델을 쓸 것인지 아닌지에 대해서 가장 중요한 것은 시스템이 수행하는 동작의 복잡도이다. 복잡하고 끊임없이 변하는 비즈니스 규칙을 구현해야 한다면, 객체 모델을 사용해 비즈니스 규칙을 처리하는 것이 현명한데, 그 이유는 OCP 원칙과 관련있다고 볼 수 있는데, 기본적으로 트랜잭션 스크립트 패턴은 수정에 닫혀 있지 않기 때문이다 물론, 도메인 모델링 설계를 OCP원칙에 맞지 않게 했다면, 같은 문제가 발생할 수 있지만, 기본적으로 객체 설계 시에는 OCP 원칙을 지키도록 하기 때문에 그것을 전제로 생각했을 때는 복잡한 비즈니스 로직을 처리할 때는 도메인 모델이 더 적합하다고 볼 수 있을 것 같다
- 그러나 분명한것은 그리 복잡하지 않다면, 트랜잭션 스크립트 패턴 자체로 구현하는 것이 여전히 더 좋은 방법이라고 생각한다
- 이 도메인 모델을 적용하기 쉽지 않은 이유는 개발 팀이 도메인 객체를 이용하는데 익숙하지 않은 경우가 많아서 일 것 같다
- 객체에서 객체로 전달하는 객체지향의 습관은 동작을 처리하기에 가장 적절한 객체로 이동할 뿐 아니라, 조건부 동작도 대부분 해결해주는데, 개인적으로는 이부분에 대한 경험을 해본 사람만이 도메인 모델링의 가치를 이해하고 적용할 수 있다고 생각한다 트랜잭션 스크립트 패턴을 사용하다보면, 로직이 복잡할 수록 if문이 수없이 많아지는데, 이를 디버깅 할 때마다 고통 받아 본 경험이 있다면, 도메인 모델링에 대해서도 관심을 가져보면 좋지 않을까 한다

## 테이블 모듈

- 테이블 모듈은 데이터베이스 테이블이나 뷰의 모든 행에 대한 비즈니스 논리를 처리하는 단일 인스턴스 이다
- 이 테이블 모듈을 통해 얻은 결과 값은 일반적으로 SQL 호출의 결과이며, 동작을 테이블과 함께 그룹화하여서, 동작과 동작의 대상이 되는 데이터를 하나로 묶는 캡슐화의 장점도 있다
- 테이블 모듈은 복잡한 논리를 구성하는 객체의 강력함을 완전히 활용하지는 못하는데, 따라서 복잡한 도메인 논리를 처리해야 한다면 도메인 모델을 선택한느 것이 좋다.
- 테이블 모듈은 복잡한 논리를 처리하는 도메인 모델의 능력 대신 테이블 기반 자료구조와의 손쉬운 통합 능력을 맞바꾼 패턴으로 볼 수 있다
- 활성 레코드 패턴과의 차이점은 테이블 모듈은 좀 더 테이블 자체에 초점을 맞췄다면, 활성 레코드는 테이블의 row에 초점을 맞춘 것 같은 느낌이 있다(정확하진 않음)

## 서비스 계층

- 서비스 계층은 클라이언트 계층을 인터페이스하는 관점에서 애플리케이션의 경계와 사용 가능한 작업의 집합을 정의 한다
- 서비스 계층은 트랜잭션 스크립트, 도메인 모델과 마찬가지로 비즈니스 논리를 구성하기 위한 패턴이다 비즈니스 논리는 도메인 논리와 애플리케이션 논리로 나눌 수 있는데, 도메인 논리는 순수하게 문제 도메인에 대한 내용이라면, 애플리케이션 논리는 좀 더 상위 개념으로 도메인에서 정의한 도메인 논리들로 애플리케이션 단의 기능을 어떻게 구현할 것인지에 대한 내용으로 이해할 수 있고, 이를 워크플로 논리라고도 한다
- 서비스 계층은 일종의 도메인 모델링으로 구현된 여러 객체들의 도메인 논리들을 모아서, 하나의 워크플로 논리로 만들어주는 역할을 하는 곳처럼 느껴진다
- 서비스는 도메인 파사드(domain facade)와 작업 스크립트(operation script) 방식이 있다. 도메인 파사드는 비즈니스 논리를 전혀 구현하지 않고, 도메인 모델에게 비즈니스 논리 구현에 대한 책임을 위임하고, 도메인 모델의 인터페이스를 통해서만 논리를 구성한다 반면에, 작업 스크립트는 리치 클래스 집합으로 구현한다고 하는데, 애플리케이션 논리를 직접 구현하며, 도메인 논리에 대해서만 도메인 객체 클래스로 위임을 하는 방식이다.
- 위의 설명은 도메인 모델링을 사용한다고 가정 했을 때의 도메인 파사드와 작업스크립트를 설명을 하였는데, 작업 스크립트의 경우는 트랜잭션 스크립트으로도 구현이 가능할것 같다는 생각이 들었다
- 서비스 계층에서 구현하는 애플리케이션 논리를 도메인 객체 클래스에서 구현하게 되면, 여러 애플리케이션에서 재사용하기 어렵다는 단점이 있다
- 서비스 계층은 엔터프라이즈 애플리케이션의 논리 계층을 체계화하기 위한 패턴으로서, 스크립팅과 도메인 객체 클래스를 결합하고 둘의 장점을 활용하게 해준다 이 패턴의 핵심은 애플리케이션 비즈니스 논리의 구현을 캡슐화하고, 다양한 클라이언트가 일관성 있게 호출할 수 있게 기반을 마련한다는 것이다.