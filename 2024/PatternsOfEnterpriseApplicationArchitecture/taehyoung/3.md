# 3장 관계형 데이터베이스 매핑

# 논의사항

- 현재 회사에서는 django 라는 framework를 사용하다보니, 의도치 않게 복잡한 로직도 django ORM을 활용한 `행 데이터 게이트웨이` 패턴으로 구현을 하고 있습니다. 이유는 django ORM 자체가 `데이터 매퍼(repository)` 를 사용하기 적합하지 않기 때문 입니다. 혹시 데이터 매퍼 패턴과 DB 테이블의 구조를 따라가는 `행 데이터 게이트웨이` 를 모두 사용해보신 분이 계시다면, 각각의 경험을 공유해주시면 좋을 것 같습니다

# 키워드

1. 테이블 데이터 게이트웨이
2. 행 데이터 게이트웨이
3. 활성 레코드 패턴
4. 데이터 매퍼
5. 임피던스 부정합
6. O/R 매핑 툴
7. 작업 단위
8. 식별자 맵
9. 지연 로드
10. 단일 테이블 상속
11. 구현 테이블 상속
12. 클래스 테이블 상속
13. 메타데이터 매핑
14. 쿼리 객체

# 내용 & 구조

## 개요

- 데이터 원본 계층에서 가장 중요한 것은 데이터베이스와 상호작용하는 것이며, 여기서 말하는 데이터베이스란 일반적으로 관계형 데이터베이스를 의미한다.

## 아키텍처 패턴

- DB 게이트웨이를 사용하는 두가지 방법
    1. 테이블 데이터 게이트웨이
        1. 테이블 기준으로 매핑되는 클래스에서, SQL을 구현하고 활용
        2. 테이블당 인스턴스 하나를 가짐
        3. 레코드 집합과 잘 어울린다
        4. 저장프로시저의 모음으로써 활용 가능
    2. 행 데이터 게이트웨이
        1. 쿼리가 반환하는 각 행마다 인스턴스 하나를 만드는 것
        2. 객체지향적 사고방식과 자연스럽게 어울린다
        3. 대개 사용하는 ORM 방식과 비슷
- 도메인 모델의 활용
    - 간단한 애플리케이션
        - 활성 레코드 활용
            - 도메인 객체가 데이터베이스 구조에 아주 근접하게 대응 되는 구조
    - 복잡한 애플리케이션
        - 복잡할 때는 활성 레코드로는 한계가 있고, 대신에 도메인 객체와 데이터베이스 테이블 간의 매핑을 간접 계층을 통해 완전히 처리해서 도메인 모델을 데이터베이스로부터 격리하는 것이 더 나은 방법
            - 이를 repository 패턴으로 볼 수 있을 것 같다
- 객체지향 데이터베이스
    - 임피던스 부정합 문제 발생
    - 가장 큰 장점은 생산성 향상
    - O/R 매핑 툴을 도입하는 것을 고려
        - ORM

## 동작 문제

- 작업 단위
    - 데이터베이스 매핑의 컨트롤러로 작동하는 객체
- 도메인 모델을 사용할 때는 데이터베이스에서 객체를 로드할 때, 연관된 객체가 함께 로드되도록 구성하는 것이 일반적이다
- 지연 로드를 적절한 지점에 활용하면 데이터베이스에 대한 각 호출로 데이터를 필요한 만큼 가져올 수 있따.

## 데이터 읽기

- 성능 문제
    - 데이터를 읽을 때 생길 수 있는 성능 문제와 관련된 몇가지 규칙
        - 가급적 여러 행을 한번에 읽는다
        - 데이터베이스 접근을 줄이는 다른 방법은 조인을 사용해 쿼리 하나로 여러 테이블을 한 번에 가져오는 것
    - 성능 프로파일링과 튜닝을 위한 시간은 꼭 할애해야 한다

## 구조적 매핑 패턴

### 관계 매핑

1. 다대일
    1. 외래 키 매핑 필요
2. 다대다
    1. 연관 테이블 매핑을 사용

### 상속

- SQL에는 상속을 처리하는 표준적인 방법이 없기 때문에 이 경우에도 매핑을 이용해야 한다
- 상속 구조를 처리하는 세가지 방법
    - 단일 테이블 상속
        - 한 테이블에 한 계층의 모든 클래스를 저장
    - 구현 테이블 상속
        - 한 테이블에 한 계층의 각 구현 클래스를 저장
    - 클래스 테이블 상속
        - 한 테이블에 한 계층의 각 클래스를 저장

## 매핑

- 도메인 모델을 사용할 때는 데이터베이스 설계와 비슷한 설계를 조심해야 한다. 즉, 데이터베이스를 염두에 두지 말고 도메인 논리를 간소화하는 데 집중하면서 도메인 모델을 구축한다
- 도메인 논리가 간단할 때는 데이터베이스를 모방하는 행 데이터 게이트웨이나 테이블 데이터 게이트웨이 클래스를 만들고, 이 위에 도메인 논리를 배치한다
- 도메인 논리가 복잡하다면, 도메인 모델이 필요하며, 도메인 모델은 데이터베이스 설계와는 일치하지 않을 가능성이 높다

## 메타데이터 사용

- 메타데이터 매핑
- 쿼리 객체

## 데이터베이스 연결

- 연결 풀
    - 연결을 만드는데 드는 비용을 절약
    - 직접 연결을 만들고 닫는 대신 연결이 필요할 때, 풀에서 요청하며 작업이 끝나면 연결을 풀로 반환한다
- 연결을 만드는 비용이 크든 작든 관리가 필요하다. 연결은 관리하는 데 비용이 많이 드는 자원이므로 사용이 끝나면 즉시 닫아야 한다.
- 연결은 트랜잭션과 밀접하게 관련되므로 트랜잭션과 함께 연결을 관리하는 것이 좋은 방법이다.

# 내 생각

- 개인적으로 테이블 설계 시에, `단일 테이블 상속` 방법을 주로 사용한다(물론 상황에 따라서 매번 다르지만,)
- 책 내용 전반적으로는 용어나 내용들을 어렵게 풀어써서 아쉬웠으나, 대부분 공감되는 내용들 이였다
- django 프레임워크를 사용하게 되면, 책에서 말하는 `데이터 매퍼` 는 구조상 경험 해볼 수 없다. `행 데이터 게이트웨이` 로 구현을 하여 사용하게 되는데, 이 패턴의 가장 큰 문제점은 DB 테이블 의존성이 너무 크다는 것이다. 이 말인 즉, 모든 비즈니스 로직 설계의 기준이 DB 테이블이 되고, 테이블 설계를 잘해야 하고, 그렇지 않은 경우 고치기도 힘들어져서 유지보수에 영향을 미치게 된다. 그래서 개인적으로는 django 프레임워크의 대표적인 단점 중 하나라고 생각한다. 물론 테이블 설계를 잘하면, 문제가 없다 하지만, 새롭게 요구사항이 추가되고, 유지보수하는 과정에서 최초에 생각한 테이블 설계에 맞는 경우가 거의 없었던 것 같고 대개는 차선을 선택하는 방향으로 유지보수를 했던 것 같다. 그렇기 때문에 개인적으로는 데이터베이스 테이블 설계에 영향을 덜 받는 데이터 매퍼 패턴이 효과에 대해서 궁금 했었는데, 책에서는 확실히 복잡한 로직에서는 이 패턴을 사용하는 것을 권장하고 있따.