# 5장 동시성

# 논의 내용

- 동시성 이슈와 관련해서 본인이 경험한 버그와 이를 어떻게 수정 하였는지에 대해서 얘기해보면 좋을 것 같습니다

# 키워드

1. 오프라인 동시성(offline concurrency)
2. 손실된 업데이트(lost update)
3. 일관성 없는 읽기(inconsistent read)
4. 낙관적 동시성 제어
5. 비관적 동시성 제어
6. 긴 트랜잭션(long transaction)
7. 요청 트랜잭션(request transaction)
8. 지연 트랜잭션(late transaction)
9. 잠금 상향(lock escalation)
10. 비즈니스 트랜잭션
11. 시스템 트랜잭션

# 내용 & 구조

## 개요

- 동시성은 소프트웨어 개발에서 가장 까다로운 측면 중 하나다
- 트랜잭션 내에서 모든 데이터 조작을 수행하면 심각한 문제는 대부분 예방할 수 있으나 단일 데이터베이스 트랜잭션에 넣을 수 없는 시스템과의 상호작용이 많기 때문에 동시성 문제를 완전히 무시할 있는 것은 아니다

## 동시성 문제

- 모든 동시성 프로그래밍의 핵심적 문제는 정확성을 충족하는 것으로는 충분하지 않으며, 동시 작업이 얼마나 많이 진행될 수 있는지를 나타내는 활동성(liveness)도 충족해야 한다는 것이다.

## 격리와 불변성

- 격리는 오류 발생 가능성을 낮추는 필수 기법이다.
- 훌륭한 동시성 설계란 이러한 격리 환경을 만드는 방법을 찾고 이 환경 내에서 최대한 많은 프로그래밍 작업을 수행하는 것이다.
- 동시성 문제는 공유하는 데이터가 수정될 수 있을 때만 발생한다. 따라서 변경 불가능한 데이터를 인식할 수 있으면 동시성 충돌을 예방할 수 있다

## 낙관적 동시성 제어와 비관적 동시성 제어

- 낙관적 잠금은 충돌 감지에 해당하며, 비관적 잠금은 충돌 예방에 해당한다
- 비관적 잠금
    - 동시성이 제한된다
    - 충돌이 자주 발생해서 결과가 심각할 수 있다면, 비관적잠금을 써야한다
- 낙관적 잠금
    - 변경사항을 제출할 때만 잠금을 적용하므로 사용자가 더 원활하게 일할 수 있다.
    - 충돌이 자주 발생하지도 않고, 결과가 별로 심각하지 않다면 낙관적 잠금을 써야한다
- 교착 상태
    - 비관적 잠금 기법에서 발생할 수 있는 특수한 문제
    - 시간 제한과 감지 기법은 모두 교착 상태가 발생하면 해결하는 기법이고, 교착 상태가 아예 발생하지 않게 예방하는 기법은 필요한 잠금을 모두 얻게 하고 추가 잠금을 얻지 못하게 하면 교착 상태를 예방할 수 있따

## 트랜잭션

- 정확성을 최대한 보장하려면 항상 직렬화 가능 격리 수준을 사용해야한다. 그러나 직렬화 가능을 사용하면 시스템의 활동성이 크게 저하되므로 처리량을 늘리려면 어쩔 수 없이 직렬화 가능성을 어느정도 포기해야 한다. 즉, 어느 수준까지 위험을 감수할지 결정하고 오류와 성능 간의 적절한 균형을 찾는 것이 중요하다
- 시스템 트랜잭션
    - RDB를 기준으로 제공하는 기능으로 BEGIN~COMMIT 을 하는 내부 작업들이 모두 성공 혹은 모두 실패의 결과가 나오게 된다
- 비즈니스 트랜잭션
    - 비즈니스 로직이 동작하는 일련의 과정을 비즈니스 트랜잭션으로 보는 것처럼 보인다
    - 일련의 짧은 트랜잭션으로 분리해야 한다.