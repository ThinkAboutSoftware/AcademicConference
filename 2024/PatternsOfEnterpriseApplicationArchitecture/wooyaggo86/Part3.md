* Chapter 11. Object-Relational Behavioral Patterns
    * 프로그램 속 객체들을 데이터베이스에 저장하고 불러올 때 생기는 문제를 다루는 방법을 다룹니다.
    * Unit of Work
        * 작업 단위: 객체의 변경 사항을 기록해서 한 번에 데이터베이스에 저장합니다. 여러 사람이 동시에 작업해도 문제 없도록 도와줍니다.
        * 식별 맵: 이미 불러온 객체를 기억해서 같은 객체를 여러 번 불러오지 않도록 합니다. 프로그램 속도를 빠르게 해줍니다.
    * Identity Map
        * 이미 불러온 객체를 기억해서 같은 객체를 여러 번 불러오지 않도록 합니다. 프로그램 속도를 빠르게 해줍니다.
    * Lazy Load
        * Implementations
            * Lazy initialization
                * 작동 방식: 필드 또는 속성은 처음에 null(또는 특수 자리 표시자 값)로 설정됩니다. 필드에 처음 액세스하면 데이터가 데이터베이스에서 로드된 다음 반환됩니다.
                * 예시: 블로그 애플리케이션에서 게시물의 댓글은 사용자가 "댓글 표시" 버튼을 클릭할 때만 로드됩니다.
            * Virtual Proxy
                * 작동 방식: 프록시 객체는 실제 객체 대신 사용됩니다. 프록시 객체는 실제 객체처럼 보이고 동작하지만 실제 데이터를 포함하지 않습니다. 프록시 객체의 메서드가 호출되면 실제 객체가 데이터베이스에서 로드되고 메서드 호출이 해당 객체로 전달됩니다.
                * 예시: 음악 애플리케이션에서 노래 목록에는 처음에 노래 제목만 포함될 수 있습니다. 사용자가 재생할 노래를 선택하면 전체 노래 세부 정보(아티스트, 앨범 등)가 가상 프록시를 통해 로드됩니다.
            * Value holder
                * 작동 방식: 값 홀더 객체는 실제 데이터를 감쌉니다. 값 홀더는 데이터에 액세스하는 방법을 제공하지만 데이터는 이러한 메서드 중 하나가 호출될 때만 데이터베이스에서 로드됩니다.
                * 예시: 전자 상거래 애플리케이션에서 제품 세부 정보 페이지는 값 홀더를 사용하여 제품 설명을 표시할 수 있으며, 이 설명은 사용자가 설명 섹션을 확장할 때만 로드됩니다.
            * Ghost
                * 작동 방식: 고스트 객체는 부분적으로 로드된 객체입니다. 자체를 식별하는 데 필요한 정보(일반적으로 기본 키)만 포함합니다. 고스트 객체의 다른 필드 또는 속성에 액세스하면 전체 객체가 데이터베이스에서 로드됩니다.
                * 예시: 소셜 네트워크 애플리케이션에서 사용자 프로필은 처음에 사용자 ID와 이름만 포함하는 고스트 객체일 수 있습니다. 사용자가 전체 프로필을 볼 때 추가 세부 정보(사진, 친구 등)가 로드됩니다.
        * Q. 이중에서 실제로 사용하신 패턴이 있으실까요? 있다면 어떤 구현을 선호하시나요?
* Chapter 12. Object-Relational Structural Patterns
    * Identity Field
        * 데이터베이스 ID를 객체에 저장해서 객체와 데이터베이스 행을 연결합니다.
            * Q. meaningful key vs meaningless key 어떤걸 선호하시나요?
    * Foreign Key Mapping
        * 객체 연결을 데이터베이스의 외래 키로 매핑합니다. 하나의 값 또는 여러 값을 가진 관계를 모두 처리할 수 있습니다.
            * e.g. Team-Member
    * Association Table Mapping
        * 다대다 관계를 위해 별도의 테이블을 사용하고, 연결된 테이블에 외래 키를 저장합니다.
            * e.g.  Movie, Actor, Casting(Movie-Actor)
    * Dependent Mapping
        * 항상 부모 객체와 연결된 객체의 경우, 부모 객체가 종속 객체의 저장을 처리하도록 해서 매핑을 단순화.
        * Q. 이거 Valid한 SQL 인가요?
            * "SELECT ID, a.title, t.title as trackTitle" +

                 " FROM albums a, tracks t" +


                 " WHERE a.ID = ? AND t.albumID = a.ID" +


                 " ORDER BY t.seq";

    * Embedded Value
        * 돈이나 날짜 범위와 같은 작은 값 객체를 별도의 테이블 대신 소유자 객체 테이블의 필드에 직접 매핑합니다.
    * Serialized LOB
        * 복잡한 객체 그래프를 데이터베이스 필드에 단일 큰 객체(LOB)로 저장합니다. 주로 XML과 같은 직렬화 형식을 사용합니다.
    * 상속 구조를 관계형 데이터베이스에 표현하는 세 가지 패턴이 있습니다
        * Single Table Inheritance
            * 모든 클래스를 모든 필드를 포함하는 단일 테이블에 저장합니다.
        * Class Table Inheritance
            * 추상 클래스를 포함하여 계층 구조의 각 클래스에 대해 하나의 테이블을 사용합니다.
        * Concrete Table Inheritance
            * 계층 구조의 각 구체 클래스에 대해 하나의 테이블을 사용합니다.
        * Q. 상속 구조를 사용해서 DB활용한 경험이 있으신지 궁금합니다. 유지보수가 너무 어렵진 않을지 염려되네요.