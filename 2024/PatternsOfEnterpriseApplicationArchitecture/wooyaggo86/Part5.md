* 논의 사항
    * 14장에서는 MVC에서 다뤘는데, 이와 관련된 비슷한 패턴들 (MVP, MVVM)이 존재하는 걸로 알고 있습니다. 이중에서 실제로 사용하신 패턴에 대한 경험을 듣고 싶습니다. 그리고 이해하신 패턴들이 있다면, 간단하게 아이디를 공유해주세요.
    * 15장에서는 RemoteFacade 관련해서, 데이터를 번들로 가져오기 위한 방식으로 GraphQL이 유용하다고 들었는데, 혹시 사용하신 경험이나 테스트해보신 분이 계시다면 경험을 듣고 싶습니다.
    * 15장에서 추가로 저는 기존 회사들에서는 DTO를, Apache Thrift나 Protobuf(gRPC)등을 사용해 봤는데, 직접 DTO를 구성해서 쓰신분이 있다면 경험(장단점)을 듣고 싶습니다.
* Chapter 14. Web Presentation Patterns
    * 이 장에서는 엔터프라이즈 애플리케이션에서 웹 기반 사용자 인터페이스를 설계하기 위한 아키텍처 패턴에 중점을 둡니다. 핵심 아이디어는 애플리케이션을 세 가지 역할로 분리하는 모델-뷰-컨트롤러 (MVC) 패턴을 중심으로 합니다.
        * 모델: 프레젠테이션 계층과 독립적으로 도메인 데이터와 비즈니스 로직을 나타냅니다.
        * 뷰: 일반적으로 HTML 또는 다른 웹 기술을 사용하여 사용자에게 정보를 표시합니다.
        * 컨트롤러: 사용자 입력을 해석하고 그에 따라 모델과 뷰와 상호 작용합니다.
    * 이 장에서는 MVC 기반을 기반으로 하는 여러 패턴을 살펴봅니다.
        * 페이지 컨트롤러: 웹 사이트의 특정 페이지 또는 작업에 대한 요청을 처리합니다. 종종 복잡한 로직을 관리하기 위한 도우미 객체가 있는 서버 페이지로 구현됩니다.
            * 예제
                * 페이지 컨트롤러는 온라인 쇼핑몰과 같은 웹사이트에서 각 페이지를 관리하는 매니저라고 생각하면 쉽습니다. 예를 들어, 제품 페이지나 결제 페이지와 같은 각 페이지에는 고유한 역할이 있습니다.
            * 언제 좋은 선택인가?
                * 페이지가 비교적 독립적인 경우.
                * 각 페이지의 로직이 너무 복잡하지 않은 경우.
                * 페이지 간에 공유 기능이 많지 않은 경우.
        * 프론트 컨트롤러: 웹 사이트에 대한 모든 요청을 처리하고 특정 작업을 개별 명령 객체에 위임하는 단일 컨트롤러입니다. 공통 동작을 팩터링하고 데코레이터를 사용하여 동적으로 향상시키는 데 유용합니다.
            * 예제
                * 프론트 컨트롤러는 바쁜 호텔의 리셉션 데스크와 같다고 생각하면 쉽습니다. 호텔에 많은 손님이 도착할 때 체크인, 룸서비스, 객실 청소 등 각 요청 유형에 대해 별도의 직원을 두는 대신, 모든 것을 처리하는 메인 리셉션 직원이 있습니다. 이것이 바로 프론트 컨트롤러의 기본 아이디어입니다.
            * 언제 좋은 기능인가?
                * 페이지 간에 많은 기능이 공유되는 경우.
                * 웹사이트의 탐색 및 흐름이 복잡한 경우.
                * 요청 처리 방식에 대한 더 많은 제어가 필요한 경우.
        * 템플릿 뷰: 정적 HTML 템플릿에 마커를 포함하여 동적 콘텐츠를 렌더링합니다. ASP, JSP 및 PHP와 같은 서버 페이지 기술이 일반적인 구현입니다.
            * 예제
                * 템플릿 뷰는 여러 장의 똑같은 카드에 각각 다른 이름과 메시지를 써서 개인화하는 것과 같다고 생각하면 쉽습니다. 템플릿 뷰는 기본 구조를 제공하고 특정 정보로 빈칸을 채우는 방식으로 동작합니다.
            * 언제 좋은 기능인가?
                * 유사한 레이아웃의 페이지가 많은 경우.
                * 디자인과 로직을 분리하려는 경우.
                * 프로그래머가 아닌 사람도 쉽게 콘텐츠를 편집할 수 있도록 하려는 경우.
        * 변환 뷰: 도메인 데이터를 직접 HTML로 변환하기 위해 프로그램(종종 XSLT)을 사용하여 더 나은 테스트 가능성과 관심사 분리를 제공합니다.
            * 예제
                * 트랜스폼 뷰는 마치 블록 상자 (데이터)와 다양한 구조물 (웹 페이지)을 만드는 방법에 대한 설명서 (변환)를 가지고 있는 것과 같습니다. 트랜스폼 뷰는 데이터를 가져와서 단계별로 완성된 웹 페이지로 변환하는 역할을 합니다.
            * 언제 좋은 기능인가?
                * 데이터와 프레젠테이션을 명확하게 분리해야 하는 경우.
                * 페이지의 레이아웃이나 형식을 쉽게 변경할 수 있도록 하려는 경우.
                * XML 데이터로 작업하는 경우.
        * 2단계 뷰: 도메인 데이터를 HTML로 변환하는 과정을 두 단계로 나눕니다. 먼저 논리적 프레젠테이션 구조를 만든 다음 HTML로 렌더링합니다. 이를 통해 웹 사이트 전체에서 일관된 모양과 느낌을 제공하고 글로벌 변경을 용이하게 합니다.
            * 예제
                * Two Step View는 웹페이지를 만드는 과정을 옷 만들기에 비유할 수 있습니다. 원단(데이터)에서 바로 완성된 옷(웹페이지)을 만드는 대신, 패턴(중간 형식)을 먼저 만들고 그 패턴을 이용해 옷을 만듭니다. 이 방식은 데이터와 디자인을 분리하고, 다양한 디자인을 쉽게 적용할 수 있게 해줍니다.
            * 언제 좋은 기능인가?
                * 복잡한 구조나 디자인의 웹사이트.
                * 여러 페이지에 걸쳐 일관된 모양과 느낌이 필요한 경우.
                * 웹사이트의 디자인을 쉽게 변경할 수 있도록 하려는 경우.
                * 디자이너와 개발자 간의 협업이 중요한 경우.
        * 애플리케이션 컨트롤러: 특히 복잡한 워크플로우와 조건부 페이지 동작이 있는 애플리케이션에서 화면 탐색 및 흐름 제어 로직을 중앙 집중화합니다.
            * 예제
                * Application Controller는 웹 애플리케이션을 여행하는 사용자를 안내하는 GPS와 같다고 생각하면 쉽습니다. 사용자의 현재 위치, 목적지, 그리고 최적의 경로를 알려주는 역할을 합니다.
                * 이렇게 생각해 보세요:
                    * 네비게이터: Application Controller는 네비게이터처럼 사용자의 행동과 현재 상황에 따라 다음에 어떤 화면이나 페이지를 보여줄지 결정합니다.
                    * 지도를 알고 있습니다: 애플리케이션의 전체 구조와 사용자가 선택할 수 있는 다양한 경로를 이해합니다.
                    * 사용자의 행동에 반응합니다: 버튼을 클릭하거나 양식을 제출하면 Application Controller는 다음에 무엇을 할지 결정합니다. 예를 들어, 새로운 페이지를 표시하거나, 데이터를 처리하거나, 메시지를 표시합니다.
                    * 진행 상황을 추적합니다: 사용자가 어디에 있었고 무엇을 했는지 기억하여 애플리케이션을 원활하고 논리적으로 탐색할 수 있도록 합니다.
            * 언제 좋은 기능인가?
                * 여러 단계 또는 결정이 있는 복잡한 흐름을 가진 경우.
                * 상황에 따라 사용자 행동에 다르게 반응해야 하는 경우.
                * 애플리케이션의 여러 부분에서 일관된 사용자 경험을 유지하려는 경우.
    * 이 장에서는 웹 인터페이스의 복잡성과 원하는 유연성 및 유지 관리성 수준에 따라 적절한 패턴을 선택하는 것의 중요성을 강조합니다.
* 15장 요약: 분산 패턴
    * 이 장에서는 구성 요소가 서로 다른 시스템 또는 프로세스에 상주할 수 있는 분산 엔터프라이즈 애플리케이션을 구축하기 위한 과제와 전략을 다룹니다.
    * 주요 사항:
        * 분산 비용: 원격 호출은 데이터 마샬링, 네트워크 지연 시간 및 보안 검사와 같은 요소로 인해 로컬 호출보다 훨씬 느립니다. 따라서 성능을 위해 원격 호출을 최소화하는 것이 중요합니다.
        * 원격 파사드: 세분화된 객체 위에 coarse-grained 인터페이스를 제공하여 원격 호출 수를 줄입니다. 이를 통해 잘 구성된 객체 모델을 유지하면서 효율적인 통신이 가능합니다.
            * 예제
                * Remote Facade는 레스토랑에서 음식을 주문하는 상황에 비유할 수 있습니다. 요리사, 웨이터, 주방 직원에게 직접 말하는 대신, 웨이터에게 원하는 것을 말하면 웨이터가 나머지 모든 것을 처리합니다. Remote Facade도 마찬가지로 복잡한 시스템에 원격으로 접근하기 위한 단일 접점 역할을 합니다.
                * 이렇게 생각해 보세요:
                    * 친절한 웨이터: Remote Facade는 주문을 받고 주방 직원과 소통하여 음식을 준비하는 친절한 웨이터와 같습니다.
                    * 복잡성 숨기기: 주방이 어떻게 작동하는지 또는 누가 무엇을 하는지 알 필요가 없습니다. 웨이터가 모든 세부 사항을 처리합니다.
                    * 간편한 의사 소통: 여러 사람에게 여러 번 요청하는 대신 웨이터와만 대화하면 됩니다.
                    * 효율적인 서비스: 웨이터는 주방과 소통하는 가장 좋은 방법을 알고 있어 효율적이고 정확한 서비스를 제공합니다.
            * 언제 좋은 기능인가?
                * 복잡한 시스템에 원격으로 접근해야 할 때.
                * 원격 통신 성능을 향상시키려는 경우.
                * 시스템의 내부 복잡성을 원격 클라이언트로부터 숨기려는 경우.
        * 데이터 전송 객체 (DTO): 프로세스 간에 데이터를 전달하는 객체로, 여러 번의 원격 호출 필요성을 최소화합니다. DTO는 일반적으로 여러 도메인 객체의 데이터를 집계하고 효율적인 직렬화 및 역직렬화를 위해 설계되었습니다.
            * 예제
                * Data Transfer Object (DTO)는 여행을 위해 짐을 싸는 상황에 비유할 수 있습니다. 여행에 필요한 특정 물건을 선택하고 깔끔하게 짐을 쌉니다. DTO도 마찬가지로 시스템의 여러 부분 사이에서 데이터를 효율적이고 체계적으로 전달하기 위해 데이터를 담는 컨테이너 역할을 합니다.
                * 이렇게 생각해 보세요:
                    * 데이터를 위한 가방: DTO는 옷, 세면도구, 여행 서류와 같이 전달하려는 특정 데이터를 담는 가방과 같습니다.
                    * 체계적이고 효율적: 짐 가방을 깔끔하게 싸서 공간을 최대한 활용하는 것처럼, DTO는 전달을 위해 데이터를 효율적으로 구성합니다. 종종 단순하고 평평한 구조로 되어 있습니다.
                    * 장소 간 이동: 짐 가방이 여행할 때 함께 이동하는 것처럼, DTO는 애플리케이션 계층 간 또는 네트워크를 통해 소프트웨어 시스템의 여러 부분 사이를 이동합니다.
                    * 여행에 따라 다름: 여행에 따라 다른 물건을 챙기는 것처럼, DTO에는 관련된 작업이나 프로세스에 특화된 데이터가 포함됩니다.
            * 언제 좋은 선택일까요?
                * 시스템의 여러 부분 간에 데이터를 전달해야 할 때.
                * 데이터 전송 성능을 향상시키려는 경우.
                * 시스템의 여러 부분 간의 의존성을 최소화하려는 경우.
    * 기타 고려 사항:
        * 원격 인터페이스 세분성: 원격 파사드는 메서드 수가 적은 coarse-grained 인터페이스를 가져야 하는 반면, 로컬 인터페이스는 유연성을 위해 fine-grained 일 수 있습니다.
        * 상태 저장 vs 무상태: 원격 파사드는 애플리케이션의 요구 사항과 원하는 리소스 효율성 수준에 따라 상태 저장 또는 무상태일 수 있습니다.
        * 데이터 직렬화: DTO는 이진 또는 텍스트 형식으로 직렬화할 수 있으며 각각 장단점이 있습니다. XML 직렬화는 가독성과 유연성이 뛰어나지만 더 많은 대역폭과 처리 능력이 필요할 수 있습니다.
* 전반적으로 이 장에서는 분산에 대한 신중한 접근 방식을 강조하고 개발자가 원격 호출을 최소화하고 효율성과 유지 관리성을 보장하기 위해 인터페이스 및 데이터 전송 메커니즘을 신중하게 설계하도록 권장합니다.