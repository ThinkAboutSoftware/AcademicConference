## 05장 동시성

- 마틴 파울러, 데이비드 라이스

동시성 문제의 해결이 어려운 이유는 문제의 모든 원인을 미리 알기 어렵기 때문이다. 동시성은 테스트하기도 어렵다.
동시성을 많이 사용하는 소프트웨어 개발 부서일수록 동시성에 대한 걱정을 덜 한다. 이유는 트랜잭션 관리자가 있기 때문이다. 트랜잭션은 까다로운 동시성의 여러 측면을 예방하는 프레임워크를 제공한다. 트랜잭션 내에서 데이터 조작을 수행하면 심각한 문제는 대부분 예방할 수 있다.

여러 데이터베이스 트랜잭셔에 걸쳐 조작되는 데이터에 대한 동시성 제어를 오프라인 동시성(offline concurrency)이라고 한다. 해결해야 하는 까다로운 동시성 문제는 다중 스레드를 지원하는 애플리케이션 서버 시스템이다. 이 문제는 대처가 수월하기도 하고 일부 서버 플랫폼은 이 문제를 자동으로 해결한다.

### 동시성 문제

손실된 업데이트(lost update)는 이해해야 할 가장 간단한 개념이다. 파일을 수정 하고 있는 중에 다른 사람이 수정을 하려고 시도하고 먼저 업데이트를 하는 경우이다. 나중에 수정한 사람의 내용은 처음 수정한 사람은 모르므로 처음 수정한 사람의 내용으로 저장해서 업데이트가 되면 나중에 수정한 사람의 파일 내용을 잃게 된다.

일관성 없는 읽기(inconsistent read)는 올바르지 않은 정보의 두 조각을 읽은 경우 발생한다.

이런 문제는 정확성(또는 안정성)을 위반하는 잘못된 동작을 유발하지만 두 사람이 동시에 동일한 데이터를 사용하려고 하지 않는다면 애초에 발생하지 않는다. 정확성을 중요하게 생각한다면 이 문제는 심각하지 않을수도 있다. 모든 동시성 프로그래밍의 핵심적 문제는 정확성을 충족하는 것으로는 충분하지 않으며, 동시 작업이 얼마나 많이 진행될 수 있는지를  나타내는 활동성(liveness)도 충족해야 한다는 것이다. 경우에 따라서 정확성을 일정 부분 양보하고 활동성을 향상시키는 경우도 있다.

문제를 용인할 수 있으면 동시성 제어가 필요가 없다. 흔하지는 않지만 문제가 용인되는 상황을 발견할 수 있을 것이다.

### 실행 컨텍스트

시스템에서 프로세싱이 진행될 때는 일반적으로 둘 이상의 컨텍스트 안에서 진행된다. 외부 세계와 상호작용하는 관점에서 중요한 두 가지 컨텍스트로 요청과 세션이 있다.

요청(request)은 소프트웨어가 작업하고 선택적으로 응답을 보내야 하는 외부 세계로부터의 단일 호출에 해당한다.
세션(session)은 클라이언트와 서버 간에 오랫동안 실행되는 상호작용이다. 세션은 한 요청만 포함될 수도 있지만, 이보다는 사용자가 하나의 일관된 논리적 흐름으로 생각하는 일련의 요청으로 이뤄지는 경우가 더 많다.

운영체제와 관련된 두 가지 중요한 용어로 프로세스(process)와 스레드(thread)가 있다.
프로세스는 사용하는 내부 데이터에 대한 다단계 격리를 제공하는 대규모 실행 컨텍스트다.
스레드는 한 프로세스 내에서 여러 스레드로 작동할 수 있게 구성된 소규모의 활성 에이전트다. 
스레드는 일반적으로 메모리를 공유하기 때문에 동시성 문제를 유발할 수 있다.

문제는 실행 컨텍스트가 생각과는 다르게 깔끔하게 정리되지 않는다. 이론상 각 세션은 전체 수명 동안 한 프로세스와 관계를 맺고 프로세스는 서로 확실하게 격리되므로 동시성 충돌을 줄이는 데 상당히 유리하다. 이런 방식으로 동작하는 서버 툴은 없으며 가장 비슷한 방식으로 각 요청마다 새 프로세스를 시작하는 것이다. 한 프로세스가 한 번에 한 요청만 처리하게 하는 시스템이라면 동시성 문제를 예방할 수 있다. 지금은 프로세스를 시작하려면 많은 양의 자원이 필요하므로 이 방식은 거의 사용되지 않는다. 

데이터베이스를 처리할 때는 트랜잭션(transaction)이라는 또 한 가지 중요한 컨텍스트가 있다. 트랜잭션을 이용하면 클라이언트가 단일 요청인 것처럼 처리하고 싶은 여러 요청을 하나로 처리할 수 있다.

### 격리와 불변성

동시성 문제를 해결하기 위해 격리와 불변성이라는 두 가지 해결책이 특히 중요하다.

격리는 오류 발생 가능성을 낮추는 필수 기법이다. 격리를 잘 활용하면 동시성 걱정 없이 필요한 작업을 할 수 있다. 훌륭한 동시성 설계는 격리 환경을 만드는 방법을 찾고 이 환경 내에서 최대한 많은 프로그래밍 작업을 수행하는 것이다.

동시성 문제는 공유하는 데이터가 수정될 수 있을 때만 발생한다. 따라서 변경 불가능한(immutable) 데이터를 인식할 수 있으면 동시성 충돌을 예방할 수 있다.

### 낙관적 동시성 제어와 비관적 동시성 제어

격리할 수 없는 변경 가능한 데이터의 경우는 낙관적 동시성 제어와 비관적 동시성 제어라는 두 가지 방법으로 제어할 수 있다.

낙관적 잠금(optimistic locking)을 사용하는 경우에는 두 사용자가 모두 자유롭게 파일을 복사하고 편집할 수 있다.
비관적 잠금(pessimistic locking)을 사용하는 경우 먼저 파일을 체크아웃하면 다른 사용자가 파일을 편집할 수 없게 된다.
낙관적 잠금은 충돌 감지에 해당하고, 비관적 잠금은 충돌 예방에 해당한다. 오늘날 대부분의 개발자는 낙관적 잠금을 선호한다.

낙관적 잠금과 비관적 잠금을 선택하는 기준은 충돌의 빈도와 심각도다. 충돌이 자주 발생하지 않거나 그 결과가 심각하지 않다면 동시성을 제공하고 구현도 쉬운 낙관적 잠금을 선택해야 한다.

#### 일관성 없는 읽기 예방

일관성 없는 읽기 상황은 다음과 같다. 마틴은 주문 클래스를 호출하는 고객 클래스를 편집하고 있다. 그 동안 데이비드는 주문 클래스를 편집하고 인터페이스를 변경하고 있다. 데이비드가 먼저 컴파일 하고 체크인한 다음 마틴이 컴파일 하고 체크인한다. 마킨은 주문 코드가 변경된 것을 몰랐기 때문에 공유된 코드는 작동하지 않는다. 시스템에서는 체크인하기 전에 계층에서 파일을 업데이트하는 등과 같이 일관성을 적용하기 위한 수동 작업이 필요하다.

동시성 문제에 의해 손실된 업데이트에 집중하느라 일관성 없는 읽기 문제를 놓치는 경우가 많다. 이건 비관적 잠금의 읽기 잠금과 쓰기 잠금을 활용하면 이 문제를 매끄럽게 해결할 수 있다.

일관성 없는 읽기를 해결하는 또 한 가지 방법은 임시 읽기(temporal read)를 이용하는 것이다. 읽은 모든 데이터에 일종의 타임스탬프나 읽기 전용 라벨을 붙여 데이터베이스는 이 시간이나 라벨을 기준으로 데이터를 반환한다.

#### 교착 상태

비관적 잠금 기법에서 발생할 수 있는 특수한 문제로 교착 상태(deadlock)가 있다. 교착 상태를 해결하는 기법으로는 교착 상태가 발생할 때 감지할 수 있는 소프트웨어를 사용하는 것이다. 교착 상태가 발생하면 희생가 한 명을 선택해 해당 사용자의 작업과 잠금을 포기하게 해서 다른 사용자의 작업을 진행할 수 있게 한다.
다른 방법으로 시간 제한을 두는 방식인데, 시간 제한이 초과되면 자동으로 희생자가 되어 잠금과 작업이 모두 손실된다. 시간 제한은 교착 상태 감지 보다는 구현이 쉽다.

이 두 방법은 교착 상태가 발생하면 해결하는 기법이고, 교착상태가 아예 발생하지 않게 하는 기법도 있다. 작업을 시작할 때 필요한 잠금을 모두 얻게 하고 추가 잠금을 얻지 못하게 하면 교착 상태를 예방할 수 있다.

사용자가 잠금을 얻는 순서에 대한 규칙으로 파일의 알파벳 순서로 정할 수 있고, 이미 가지고 있는 잠금을 다른 사람이 얻으려고 하면 자동으로 희생자가 되게 하는 방법도 있다.

보수적인 방식을 선호한다면 여러 기법을 함께 적용할 수 있다. 지나치게 조심스러울 수 있지만 교착 상태가 발생한 후 처리하는 것 보다 처음 부터 보수적으로 접근하는 것이 현명하다.

### 트랜잭션

트랜잭션은 엔터프라이즈 애플리케이션에서 동시성을 처리하는 가장 중요한 툴이다.

트랜잭션은 시작점과 끝점이 명확하게 정의된 일련의 작업이다. 현금지급기 트랜잭션의 경우 사용자가 카드를 삽입하면서 시작되며, 현금이 지급되거나 잔액이 부족한 경우 끝난다.

트랜잭션은 전체를 실행하거나 실행하지 않는 양자택일 방식으로 수행해야 한다. 현금지급기에서 현급을 지금하기 전에 고객의 계좌에서 예금을 인출해서는 안 된다.

#### ACID

소프트웨어 트랜잭션은 다음과 같은 ACID 속성을 가진다.

- 원자성(Atomicity): 트랜잭션의 경계 안에서 수행되는 각 작업의 단계는 모두 성공저그로 완료되거나 롤백해야 한다.
- 일관성(Consistency): 시스템의 자원은 트랜잭션의 시작과 완료 시점에 모두 일관성 잇고 손상되지 않은 상태여야 한다.
- 격리성(Isolation): 개별 트랜잭션의 결과는 트랜잭션이 성공적으로 커밋하기 전까지 다른 열려 있는 트랜잭션에서 볼 수 없어야 한다.
- 지속성(Durability): 커밋된 트랜잭션의 결과는 영구적이어야 한다. 강제 종료가 발생해도 유지되어야 한다.

#### 트랜잭션 리소스

트랜잭션에 대한 기술적 논의에서 트랜잭션으로 동시성을 제어할 수 있는 모든 대상을 나타내는 데 "트랜잭션 리소스"라는 용어를 사용한다. 이 용어는 다소 복잡하므로 여기서는 "데이터베이스"라고 한다.

처리량을 극대화하기 위해 최신 트랜잭션 시스템은 최대한 짧게 유지하도록 설계된다. 따라서 여러 요청에 걸친 트랜잭션을 만들지 말아야 한다. 여러 요청에 걸친 트랜잭션을 일반적으로 긴 트랜잭션(long transaction)이라고 한다.

반면에 요청을 시작할 때 트랜잭션을 시작하고 요청이 끝날 때 트랜잭션을 끝내는 방법이 일반적이고 이런 방법을 요청 트랜잭션(request transaction) 이라고 한다.

다른 방법으로는 트랜잭션을 최대한 늦게 여는 것이다. 트랜잭션 밖에서 모든 읽기를 수행하고 업데이트를 시작할 때 트랜잭션을 여는 방식을 지연 트랜잭션(late transaction)이라고 한다. 장점으로는 트랜잭션에 소비되는 시간을 최소화한다는 것이다. 하지만 트랜잭션을 시작하기 전 까지는 동시성 제어가 적용되지 않으므로 일관성 없는 읽기 문제의 우려가 있다. 그래서 충돌이 아주 심하거나 비즈니스 트랜잭션이 여러 요청에 걸치기 때문에 어쩔 수 없이 사용해야 하는 경우가 아니면 사용하지 않는다.

트랜잭션을 사용할 때는 어떤 리소스가 lock이 걸리는지 어느 정도 인식하고 있어야 한다. 트랜잭션이 전체 행을 잠그는 경우 데이터베이스가 처리 가능한 수준 이상으로 잠금이 증가하고 잠금이 상향되어 다른 트랜잭션까지 잠그게 된다. 이런 잠금 상향(lock escalation)은 동시성에 심각한 영향을 미친다. 도메인의 `계층 상위 형식`레벨의 데이터에 일부 "객체" 테이블을 사용하지 않아야 하는 이유이기도 하다.

#### 활동성을 위한 트랜잭션 격리성 저하

여러 트랜잭션을 동시에 실행해도 순서대로 실행했을 때와 동일한 결과를 얻을 수 있는 경우 직렬화 가능(serializable) 트랜잭션이라고 한다. 직렬화 가능성이 어떤 결과를 얻을지 보장하지 않지만 적어도 정답을 보장한다.

대부분의 트랜잭션 시스템은 SQL 표준을 사용해 네 가지 격리 수준을 정의한다. 직렬화 가능(serializable)은 그 중 가장 강력한 수준이며, 그 아래 수준은 각각 특정한 종류의 일관성 없는 읽기(inconsistent read)가 발생할 수 있다.

직렬화 가능 아래의 첫 번째 격리 수준은 팬텀(phantom)이 허용되는 반복 가능 읽기(repeatable read)다. 팬텀은 컬렉션에 여러 요소를 추가했을 때 읽는 쪽에서 일부 요소만 볼 수 있는 현상이다.

그 아래 격리 수준은 반복 불가능 읽기(unrepeatable read)가 허용되는 커밋된 읽기(read committed)다. 데이터베이스에서 팬텀보다 반복 불가능 읽기를 찾기가 쉽기 때문에 반복 가능한 읽기는 커밋된 읽기보다 정확성은 높지만 활동성은 낮다.

가장 낮은 격리 수준은 더티 읽기(dirty read)가 허용되는 커밋되지 않은 읽기(read uncommitted)다. 커밋되지 않은 읽기에서는 다른 트랜잭션이 아직 커밋하지 않은 데이터를 읽을 수 있다. 이 경우 두 가지 오류가 발생할 수 있다.

표 5.1에는 각 격리 수준에서 발생하는 읽기 오류이다.

**Table 5.1. Isolation Levels and the Inconsistent Read Errors They Allow**

| Isolation Level | Dirty Read | Unrepeatable Read | Phantom |
|---------------|------------|--------------------|----------|
| Read Uncommitted | Yes | Yes | Yes |
| Read Committed | No | Yes | Yes |
| Repeatable Read | No | No | Yes |
| Serializable | No | No | No |

정확성을 보장하려면 항상 직렬화 가능 격리 수준을 사용해야 한다.
직렬화 가능을 사용하면 시스템의 활동성이 저하되므로 처리량을 늘리려면 직렬화 가능성을 어느 정도 포기해야 한다.
어느 수준까지 위험을 감수할지 결정하고 오류와 성능 간의 적절한 균형을 찾는 것이 중요하다.

#### 비즈니스 트랜잭션과 시스템 트랜잭션

지금까지의 트랜잭션은 시스템 트랜잭션이며, RDMBS 시스템과 트랜잭션 모니터의 지원을 받아 운영된다.
데이터베이스 트랜잭션은 트랜잭션의 시작과 끝을 지정하는 명령으로 구분되는 SQL 명령의 그룹이다. SQL 명령 네 개로 이뤄진 트랜잭션에서 네 번째 구문이 무결성 제약 조건을 위반한 경우 처음 세 개의 구문이 적용된 영향을 롤백하고 호출자에게 트랜잭션이 실패했음을 알린다.
또 네 개의 구문이 모두 성공하면 네 개의 구문이 끼친 영향을 한꺼번에 공개한다. RDBMS 시스템과 애플리케이션 서버 트랜잭션 관리자는 보편적으로 제공되므로 자주 활용된다.

그러나 시스템 트랜잭션은 비즈니스 시스템의 사용자에게는 전혀 의미가 없다. 온라인 은행 시스템에서 로그인, 계정 선택, 이체 내역, 금액 이체 등은 비즈니스 트랜잭션(business transaction)이라고 하며, 여기서도 시스템 트랜잭션과 동일한 ACID 속성을 제공해야 한다.

비즈니스 트랜잭션에서 ACID 속성을 지원하는 확실한 방법은 한 비즈니스 트랜잭션 전체를 한 시스템 트랜잭션 안에서 실행하는 것이다. 그렇게 되면 긴 시스템 트랜잭션이 되고 대부분 트랜잭션 시스템은 긴 트랜잭션을 잘 처리하지 못한다.

긴 트랜잭션을 사용하지 말라는 의미는 아니지만 판단을 잘 해야 한다. 긴 트랜잭션을 사용하면 귀찮은 문제를 예방할 수 있는 반면에 데이터베이스의 주요 병목 구간이 되기도 하므로 확장성이 제약 받는다.

그래서 엔터프래이즈 애플리케이션에서는 긴 트랜잭션을 사용하기 어렵다. 여러 시스템 트랜잭션 사이에서 비즈니스 트랜잭션의 ACID 특성을 지원하는 역할을 직접 구현해야 하며, 오프라인 동시성(offline concurrency) 문제도 해결해야 한다.

원자성과 지속성은 비즈니스 트랜잭션에서 가장 쉽게 지원할 수 있는 ACID 속성이다. 이 두 속성은 트랜잭션의 커밋 단계를 하나의 시스템 트랜잭션 안에서 실행하는 방법으로 지원할 수 있다. 여기에서 까다로운 부분은 비즈니스 트랜잭션의 수명 동안 정확한 변경 사항의 집합을 유지해야 한다는 것이다. 애플리케이션이 `도메인 모델`을 사용하는 경우 `작업 단위`로 정확하게 변경을 추적할 수 있다.

비즈니스 트랜잭션에서 적용하기 까다로운 ACID 속성은 격리다. 격리의 실패는 일관성의 실패로 이어진다. 일관성을 유지하려는 비즈니스 트랜잭션에서 레코드 집합을 잘못된 상태로 만들지 말아야 한다.

비즈니스 트랜잭션은 세션과 밀접하게 연관된다. 일반적으로 모든 비즈니스 트랜잭션은 단일 클라이언트 세션에서 실행된다고 간주한다.

### 오프라인 동시성 제어를 위한 패턴

가능하면 트랜잭션 시스템이 최대한으로 동시성 문제를 맡아서 처리하게 해야 한다. 

모든 비즈니스 트랜잭션을 요청 하나에 연결해 시스템 트랜잭션 하나로 처리할 수 있다면 그렇게 하는 것이 좋다. 또 확장성을 포기하고 긴 트랜잭션을 사용할 수 있다면 그렇게 하는 것이 좋다. 이 패턴은 모든 동시성 문제를 해결하는 방법은 아니며 동시성 제어를 트랜잭션 소프트웨어에 맡길 수 없을 때 사용한다. 동시성 제어를 트랜잭션 소프트웨어에 맡기면 수고를 크게 덜 수 있다.

오프라인 동시성을 처리하는 첫 번째 선택은 낙관적 동시성 제어를 사용하는 `낙관적 오프라인 잠금`이다. 이 패턴은 프로그래밍하기 쉽고 활동성이 가장 높다. 한계는 비즈니스 트랜잭션이 실패하는 경우 커밋할 때가 되서 알 수 있다는 점이다. `비관적 오프라인 잠금`은 대안으로 문제를 조기에 알 수 있지만 프로그래밍하기가 어렵고 활동성이 제한된다.

이 두 방식을 사용할 때 객체의 잠금을 직접 관리하려고 하지 않는다면 복잡도를 크게 낮출 수 있다.
`굵은 입자 잠금`을 사용하면 객체 그룹의 동시성을 함께 관리할 수 있다.
`암시적 잠금`을 사용하면 애플리케이션 개발자의 부담을 크게 덜 수 있다. 이 방식을 사용하면 잠금을 직접 관리할 필요가 없다.

동시성을 다루는 것은 아주 어려운 프로그래밍 작업 중 하나다. 실제 이 패턴을 활용해야 할 때는 숙련된 동료 개발자의 도움을 받는 것이 좋을 수 있다.

### 애플리케이션 서버 동시성

동시성의 다른 형태로 애플리케이션 서버 자체의 프로세스 동시성이 있다. 이 동시성 문제에서는 서버가 여러 동시 요청을 어떻게 처리하며, 설계에 어떤 영향을 미치는지 고려한다. 애플리케이션 서버 동시성은 트랜잭션과는 관계가 없다.

잠금과 동기화 블록을 사용해 명시적 다중 스레드 프로그램을 제대로 구현하기는 어렵다. 주의하지 않으면 결함이 쉽게 발생하고 버그 재현이 거의 불가능하다. 따라서 동기화와 잠금을 명시적으로 처리해야 하는 경우는 가급적 최소화해야 한다.

가장 간단한 방법으로 `세션별 프로세스(process-per-session)를 사용하는 것이다. 이 방식의 장점은 각 프로세스의 상태가 다른 프로세스와 격리되므로 다중 스레드에 대해 신경 쓸 필요가 없다. 문제는 프로세스가 리소스를 너무 많이 소모한다는 점이다. 그래서 각 프로세스는 한 번에 한 요청만 처리하고 다른 세션의 여러 요청을 순차적으로 처리할 수 있도록 프로세스의 풀을 만들어 효율을 높이는 방법을 쓴다. 풀링하는 `요청별 프로세스(process-per-request)를 이용하면 일정 수의 세션을 처리하는 데 훨씬 적은 수의 프로세스를 사용할 수 있다. 주의할 점은 요청이 끝나면 사용한 모든 리소스를 반환해야 한다는 것이다. 아파치 mod-perl을 비롯해 여러 대규모 트랜잭션 처리 시스템에서 이 체계를 적용하고 있다.

한 프로세스가 여러 스레드를 실행하게 해서 처리량을 개선할 수 있다. `요청별 스레드(thread-per-request)`방식은 프로세스 내에 한 스레드에 의해 처리된다. 프로세스보다 서버 리소스를 적게 사용하므로 적은 하드웨어 리소스로 더 많은 요청을 처리해 서버의 효율을 높일 수 있다. 문제점은 스레드가 서로 격리되지 않으므로 스레드가 접근 가능한 데이터를 변경할 수 있다는 것이다.

권장하는 방식은 `요청별 프로세스`이다. `요청별 스레드` 보다는 효율이 낮지만 확장성은 충분하다. 또한 견고성이 더 우수하다.

일부 환경에서는 데이터의 격리된 영역을 단일 스레드에 할당하는 중간 성격의 기법을 지원하기도 한다. COM은 단일 스레드 아파트먼트(single-thread-apartment)라는 이름으로, J2EE는 엔터프라이즈 자바 빈즈라는 이름으로 이 기능을 제공한다. 이걸 사용하면 요청별 스레드의 효율과 요청별 스레드의 격리라는 두 장점을 취할 수 있다.

요청별 스레드를 사용할 때는 다중 스레드 문제를 걱정할 필요가 없는 격리된 지역을 만들고 이를 활용해야 한다. 스레드가 요청을 처리하기 시작할 때 다른 스레드와 상관 없는 새로운 객체를 만들고 이를 활용하는 방법으로 한다.

객체 생성 프로세스에 비용이 많이 든다고 판단하면 객체를 풀링하는 방법으로 해결한다. 풀링을 사용할 때의 문제는 풀링된 객체에 대한 접근을 동기화해야 한다는 것이다. 각 세션마다 새로운 객체를 만들면 많은 동시성 버그를 예방하고 확장성을 개선할 수 있다. 이 방식을 사용하려면 정적 변수, 클래스 기반 변수, 전역 변수 등을 피해야 한다. 싱글턴의 경우도 마찬가지다.

전역 메모리와 비슷한 기능이 필요하다면 `레지스트리`를 사용한다. 레지스트리는 정적 변수와 비슷하지만 실제로는 스레드별 저장소를 사용하도록 구현할 수 있다.

### 참고 자료

- [Bernstein and Newcomer]
- [Lea]
- [Schmidt et al.]