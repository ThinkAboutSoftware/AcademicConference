## 09장 도메인 논리 패턴

리뷰 및 논의주제)

이번 챕터에서는 도메인 논리를 어떤 패턴과 구조로 가져가냐에 따라 자세한 설명을 한 거라 보고 싶습니다.
아래 네 가지 중에 객체지향적인 요소가 얼마나 강해야 하는지에 대해 점수를 1점부터 10점 까지 매겨 봤습니다.
그리고 데이터베이스와의 연관성도 생각해 봤습니다.

Transaction Script, 1점, 10점
Domain Model, 10점, 1점
Table Module, 8점, 8점
Service Layer, 10점, 1점

이렇게 놓고 봤을 때 저는 도메인 논리에는 도메인 모델과 그 위에 더 추상화된 계층의 서비스 레이어를 잘 조합하면 좋겠다는 생각이 들었습니다.
그리고 지금은 서비스 레이어가 상식적이고 자연스러운 패턴으로 여겨지고 있는데 무려 도메인 주도 개발 보다도 더 전에 서비스 레이어를 생각했다는 점이 흥미로웠습니다.

본격적인 논의 주제로, 프레임워크에서 강제하는 서비스 레이어 (예: 스프링 부트)외에 도메인 모델링을 하면서 서비스 레이어를 설계하고 구현한 경험이 있는지 얘기해 봤으면 합니다.

저의 경우는 현재 유니티 + iOS 애플리케이션을 개발하면서 공통으로 사용할 서비스 레이어를 추상화 시켜 두고 그 하위에 네트워크(사실상 데이터베이스를 쓰지 않으므로 네트워크가 데이터베이스 역할을 대체) 레이어를 두는 형태로 설계를 했었습니다.
확실이 다른 플랫폼으로의 이식이나 변경의 용이성 측면에서는 도메인 - 서비스 - 네트워크(데이터베이스)로 나누는게 확실히 좋다는게 느껴졌습니다.

- Transaction Script
- Domain Model
- Table Module
- Service Layer

### 트랜잭션 스크립트

> 비즈니스 논리를 프로시저별로 구성해 각 프로시저가 프레젠테이션의 단일 요청을 처리하게 한다.

<img width="504" alt="image" src="https://github.com/jongfeel/BookReview/assets/17442457/d8bd709c-d281-4852-8a23-32ba71ebc5ed">

트랜잭션 스크립트(Transaction Script)는 논리를 단일 프로시저로 구성하고 데이터베이스를 직접 또는 씬 데이터베이스 래퍼를 통해 호출한다.

#### 작동 원리

트랜잭션 스크립트를 사용하는 경우 도메인 논리는 주로 시스템에 대해 수행하는 트랜잭션으로 구성된다.
이 방식의 장점 중 하나는 다른 트랜잭션에서 하는 일에 대해 신경 쓸 필요가 없고, 복잡한 경우가 아니라면 코드 작성이 어렵지 않다. 입력, 데이터베이스 조회, 작업 진행, 결과 저장의 단순한 논리로 진행된다.

트랜잭션 스크립트를 넣는 위치는 서버 페이지, CGI 스크립트 또는 분산된 세션 객체에 넣을 수 있다. 스크립트는 최대한 분리하는 것이 바람직하다. 트랜잭션 스크립트는 프레젠테이션 논리에 대한 호출을 포함하지 않아야 코드를 수정하고 테스트하기가 수월해진다.

클래스로 구성하는 방법은 두 가지가 있다.
여러 트랜잭션 스크립트를 한 클래스에 넣고 각 클래스에서 연관된 트랜잭션 스크립트의 주제 영역을 정의한다.
다른 방법은 명령 패턴[Gang of Four]을 활용해 각 트랜잭션 스크립트를 자체 클래스에 넣는 것이다. (그림 9.1)

<img width="499" alt="image" src="https://github.com/jongfeel/BookReview/assets/17442457/961fb0d6-dd94-4aee-8e0c-80345b0d3de6">

이렇게 하면 스크립트의 인스턴스를 런타임에 객체로 조작할 수 있는데, 트랜잭션 스크립트로 도메인 논리를 구성하는 시스템에서 이러한 기능이 필요한 경우는 거의 없다.

이 패턴을 트랜잭션 스크립트라고 하는 이유는 대부분 데이터베이스 트랜잭션마다 트랜잭션 스크립트가 하나씩 있기 때문이다.

#### 사용 시점

가장 큰 장점은 단순함이다. 작은 규모의 논리를 포함하는 애플리케이션에서는 자연스럽게 논리 구성을 할 수 있으며, 코드 실행 오버헤드가 적고 코드를 이해하기도 쉽다.

비즈니스 논리가 복잡해지면 트랜잭션 코드 간의 중복 문제로 좋은 설계 상태를 유지하기가 어려워진다.

리팩터링으로 어느 정도 완화활 수 있지만 복잡한 비즈니스 도메인을 제대로 구현하려면 `도메인 모델`을 이용해야 한다.

논리의 복잡도가 어느 수준 이상이어야 `도메인 모델`이 적합하다고 말하기는 어렵다. 리팩터링은 필요 이상으로 어려울 수 있으므로 처음부터 `도메인 모델`로 설계하는 것이 유리하다.

해결해야 하는 문제가 단순하다면 단순한 해결책으로 훨씬 빨리 해결하는 게 좋으므로
트랜잭션 스크립트를 처음부터 배제하는 건 현명하지 않다.

#### 수익 인식 문제

수익 인식의 규칙은 다양하고 변형이 많다. 법률이나 분야별 표준에 따라 정해지기도 하고 회사 정책에 따라 정해지기도 한다. 수익 관리는 복잡한 문제이다.

여기서는 세 가지 사품인 워드프로세서, 데이터베이스, 스프레드시트를 판매하는 가상의 회사를 예로 알아본다.
세 가지 상품에 대해 판매 수익에 대해 실제 규칙은 아니지만 가상의 규칙으로 정하면 다음과 같다.

- 워드프로세서: 판매 즉시 수익 계산
- 스프레드시트: 즉시 수익의 1/3, 60일 후 1/3, 90일 후 1/3
- 데이터베이스: 즉시 수익의 1/3, 30일 후 1/3, 60일 후 1/3

<img width="615" alt="image" src="https://github.com/jongfeel/BookReview/assets/17442457/9b5cfe8a-3edb-44a1-8288-6db60daca2b6">

#### 예제: 수익 인식(자바)

두 개의 트랜잭션 스크립트

- 특정 계약의 수익 인식 계산
- 특정 계약에서 특정 날짜까지 인식되는 수익 계산

세 개의 테이블로 정의한 데이터베이스

- 상품
- 계약
- 수익 인식

``` sql
CREATE TABLE products (ID int primary key, name varchar, type varchar)
CREATE TABLE contracts (ID int primary key, product int, revenue decimal, dateSigned date)
CREATE TABLE revenueRecognitions (contract int, amount decimal, recognizedOn date, PRIMARY KEY (contract, recognizedOn))
```

첫 번째 스크립트는 특정 날짜까지 인식된 총액을 계산한다. 수익 인식 테이블에서 해당하는 행을 선택 후에 금액을 합하는 두 단계로 수행할 수 있다.

트랜잭션 스크립트를 설계할 때는 SQL 코드를 프로시저에 넣어 데이터베이스에 대해 직접 작업하는 경우가 많다.
여기서는 `테이블 데이터 게이트웨이`를 사용해 SQL 쿼리를 래핑했다.

``` java
class Gateway {
  public ResultSet findRecognitionsFor(long contractID, MfDate asof) throws SQLException {
    PreparedStatement stmt = db.prepareStatement(findRecognitionsStatement);
    stmt = db.prepareStatement(findRecognitionsStatement);
    stmt.setLong(1, contractID);
    stmt.setDate(2, asof.toSqlDate());
    ResultSet result = stmt.executeQuery();
    return result;
  }

  private static final String findRecognitionsStatement =
   "SELECT amount " +
   "FROM revenueRecognitions " +
   "WHERE contract = ? AND recognizedOn <= ?";
 
  private Connection db;
}
```

게이트웨이에서 반환된 결과 집합을 바탕으로 합계를 구하는 코드를 작성한다.

``` java
class RecognitionService {
  public Money recognizedRevenue(long contractNumber, MfDate asOf) {
    Money result = Money.dollars(0);
    try {
      ResultSet rs = db.findRecognitionsFor(contractNumber, asOf);
      while (rs.next()) {
        result = result.add(Money.dollars(rs.getBigDecimal("amount")));
      }
      return result;
    } catch (SQLException e) {throw new ApplicationException (e);
    }
  }
}
```

인메모리 스크립트를 집계 함수로 총액을 얻는 SQL 문 호출로 대체할 수 있다.
할당하는 데 `금액(Money)`을 사용한다. 금액을 여러 개로 분할하면 잔돈을 잃어버리기 쉽다.

이 예제는 `도메인 모델` 예제와 비교해 봤을 때 훨씬 더 간단하다. 문제는 규칙이 복잡해질 때 해결하는 방법을 찾기 어렵다는 점이다.

### 도메인 모델

> 동작과 데이터를 모두 포함하는 도메인의 객체 모델

![image](https://github.com/jongfeel/BookReview/assets/17442457/437f246e-dfdc-41e1-b30b-22e2fe9587aa)

규칙과 논리는 매우 다양한 사례와 동작의 변형을 나타내고, 객체는 이런 복잡성을 처리하기 위해 고안됐다.
도메인 모델Domain Model은 각 객체가 하나의 기업과 같이 복잡하거나 주문서의 내용 한 줄과 같이 간단한, 의미 있는 하나의 대상을 나타내는 상호 연결된 객체의 연결망으로 이뤄진다.

#### 작동 원리

애플리케이션에서 도메인 모델을 구현하는 과정은 비즈니스 영역을 모델링하는 객체로 구성된 계층을 구성하는 과정이다.
객체지향 도메인 모델은 데이터베이스 모델과 비슷해 보이지만 도메인 모델은 데이터와 프로세스가 혼합된 구조이고, 다중 값  속성과 복잡한 연결망을 가지며, 상속을 사용한다.

그래서 두 가지 형식의 도메인 모델이 사용된다.

- 단순 도메인 모델: 도메인 객체가 데이터베이스 테이블과 일치
- 리치 도메인 모델: 상속, 전략, 다양한 [Gang of Four] 패턴, 복잡하게 상호 연결된 객체의 연결망을 포함

단순 도메인 모델에는 `활성 레코드`를 사용할 수 있지만
리치 도메인 모델에는 `데이터 매퍼`가 필요하다.

비즈니스 동작은 자주 변경이 일어나므로 이 계층을 쉽게 수정, 구축, 테스트할 수 있게 만드는 것이 중요하다. 그래서 도메인 모델과 시스템의 다른 계층 간의 결합을 최소화한다.

도메인 모델은 단순하게 할 경우 파일에서 전체 객체 그래프를 읽어 메모리에 저장하는 단일 사용자 애플리케이션이다. 모든 객체를 메모리에 저장하려면 메모리가 많이 필요하고 시간도 걸리므로 객체지향 데이터베이스의 장점을 이용해 볼 수 있다. 만약 사용할 수 없다면 필요한 일을 직접 해야 한다.

도메인 논리에서 흔히 하는 고민은 도메인 객체가 과하게 비대해지는 것이다. 특정 동작만 필요한데 특정 동작에만 사용하는데 객체를 계속 생성하다 보면 메모리 사용량이 많아질 수 있다.

##### 자바 구현

J2EE 상에서 도메인 모델을 개발하면 엔터티 빈을 사용해 도메인 모델을 개발하도록 권장하고 있다. 이 방식에는 몇 가지 문제점이 있다.

엔터티 빈은 CMP(컨테이너 관리 지속성)를 사용할 때 가장 유용하다. CMP는 제한된 형식의 객체-관계형 매핑이라고 할 수 있는데, 리치 도메인 모델에서 필요한 여러 패턴을 지원할 수 없다.

엔터티 빈은 재진입이 불가능하다. 리치 도메인 모델은 재진입을 자주 사용하므로 이는 중요한 장애요인이다. 재진입을 하지 않으면 될 수 있지만 도메인 모델을 사용하는 장점이 크게 퇴색한다.

엔터티 빈을 포함해 실행하려면 컨테이너가 있어야 하고 데이터베이스 연결이 필요하다. 그래서 빌드 시간이 길어지고, 테스트에도 데이터베이스 연결이 필요하므로 테스트 실행에 걸리는 시간도 길어진다. 엔터티 빈은 디버그하기도 까다롭다.

대안은 일반 자바 객체를 사용하는 것이지만 EJB 컨테이너에서는 일반 자바 객체를 실행할 수 없다고 생각하는 사람들이 많다. 2000년 레베카 파슨즈, 조쉬 메켄지와 함께 강연을 준비하면서 POJO(plain old java objects)라는 이름을 지었다. POJO 도메인 모델은 이해하기 쉽고 빠르게 만들 수 있으며 EJB 컨테이너 외부에서 실행 및 테스트를 할 수 있고 EJB 독립적이다.

도메인 논리가 복잡하지 않다면 엔터티 빈을 도메인 모델로 사용해도 된다.
반면 상속, 전략, 다른 정교한 패턴 등이 포함된 복잡한 도메인 논리를 구축하려면 상업용 툴이나 직접 제작한 계층을 활용해 POJO 도메인 모델과 데이터 매퍼를 만드는 것이 좋다.

EJB에서 리치 도메인 모델을 구현할 때는 도메인 모델 자체만으로 충분히 복잡하고 어려우므로 구현 환경의 세부사항과는 독립된 방법으로 구현한다.

#### 사용 시점

시스템이 수행하는 동작의 복잡도에 따라 결정한다. 복잡하고 끊임없이 변하는 비즈니스 규칙을 구현한다면 객체 모델을 사용하는 것이 현명하다.

개발팀에서 도메인 객체에 얼마나 익숙한지도 고려 대상이다. 도메인 모델을 익숙하게 사용하려면 적지 않은 연습과 교육이 필요하다. 하지만 익숙해 진다면 트랜잭션 스크립트로 돌아가고 싶은 마음이 생기지 않을 것이다.

도메인 모델을 사용한다면 데이터베이스에 데이터 매퍼를 사용하는 것이 좋다. 도메인 모델을 데이터베이스 독립접으로 유지할 수 있다.

도메인 모델을 사용할 때 도메인 모델에 더 고유한 API를 적용하려면 서비스 계층을 사용하는 걸 고려할 수 있다.

#### 참고 자료

도메인 모델은 객체지향 개발을 이야기할 때 핵심 주제이다. 객체지향 설계에 대한 안내서라면 [Larman]을 추천한다. 도메인 모델에 대한 예제는 [Fowler AP]를 추천한다.

[Hay]는 관계형 환경과 관련된 좋은 예제가 있다. 훌륭한 도메인 모델을 구축하려면 객체에 대한 개념적 사고방식을 이해해야 한다. [Martin-Odell]이 큰 도움이 된다. 리치 도메인 모델이나 패턴을 이해하려면 [Gang of Four]를 꼭 읽어본다.

에릭 에반스는 도메인 모델 구축에 대한 책 [Evans]를 집필 중에 있다.

#### 예제: 수익 인식(자바)

도메인 모델에 대한 예제의 아이러니는 예제를 간단히 만들어야 하는데 그러면 도메인 모델의 강력함을 제대로 보여줄 수 없다. 즉, 도메인 모델을 제대로 설명하려면 복잡한 도메인 모델의 예시를 들어야 한다.

그림 9.3에는 모든 클래스에 동작과 데이터가 포함되어 있다는 걸 알 수 있다. 간단한 수익 인식 클래스의 경우도 간단한 메서드가 포함되어 있다.

![image](https://github.com/jongfeel/BookReview/assets/17442457/d4ed9fb4-d603-465f-8391-dceb9009c47a)

도메인 모델을 보고 쉽게 알 수 있는 사실은 간단한 작업도 여러 클래스가 상호작용한다는 것이다.

예제에서 생성과 계산은 고객과 함께 시작되어 상품을 통해 전략 계층으로 전달된다. 전략 패턴[Gang of Four]은 잘 알려진 객체지향 패턴으로 작업의 그룹을 작은 클래스 계층으로 결합할 수 있다.

전략의 가장 큰 가치는 애플리케이션을 확장할 수 있는 잘 조직화된 연결점을 제공한다는 것이다. 새 수익 인식 알고리즘을 추가한다고 하면 하위 클래스를 만든 후에 메서드를 오버라이드 하면 된다.

객체에서 객체로 전달하는 객체지향의 습관은 동작을 처리하기에 가장 적절한 객체로 이동할 뿐 아니라 조건부 동작도 대부분 해결한다.

이 예제에서는 객체를 데이터베이스에 연결하는 건 없는데 이유가 있다.

- 도메인 모델과 데이터베이스를 매핑하는 건 힘든 작업이어서 예제로 만들지 않았다.
- 도메인 모델을 사용하는 중요한 이유로 상위 계층에서 도메인 모델을 사용하는 사람들에게 데이터베이스를 숨기는 데 있다.

### 테이블 모듈

 > 데이터베이스 테이블이나 뷰의 모든 행에 대한 비즈니스 논리를 처리하는 단일 인스턴스

![image](https://github.com/jongfeel/BookReview/assets/17442457/4fb23f9b-c29b-42b9-8acb-c3ae585bc985)

객체지향의 핵심 개념 중 하나는 데이터, 그리고 이를 사용하는 동작을 하나로 묶는 것이다. 객체지향 방식은 `도메인 모델`과 비슷한 맥락으로 식별자가 있는 객체에 기반을 두고 있다.

`도메인 모델`의 문제점 중 하나는 관계형 데이터베이스와의 인터페이스가 까다롭다는 점이다.

`테이블 모듈(Table Module)`은 데이터베이스의 테이블 당 클래스 하나로 도메인 논리를 구성하며, 클래스의 한 인스턴스가 해당 데이터에 대해 수행하는 여러 프로시저를 포함한다.

#### 작동 원리

테이블 모듈의 장점은 데이터와 동작을 하나로 묶으면서도 동시에 관계형 데이터베이스의 강력함을 그대로 활용할 수 있다는 것이다. 테이블 모듈은 객체와 비슷하지만 차이는 식별자 개념이 없다는 것이다. 특정 직원에 대한 어떤 작업을 한다면 항상 식별자 참조를 전달해야 한다. 이 식별자는 데이터베이스의 기본 키이다.

테이블 모듈은 테이블 기반의 기본 자료구조와 함께 사용한다. SQL 호출의 결과로 SQL 테이블을 흉내 내는 `레코드 집합`에 저장한다. 테이블 모듈은 이 데이터를 대상으로 작업하는 명시적인 메서드 기반 인터페이스를 제공한다.

의미 있는 작업이 진행되기 위해서는 여러 테이블 모듈의 동작이 필요하다. 그림 9.4와 같이 여러 테이블 모듈이 동일 레코드 집합을 대상으로 작업하는 경우가 많다.

<img width="499" alt="image" src="https://github.com/jongfeel/BookReview/assets/17442457/fe7d65f8-b0cb-47cb-af4d-4b3f1999e114">

전형적인 예제는 데이터베이스의 각 테이블당 하나씩 테이블 모듈을 사용하는 것이다. 뷰나 다른 쿼리가 있다면 이에 대한 테이블 모듈도 사용할 수 있다.

테이블 모듈은 인스턴스 하나이거나 정적 메서드의 컬렉션일 수 있다. 인스턴스일 때 상속 적용이 가능하므로 추가 동작을 더해서 모듈 작성 작업이 가능하다.

테이블 모듈은 쿼리를 팩터리 메서드로서 포함할 수 있다. 각 데이터 원본에 다른 테이블 데이터 게이트웨이를 사용하므로 테이블 모듈 하나를 다른 데이터 원본의 데이터에 사용할 수 있다.

테이블 데이터 게이트웨이를 사용하는 경우 레코드 집합을 조립한다. 그 다음 레코드 집합을 인수로 테이블 모듈을 만든다. 테이블 모듈은 레코드 집합을 대상으로 비즈니스 논리를 수행한 후 수정된 레코드 집합을 표시하고 프레젠테이션으로 전달한다. GUI에서 수정된 데이터는 다시 테이블 모듈로 전달된 후 유효성 검사를 거쳐 데이터베이스에 저장된다. 이 방식의 장점은 메모리에 레코드 집합을 생성해 데이터베이스를 거치지 않고 테이블 모듈을 테스트할 수 있다는 것이다.

<img width="501" alt="image" src="https://github.com/jongfeel/BookReview/assets/17442457/f82f55a7-97db-4a60-a42f-ca5474d683e6">

#### 사용 시점

테이블 모듈은 레코드 집합을 사용해 테이블 형식의 데이터에 접근할 때 가장 적합한 패턴이다. 또 자료구조를 중요한 요소로 다루므로 직관적으로 접근할 수 있다.

하지만 테이블 모듈은 복잡한 논리를 구성하는 객체의 강력함을 완전하게 활용하지 못한다. 직접 인스턴스-인스턴스 관계를 만들지 못하고, 다형성이 제대로 작동하지 않는다. 복잡한 도메인 논리를 처리해야 한다면 도메인 모델을 선택한다. 테이블 모듈은 도메인 모델의 능력 대신 테이블 기반 자료구조와 손쉬운 통합 능력을 맞바꾼 패턴이다.

도메인 모델의 객체와 데이터베이스 테이블이 상대적으로 비슷하다면 활성 레코드를 사용하는 도메인 모델을 사용하는 것이 낫다.
애플리케이션의 다른 부분이 일반적인 테이블 기반 자료구조에 바탕을 둔다면 테이블 모듈이 잘 어울린다.

이 패턴을 활용하는 환경은 .NET이 있다. 레코드 집합을 애플리케이션의 주요 데이터 리포지토리로 사용한다.

#### 예제: 테이블 모듈을 이용한 수익 인식(C#)

수익 인식 예제를 테이블 모듈로 적용해 본다.

테이블 모듈은 데이터 스키마에 기반을 둔다. 그림 9.6의 관계형 스키마를 사용한다.

<img width="504" alt="image" src="https://github.com/jongfeel/BookReview/assets/17442457/c4e66501-587b-404d-90d1-fdc0597612d4">

데이터를 조작하는 클래스는 같은 형태이고, 각 테이블당 테이블 모듈 클래스가 하나씩 사용된다.
.NET 아키텍처의 데이터 집합 객체는 데이터베이스 구조의 인메모리 표현을 제공한다. 따라서 이 데이터 집합을 이용하도록 클래스를 구축한다.
데이터 테이블 형식의 데이터 멤버가 포함되고 테이블을 일근ㄴ 이런 능력은 `계층 상위 형식`에 나올 수 있다.

``` C#
class TableModule
{
  protected DataTable table;
  protected TableModule(DataSet ds, string tableName) => table = ds.Tables[tableName];
}
```

하위 클래스 생성자는 테이블 이름으로 상위 클래스 생성자를 호출한다.

``` C#
class Contract
{
  public Contract(DataSet ds) : base (ds, "Contracts")
}
```

이것은 ADO.NET의 가이드라인에 따라 데이터 집합을 생성하는 코드를 테이블 모듈로 부터 분리하기 위한 것이다.
C#의 indexer를 사용하면 테이블에서 기본 키로 지정한 행을 가져오는 기능을 구현할 수 있다.

``` C#
public DataRow this[long key] => table.Select($"ID = {key}")[0];
```

계약의 수익 인식을 계산하고 수익 인식 테이블을 업데이트 한다. (책 예제 코드 참고) 이 동작은 계약 테이블의 데이터를 주로 사용하므로 계약 클래스에 메서드를 추가한다.

`금액`클래스를 사용하면 좋지만, 다양한 방법을 보여주기 위해 decimal을 사용했다.

### 서비스 계층

> 사용 가능한 작업의 집합을 설정하고 각 작업에 대한 애플리케이션의 반응을 조율하는 서비스의 계층으로 애플리케이션의 경계를 정의한다. - 랜디 스태퍼드

<img width="358" alt="image" src="https://github.com/jongfeel/BookReview/assets/17442457/12a463cd-cae3-4fc2-95b4-c843592a2bef">

저장하는 데이터와 구현하는 논리에 대한 다양한 인터페이스가 필요하다. 데이터 로더, 사용자 인터페이스, 통합 게이트 웨이 등이 있다.
이런 인터페이스는 데이터에 접근 및 조작하고 비즈니스 논리를 호출하기 위해 애플리케이션과 상호작용을 필요로 한다.
상호작용의 논리를 인터페이스에서 별도로 인코딩하면 중복이 많이 발생한다.

`서비스 계층(Service layer)`은 클라이언트 계층을 인터페이스하는 관점에서 애플리케이션의 경계[Cockburn PloP] 와 사용 가능한 작업의 집합을 정의한다. 또 트랜잭션을 제어하고 응답을 조율하면서 애플리케이션 비즈니스 논리를 캡슐화한다.

#### 작동 원리

"비즈니스 논리" 서비스 계층은 "도메인 논리"와 "애플리케이션 논리"로 나누면 좋다. 도메인 논리는 순수하게 문제 도메인을 집중적으로 처리하며, 애플리케이션 논리는 애플리케이션 역할[Cockburn UC]을 처리한다.

도메인 모델은 전통적인 디자인 패턴을 사용해 복잡성을 관리하고 도메인 논리 중복을 예방한다는 면에서 트랜잭션 스크립트보다 나은 방법이다.

애플리케이션 논리를 순수 도메인 객체 클래스에 넣으면 문제가 있는데,

- 도메인 객체가 특정 애플리케이션 논리를 구현하면 도메인 객체를 재사용하기 어려워진다.
- 두 종류의 논리를 같은 클래스에 넣으면, 나중에 분리할 필요가 있을 때 다시 구현하기 어렵다.

그래서 서비스 계층은 각 유형의 비즈니스 논리를 별도의 계층으로 분리해서 계층화의 일반적인 장점을 제공하고, 순수 도메인 클래스를 애플리케이션에서 재사용하기 쉽게 만들어준다.

구현의 변형으로 도메인 파사드(domain facade) 방식과 작업 스크립트(operaion scrip) 방식이 있다.

도메인 파사드 방식은 서비스 계층을 도메인 모델 위해 씬 파사드의 집합으로 구현한다. 파사드를 구현하는 클래스는 비즈니스 논리를 구현하지 않으며 도메인 모델이 모든 비즈니스 논리를 구현한다.

작업 스크립트 방식에서 서비스 계층을 리치 클래스 집합으로 구현한다. 애플리케이션 논리는 직접 구현하지만 도메인 논리는 캡슐화된 도메인 객체 클래스로 위임한다. 각 클래스는 애플리케이션 "서비스"를 형성하며 서비스 형식 이름이 "서비스"로 끝나는 경우도 흔하다. 서비스 계층은 여러 애플리케이션 서비스 클래스로 이뤄지며, 이런 서비스 클래스는 각자의 역할과 공통 동작을 추상화하고 계층 상위 형식을 확장해야 한다.

원격 호출에 대한 고려: 서비스 계층 클래스의 인터페이스는 클라이언트 계층에 제공되는 애플리케이션 작업의 집합을 선언하므로 굵은 입자 인터페이스이다. 서비스 계층 클래스는 인터페이스 세분성(interface granularity)의 관점에서 보면 원격 호출에 적합하다.

원격 호출은 객체 분산이라는 비용을 치러야 하므로 서비스 계층 메서드 시그니처를 `데이터 전송 객체`를 받게 변경하려면 부담스러운 추가 작업을 해야 한다.

우선 로컬로 호출할 수 있고 도메인 객체를 받는 메서드 시그니처를 사용하는 서비스 계층으로 시작하는 것이 좋다. 원격이 꼭 필요할 때는 서비스 계층에 `원격 파사드`를 넣거나 서비스 계층 객체에서 원격 인터페이스를 구현한다.

서비스 및 작업 식별: 서비스 계층 경계에 필요한 작업을 식별하는 과정은 간단하다. 중요하고 우선적인 서비스 계층 클라이언트는 사용자 인터페이스다. 사용자 인터페이스는 사용자가 애플리케이션으로 수행하는 유스 케이스를 지원하도록 설계되므로 서비스 계층 작업을 식별하는 시작점은 애플리케이션의 유스 케이스 모델과 사용자 인터페이스 설계다.

엔터프라이즈 애플리케이션의 유스 케이스는 도메인 객체를 대상으로 하는 CRUD이다. CRUD 유스 케이스와 서비스 계층 작업 간에는 거의 1:1 대응 관계가 있다.

유스 케이스를 실행하는 애플리케이션의 역할은 유효성 검사, 도메인 객체 생성, 업데이트, 삭제를 할 때 다른 사람이나 다른 애플리케이션에 알려야 한다. 이런 응답은 서비스 계층 작업에 의해 조율되고 트랜잭션을 통해 원자성을 유지해야 한다.

서비스 계층 추상화를 식별해서 그룹화하는 걸 할 수 있으면 좋은데, 아직은 체험적인 조언만 해줄 수 있다.

##### 자바 구현

서비스 계층 클래스는 도메인 파사드 방식과 작업 스크립트 방식 모두 POJO나 ㅅ아태 비저장 세션 빈으로 구현할 수 있다. 테스트하기 쉽고 트랜잭션 제어가 용이하다는 장점을 가진다. POJO 서비스 계층은 분산 컨테이너 관리 트랜잭션 서비스에 연결하기 어려우며 특히 서비스간 호출이 어렵다.

J2EE 상에서 서비스 계층은 EJB 2.0 상태 비저장 세션 빈과 로컬 인터페이스를 사용하고 작업 스크립트 방식으로 POJO 도메인 객체 클래스에 위임한다. EJB는 분산 컨테이너 관리 트랜잭션을 제공하므로 상태 비저장 세션 빈으로 구현하면 좋다.

세션 파사드는 엔티티 빈에 원격 호출 부하가 있을 때 성능 저하를 방지하는 방법으로 고안됐다. 반면 서비스 계층은 역할을 분리해서 재사용성을 향상하기 위해 만들어졌으며, 특정 기술에 얽매이지 않는 아키텍처 패턴이다. 세션 파사드는 서비스 계층과 비슷하지만 명칭이나 범위 사용 용도를 살펴보면 다르다.

#### 사용 시점

애플리케이션에 비즈니스 논리를 사용하는 클라이언트 종류가 둘 이상이고,
유스 케이스의 복잡한 응답에 여러 트랜잭션 리소스가 포함되는 경우,
분산 아키텍처가 아닌 컨테이너 관리 트랜잭션과 함께 서비스 계층을 활용하는 것이 좋다.

반대로
애플리케이션에 비즈니스 논리를 사용하는 클라이언트가 한 종류 뿐이고
유스 케이스의 응답에 여러 트랜잭션이 포함되지 않는다면 서비스 계층은 필요가 없다.

나중에 클라이언트가 추가되거나 유스 케이스에 두 번째 트랜잭션 리소스가 추가되는 경우가 있다면
처음부터 서비스 계층을 설계하는 것이 좋다.

#### 참고 자료

- 알리스테어 콕번(Alistair Cockburn)의 애플리케이션 경계 패턴이 서비스 계층에 영감을 주었다.
- 원격 서비스 [Alpert, et al.]에서는 분산 시스템에서 파사드 역할을 설명한다. 세션 파사드에 대해 [Marinescu]와 비교해 보면 좋다.
- 동작의 계약[Cockburn UC]이라는 유스 케이스는 서비스 계층 작업 내에서 조율해야 하는 애플리케이션 역할에 대해 설명한다.
- 시스템 작업[Coleman et al.] 에 대한 퓨전 방법론(Fusion methodology)의 관점도 알아두면 좋다.

#### 예제: 수익 인식(자바)

작업 스크립트 방식으로 서비스 계층을 구현하는 예제로 POJO를 사용하고 EJB를 사용한다.

애플리케이션 유스 케이스 요건에서, 계약의 수익 인식이 계산되면 이벤트에 대해 이메일 알림을 지정된 계약 관리자에게 전송하고 메시지 기반 미들웨어를 사용해 다른 통합 애플리케이션에 메시지를 게시하는 걸 고려한다.

트랜잭션 스크립트의 예제를 따라 RecognitionService 클래스를 수정해서 `계층 상위 형식`을 확장하고 `게이트웨이` 두 개를 사용해서 애플리케이션 논리를 수행한다. (그림 9.7)
RecognitionService 메서드는 작업 논리를 진행하고, 도메인 논리는 도메인 객체 클래스(`도메인 모델`)로 위임한다.

![image](https://github.com/jongfeel/BookReview/assets/17442457/82935d03-0685-49e8-99bd-b3530ebef002)

``` java
public class ApplicationService {
  protected EmailGateway getEmailGateway() {
    //return an instance of EmailGateway
  }
  protected IntegrationGateway getIntegrationGateway() {
    //return an instance of IntegrationGateway
  }
}
public interface EmailGateway {
  void sendEmailMessage(String toAddress, String subject, String body);
}
public interface IntegrationGateway {
  void publishRevenueRecognitionCalculation(Contract contract);
}
public class RecognitionService
extends ApplicationService {
  public void calculateRevenueRecognitions(long contractNumber) {
    Contract contract = Contract.readForUpdate(contractNumber);
    contract.calculateRecognitions();
    getEmailGateway().sendEmailMessage(
      contract.getAdministratorEmailAddress(),
      "RE: Contract #" + contractNumber,
      contract + " has had revenue recognitions calculated.");
    getIntegrationGateway().publishRevenueRecognitionCalculation(contract);
  }
  public Money recognizedRevenue(long contractNumber, Date asOf) {
    return Contract.read(contractNumber).recognizedRevenue(asOf);
  }
}
```

지속성과 관련된 세부사항, 트랜잭션 관련된 세부 사항은 예제에서는 다루지 않았다.

J2EE 플랫폼에서는 애플리케이션 서비스(및 게이트웨이)를 트랜잭션 리소스를 사용하는 상태 비저장 세션 빈으로 구현해 EJB 컨테이너가 분산 트랜잭션을 관리하게 할 수 있다. (그림 9.8)

![image](https://github.com/jongfeel/BookReview/assets/17442457/e4e42c5b-1733-4fd7-9902-362e8de9b384)

예제에서 중요한 점은 서비스 계층이 작업의 트랜잭션 응답을 조율하는 데 작업 스크립팅과 도메인 객체 클래스를 모두 사용한다는 것이다. 역할은 위임을 통해 재사용할 수 있게 팩터리을 거쳐 다른 객체로 분리된다.

관찰자[Gang of Four] 패턴을 사용하면 작업 스크립트를 더 세련되게 구현할 수도 있지만 상태 비저장 다중 스레드 서비스 계층에서는 구현하기 어렵다. 작업 스크립트를 통한 개방적인 코드가 더 명확하고 간단하다.

애플리케이션 논리 역할을 도메인 객체 메서드에 구현하거나 데이터 원본 계층에 구현하면 별도의 서비스 계층이 필요 없다고 생각할 수 있다. 하지만 몇 가지 이유로 권장하지 않는다.

- 도메인 객체 클래스가 특정 애플리케이션의 논리를 구현하면 여러 애플리케이션에서 재사용이 어려워진다
  - 도메인 객체 클래스는 관심사에 해당하는 도메인을 모델링 해야 한다.
- 애플리케이션 논리를 전용 목적의 "상위" 계층에 캡슐화하면 해당 계층의 구현을 변경하기가 용이하다.

서비스 계층은 엔터프라이즈 애플리케이션의 논리 계층을 체계화하기 위한 패턴으로, 스크립팅과 도메인 객체 클래스를 결합하고 둘의 장점을 활용하게 해준다.

이 패턴의 핵심은 애플리케이션의 비즈니스 논리의 구현을 캡슐화하고 다양한 클라이언트가 일관성 있게 호출할 수 있는 기반을 마련한다는 것이다.