## 01장 계층화

계층화(layering)는 소프트웨어 설계자가 복잡한 소프트웨어 시스템을 분할하는 데 사용하는 가장 일반적인 기법이다.

계층의 관점에서 시스템을 상위 계층은 하위 계층이 정의하는 서비스를 사용하지만, 하위 계층은 상위 계층을 인식하지 못한다.
모든 계층형 아키텍처가 이렇게 불투명한 구조를 갖는 건 아니지만 대부분 그러하다.

시스템을 계층으로 분할하면 여러 중요한 이점이 있다.

- 다른 계층에 대한 정보 없이도 단일 계층을 하나의 일관된 계층으로 이해할 수 있다.
- 동일한 기본 서비스를 가진 대안 구현으로 계층을 대체할 수 있다.
- 계층 간의 의존성을 최소화할 수 있다.
- 표준화하기 좋은 위치다.
- 한 번 구축한 계층은 여러 다른 상위 서비스에서 사용할 수 있다.

계층화는 중요한 기법이지만 단점도 있다.

- 계층은 전체가 효과적으로 캡슐화되지 않는다. 그 결과, 뭔가를 변경했을 때 다른 계층에 영향을 미치는 경우가 있다.
- 계층을 추가하면 성능이 저하된다. 일반적으로 각 계층에서는 정보를 한 표현에서 다른 표현으로 변환해야 한다.

그러나 계층형 아키텍처에서 가장 어려운 부분은 어떤 계층을 만들고 각 계층이 어떤 역할을 담당할지 결정하는 것이다.

### 엔터프라이즈 애플리케이션에서 계층의 발전

일괄 처리 시스템에서는 계층화에 대해 그리 신경쓰지 않은 것으로 보인다.

계층의 개념은 90년대 클라이언트-서버 시스템의 등장과 함께 중요해졌다. 이는 2계층 시스템으로 VB, 파워빌더, 델파이 등이 있다. 이런 툴은 SQL을 인식하는 UI 위젯이 있어서 데이터 중심 애플리케이션을 개발하는 데 적합하다.

2계층에서 문제는 비즈니스 규칙, 유효성 검사, 계산과 같은 도메인 논리를 수행하는 경우에 일어난다. 도메인 논리가 복잡해지면 코드 작업하기가 어려워지는 문제가 있다. 대안으로 도메인 논리를 저장 프로시저로 만들어서 데이터베이스에 저장하는 방법이 있는데 제한적인 구조화 메커니즘으로 어색한 코드가 되는 문제는 여전히 발생한다.

객체지향 쪽에서는 도메인 논리 문제에 대한 해결책으로 3계층 시스템을 제안했다.
UI를 위한 프레젠테이션 계층,
도메인 논리를 위한 도메인 계층,
데이터 원본을 이용하는 것이다.

이런 장점에도 객체지향 기법은 큰 진전이 없었는데, 당시 시스템이 너무 간단했기 때문이다. 해결하려는 문제가 간단하면 클라이언트-서버 2계층 툴이 너무 매력적이었다.

웹이 등장하면서 판도가 크게 흔들리기 시작했다. 웹 페이지 작성 툴은 SQL과의 결합이 훨씬 느슨했기 때문에 세 번째 계층을 받아들이는 데 유리했다.

계층을 이야기할 때는 계층(layer)과 티어(tier)를 혼동하는 경우가 많다. 종종 같은 의미로 사용하지만, 티어의 경우는 물리적 분리를 함축하는 경우가 많다. 클라이언트-서버 2계층 역시 클라이언트는 데스크톱에 설치되어 있고, 서버는 서버에 있으므로 물리적으로 분리돼 있기 때문에 2티어 시스템이라고 불리는 경우가 많다.
계층의 경우 다른 시스템에서 실행할 필요가 없음을 강조하기 위해 계층이라는 용어를 쓴다. 3계층을 단일 시스템에서 실행하다고 해도 세 개의 분리된 계층을 이야기할 수 있다.

### 세 가지 주요 계층

여기서는 프레젠테이션, 도메인, 데이터 원본이라는 세 가지 주요 계층을 다룬다.

프레젠테이션(presentation) 논리는 사용자와 소프트웨어 간 상호작용을 처리한다. 주 역할은 사용자에게 정보를 표시하고 사용자가 내린 명령을 도메인과 데이터 원본에서 수행할 작업으로 해석하는 것이다.

표 1.1 세 가지 주요 계층
| Layer | Responsibilities |
|-----|-----|
| Presentation | Provision of services, display of information (e.g., in Windows or HTML, handling of user request (mouse clicks, keyboard hits), HTTP requests, command-line invocations, batch API) |
| Domain | Logic that is the real point of the system |
| Data Source | Communication with databases, messaging systems, transaction managers, other packages |

데이터 원본(Data Source) 논리는 애플리케이션을 대신해 다른 시스템과 통신한다. 다른 시스템은 트랜잭션 모니터, 애플리케이션, 메시징 시스템이다. 대부분 엔터프라이즈 애플리케이션에서는 데이터베이스를 뜻한다.

도메인 논리(Domain Logic)는 입력과 저장된 데이터를 바탕으로 하는 계산, 프레젠테이션에서 받은 데이터의 유효성 검사, 프레젠테이션에서 받은 명령을 기준으로 작업 대상이 될 데이터 원본 논리를 결정하는 등의 작업이 포함된다.

이런 계층을 구분하는 방법은 애플리케이션이 얼마나 복잡하느냐에 따라 달라진다. 데이터베이스에서 데이터를 가져와 웹 페이지로 표시하는 간단한 스크립트는 스크립트 전체를 하나의 프로시저로 작성할 수도 있다. 세 계층으로 구분하기 위해 노력해도 되지만 이 정도 복잡도라면 각 계층의 동작을 별도의 서브루틴에 넣는 정도면 충분하다. 서브루틴 수준에서 상황에 맞는 가장 적절한 분리 방법을 선택해야 한다.

분리 외에 의존성에 대한 중요한 규칙이 있다. 도메인과 데이터 원본은 프러젠테이션에 의존하지 않아야 한다. 이 규칙을 지키면 동일한 기반의 다른 프레젠테이션으로 손쉽게 교체할 수 있다.

도메인 논리 작업에서 가장 어려운 점 중 하나는 도메인 논리와 다른 형태의 논리를 구분하기 어려운 경우가 많다는 것이다.
이 문제의 예로 지난달보다 10% 이상 더 판매된 상품을 빨간색으로 표시하는 시스템을 생각해볼 수 있다. 이것을 표현하는 논리로 프레젠테이션 계층에 추가할 수 있는데, 문제는 도메인 논리를 프레젠테이션에 넣었다는 것이다. 계층을 올바르게 분리하려면 상품 판매량이 늘었는지 확인하는 메서드를 도메인 계층에 넣어야 한다. 프레젠테이션 계층은 이 메서드를 호출하고 true가 반환된 경우에 빨간색으로 강조 표시만 하면 된다.

### 계층이 실행될 위치 선택

시스템의 다른 부분끼리의 결합(coupling)을 완화하기 위한 논리적 계층을 주로 설명한다.
계층 간의 분리는 한 시스템에서 모두 실행되더라도 유용하다. 그런데 시스템의 물리적 구조가 차이를 만드는 경우도 있다.

대부분 IS 애플리케이션은 처리를 수행할 위치를 클라이언트, 데스크톱 시스템 또는 서버 중에서 선택하는 것이 중요하다.

가장 간단한 방법으로 모든 걸 서버에서 실행하는 것이다. 이 방식의 장점은 서버에서 모든 작업이 이뤄지므로 업그레이드나 수정하기 쉽다는 것이다. 배포 후 서버 동기화 작업에 신경쓰지 않아도 되고, 다른 데스크톱 소프트웨어와 호환성 문제도 생각할 필요가 없다.

클라이언트 실행의 경우는 응답성, 비연결 작업의 유리함을 이유로 든다. 사용자의 즉각적인 피드백을 위해서는 서버 논리가 실행되는 네트워크의 왕복은 문제가 된다. 비연결 작업은 상당히 독특한 과제에 해당하지만 여기서는 다루지 않는다.

계층별로 선택할 수 있는 위치의 경우 데이터 원본은 거의 항상 서버에서 실행된다. 예외적으로 비연결 작업을 위해 서버 기능을 고성능 클라이언트에 복제하려는 경우가 있는데, 비연결 클라이언트의 데이터 원본에 대한 변경 사항을 서버와 동기화해야 하므로 비연결 작업에 대해서는 다루지 않는다.

프레젠테이션 계층을 실행하는 위치에 대한 결정은 사용자 인터페이스 유형에 따라 달라진다. 리치 클라이언트는 클라이언트에서 프레젠테이션 계층을 실행한다. 웹 인터페이스는 서버에서 실행한다. 데스크톱에서 실행되는 웹 서버에서 클라이언트 소프트웨어를 원격 운영하는 예외가 있지만 아주 드문 경우다.

B2C 시스템을 구축할 때는 다른 선택의 여지는 없다. 구식 컴퓨터에서도 온라인 쇼핑이 가능하게 해야 한다. 즉, 모든 처리르 서버에서 하고 소비자의 브라우저는 HTML을 전달한다. 이 방식의 제한은 모든 결정이 클라이언트와 서버 간의 왕복으로 수행되므로 응답성이 낮을 수 있다는 점이다. 브라우저 호환성 문제가 생길 여지도 있으므로, 순수하게 HTML만 사용할수록 문제가 간단해진다.

리치 클라이언트 프레젠테이션을 선호하는 주된 이유는 사용자가 직접 하기는 복잡한 작업이 있고 웹 GUI가 제공하는 것 이상의 기능이 필요한 경우 때문이다. 가능하면 웹 프레젠테이션을 사용하고 필요할 때만 리치 클라이언트를 사용하면 좋다.

도메인 논리의 경우는 서버나 클라이언트 모두 실행 가능하거나 분할 실행할 수 있다. 하지만 모두 서버에서 실행하는 것이 유지 관리를 생각할 때 최선의 방법이다. 비즈니스 논리가 클라이언트에 있는 경우는 응답성 개선이나 비연결성 작업을 지원하기 위해서이다.

모든 논리를 클라이언트에서 실행하는 것도 고려해 볼 수 있다. 이 방식은 리치 클라이언트와 관련이 있는데 응답성 보다는 비연결 작업 문제를 해결하는 방법일 수 있다. 모든 논리를 클라이언트에서 실행해도 `트랜잭션 스크립트`나 `도메인 모델`을 통해 도메인 논리를 프레젠테이션과 별도의 모듈로 유지할 수 있다. 문제점은 업그레이드 및 유지 관리해야 하는 것이 늘어난다는 점이다.

프로세싱 노드를 선택한 후에 노드의 모든 코드를 단일 프로세스에 넣어야 한다. 꼭 필요한 경우가 아니면 계층을 개별 프로세스로 분리하지 말아야 한다. 그렇지 않으면 `원격 파사드`, `데이터 전송 객체`등을 추가해야 할 때 너무 복잡하고 성능이 저하될 수 있다.