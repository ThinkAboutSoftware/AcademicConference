## 06장 세션 상태

비즈니스 트랜잭션과 시스템 트랜잭션 간의 차이는 상태 비저장 세션(stateless session)과 상태 저장 세션(stateful session)에 대한 논의의 바탕이 된다. 일부 세션은 본질적으로 상태 저장이라는 것을 인정하고 이 상태를 어떻게 처리해야 하는지 결정하는 것이 중요하다고 본다.

### 상태 비저장의 가치

분산 엔터프라이즈 애플리케이션의 상태 비저장 서버는 요청 간에 상태가 유지되지 않는 객체를 의미한다.

상태 비저장 서버 객체의 예로 책에 대한 정보를 담은 웹 페이지를 반환하는 객체를 생각해볼 수 있다. ISBN 번호를 통해 책 정보를 생성한 후에는  더 이상 이 값이 필요하지 않다. 다음 ISBN은 완전히 다른 작업이다.

특정 클라이언트 IP 주소에서 확인한 모든 ISBN을 추적한다고 가정해 보면, 서버 객체에서 ISBN 리스트를 관리해야 하고 이 리스트는 요청 간에 지속해야 하므로 상태 저장 서버 객체가 필요하다. 상태 비저장에서 상태 저장으로의 전환은 단순한 한 글자 차이 이상의 큰 의미가 있다.

상태 저장 서버의 우선적인 문제는 서버 리소스에 대한 것이다.
모든 상태 저장 서버 객체는 사용자가 웹 페이지를 보는 동안 대기하면서 모든 상태를 유지해야 한다.
반면 상태 비저장 서버 객체는 다른 세션의 다른 요청을 처리할 수 있다.

메서드 호출 간에 상태를 저장할 필요가 없으면 어떤 객체로 요청을 처리해도 관계없지만, 상태를 저장하려면 항상 같은 객체가 필요하다. 상태 비저장 서버는 트래픽이 많은 웹 사이트에 아주 유용하다. HTTP가 상태 비저장 프로토콜이므로 웹과도 잘 맞는다.

모든 것이 상태 비저장이면 간단하겠지만, 클라이언트 상호작용 중에는 근본적으로 상태 저장인 것이 많다. 전자상거래 사이트의 장바구니가 그 예이다. 장바구니는 사용자의 전체 세션 동안 유지돼야 한다. 책을 사지 않는다면 상관 없지만 책을 사려면 상태 저장이어야 한다. 돈을 벌려면 상태를 저장해야 한다.

다행스러운 소식은 상태 비저장 서버를 사용해 상태 저장 세션을 구현할 수 있다는 것이고,
흥미로운 소식은 이를 원하지 않을 수 있다는 것이다.

### 세션 상태

장바구니의 세부 사항은 세션 상태이므로 장바구니 안의 데이터는 특정 세션에만 해당된다. 이는 `레코드 데이터(record data)라고 부르는 것과는 구분된다. 레코드 데이터는 데이터베이스에 저장되는 장기 보존 데이터이며, 세션 상태는 커밋을 거쳐야 레코드 데이터가 된다.

세션 상태는 한 비즈니스 트랜잭션에 포함되므로 ACID와 같은 트랜잭션의 속성을 가진다. 하지만 이에 따른 영향은 잘 모르는 경우가 많다.

한 가지 흥미로운 영향은 동시성이다. 세션 상태는 작업 중인 동안에 유효성 검사 규칙과 맞지 않는 경우가 많다. 비즈니스 트랜잭션이 커밋할 때만 유효성 검사 규칙과 맞게 된다.

세션 상태와 관련된 가장 중요한 문제는 격리성이다. 관여하는 대상이 많기 때문에 고객이 보험 증서를 편집하는 동안 다양한 상황이 발생할 수 있다. 세션이 저장하는 모든 데이터가 세션 상태인 것은 아니다. 세션은 요청 간에 꼭 저장할 필요가 없는 데이터도 성능 향상을 위해 캐싱할 수 있다. 세션 상태는 올바른 동작을 위해 요청 간에 저장해야 하지만 캐시는 손절되더라도 올바른 동작에 방해되지 않는다.

### 세션 상태를 저장하는 방법

`클라이언트 세션 상태`는 데이터를 클라이언트에 저장한다. 방법은 URL에 데이터 인코딩, 쿠키 이용, 웹의 hidden 필드로 데이터 직렬화, 리치 클라이언트의 객체에 데이터 저장 등이다.

`서버 세션 상태`는 요청 간에 데이터를 메모리에 저장하는 간단한 방법일 수 있지만 일반적으로 세션 상태를 직렬화된 객체와 같이 더 안정적으로 저장할 수 있는 메커니즘이 사용된다. 객체는 애플리케이션 서버의 로컬 파일이나 공유된 데이터 원본에 저장할 수 있으며, 세션 ID와 직렬화된 객체가 각각 키와 값이 간단한 데이터베이스 테이블일 수 있다.

`데이터베이스 세션 상태`도 역시 서버 쪽 저장소지만 오랫동안 보관할 데이터를 저장하듯이 데이터를 테이블과 필드로 분리하고 데이터베이스에 저장하는 방식이다.

클라이언트 세션 상태를 사용하는 경우 요청과 함께 세션 데이터를 전송해야 하므로 필요한 대역폭을 고려해야 한다. 저장해야 하는 세션 상태의 양이 아주 적지 않으면 클라이언트 세션 상태는 사용하지 않는 것이 좋다. 보안과 무결성도 고려해야 한다.

세션 데이터는 격리해야 한다. 세션 끼리는 영향을 끼치지 않아야 한다. 데이터베이스 세션 상태를 사용할 때는 레코드 데이터로부터 세션 데이터를 격리하기 위해 까다로운 작업이 필요할 수도 있다.

사용자 수가 많은 경우 처리량을 향상하기 위해 클러스터링을 도입하는 걸 고려해서 세션 마이그레이션(session migration)이 필요한지 생각해야 한다. 이와 반대되는 개념은 한 서버가 특정 세션의 모든 요청을 처리하는 방식으로 서버 선호도(server affinity)다. 세션 마이그레이션을 사용하면 세션이 길에 유지될 때 서버가 처리하는 부하를 균형 있게 배분할 수 있다. 서버 세션 상태를 사용할 때는 세션을 처리하는 시스템만 해당 상태를 쉽게 찾을 수 있는 경우가 많기 때문에 불편한 상황에 처할 수 있다.

서버 선호도는 생각보다 심각한 문제를 유발할 수 있다. 클라이언트의 호출을 동일한 애플리케이션 서버로 전달하는데 그 기준으로 클라이언트의 IP 주소를 사용하는 경우가 많다. 클라이언트가 프록시를 사용하면 여러 클라이언트가 동일한 IP 주소를 사용하는 것으로 나타나므로 모두 특정 서버로 연결된다. 그러면 트래픽의 상당수가 한 서버로 집중될 수 있다.

인터넷 소매 사이트에서는 세션에서 사용하는 데이터 양은 많지만 유휴 사용자가 많을 수 있다. 따라서 데이터베이스 세션 상태가 성능 면에서 적절할 수 있다.
임대 시스템에서는 각 요청마다 많은 양의 데이터가 데이터베이스로 오간다. 따라서 서버 세션 상태를 선택하면 더 나은 성능을 얻을 수 있다.
사용자가 세션을 취소하고 다시 돌아오지 않을 경우도 있는데 B2C 애플리케이션은 사용자가 정상적으로 취소하지 않고 그냥 잊어버리는 경우가 있다. 이럴 때는 클라이언트 세션 상태를 쓴다.

세션 상태가 취소 되었다면 세션 상태를 지워야 하기에 일정 시간 제한을 둬서 취소하는 시스템을 마련해야 한다. 잘 개발된 서버 세션 상태의 구현에서는 이를 고려한 자동 시간 제한을 지원한다.

시스템적인 문제로 클라이언트 강제 종료, 서버 오류, 네트워크 연결 실패 등의 경우는
데이터베이스 세션 상태를 쓰면 잘 대처할 수 있다.
서버 세션 상태는 세션 객체를 어느 저장소에 저장해 뒀는지에 따라 대처 여부가 달라진다.
클라이언트 세션 상태는 클라이언트 강제 종료에만 대처 가능하다.

개발 난이도 측면에서는
서버 세션 상태는 가장 쉽게 개발 가능하며 세션 상태를 지속할 필요가 없다면 특히 더 쉽다.
나머지 두 상태의 경우 데이터베이스에 읽은 형식을 반환하거나 세션 객체가 사용할 형식을 변환하는 코드가 필요하다.

세 방식은 상호베타적인 방식이 아니며 여러 방식을 혼합해 세션 상태의 다른 부분을 저장할 수 있다. 하지만 여러 방식을 혼합하면 작업이 복잡해진다.