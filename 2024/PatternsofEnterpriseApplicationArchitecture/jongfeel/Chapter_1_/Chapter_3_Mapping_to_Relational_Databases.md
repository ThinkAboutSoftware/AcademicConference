## 03장 관계형 데이터베이스 매핑

데이터 원본 계층의 역할은 애플리케이션 작업을 수행하는 데 필요한 인프라의 다양한 부분과 통신하는 것이다. 이 계층은 주로 관계형 데이터베이스와 상호작용한다.

관계형 데이터베이스가 성공한 가장 큰 이유 중 하나는 테이터베이스 통신을 위한 표준화된 언어인 SQL이 있었기 때문이다.

### 아키텍처 패턴

아키텍처 패턴은 도메인 논리가 데이터베이스와 상호작용하는 방법을 좌우한다. 이런 패턴의 선택은 설계에 미치는 영향이 크고 리팩터링 하기 어려우므로 주의를 해야 한다. 또 도메인 논리를 어떻게 설계했느냐에 따라서도 영향을 받는다.

애플리케이션 개발자 중에 SQL을 이해하지 못해 효과적인 쿼리와 명령을 정의하는데 어려움을 겪는 사람이 많다.
SQL을 프로그래밍 언어로 삽입하는 다양한 기법이 있지만 다소 불편하다. 그래서 애플리케이션 개발 언어에 맞는 매커니즘을 사용해 데이터에 접근하는 것이 바람직하다.

![image](https://github.com/jongfeel/BookReview/assets/17442457/ec292799-2d9c-4481-917d-62a9a4e9134d)

이런 이유로 SQL 접근을 도메인 논리와 별도로 분리하고 개별 클래스에 배치하는 것이 좋다. 이런 클래스는 테이블에 대한 `게이트웨이`가 된다.

`게이트웨이`를 사용하는 데는 두 가지 방법이 있다.
확실한 방법으로 쿼리가 반환하는 각 행마다 인스턴스 하나를 만드는 것이다. (그림 3.1)
이를 `행 데이터 게이트웨이`라고 하며 데이터에 대한 객체지향적 사고방식과 자연스럽게 어울린다.

`레코드 집합`은 데이터베이스의 테이블식 특성을 흉내 낸 테이블과 행의 범용 자료구조이다. GUI 툴에 레코드 집합을 사용하는 컨트롤이 포함된 경우가 흔한 경우이다. 레코드 집합을 사용하는 경우 데이터베이스의 각 테이블마다 클래스가 하나만 있으면 된다.

![image](https://github.com/jongfeel/BookReview/assets/17442457/95e46eb0-ce67-4259-8881-1970593106a6)

간단한 애플리케이션도 게이트웨이 패턴을 사용하면 좋다. SQL과 도메인 논리를 명확하게 분리하면 많은 도움이 된다.

테이블 데이터 게이트웨이는 레코드 집합과 아주 잘 어울리므로 `테이블 모듈`을 사용하는 경우에도 확실한 선택이다. 또 저장 프로시저를 정리하는 데도 이 패턴을 고려할 수 있다.

도메인 모델을 사용할 때는 몇 가지 추가 옵션이 있다. 행 데이터 게이트웨이나 테이블 데이터 게이트웨이를 함게 이용할 수 있지만 이 옵션은 간접성이 너무 많거나 부족하다.

도메인 모델은 데이터베이스 테이블당 도메인 클래스 하나를 사용해 데이터베이스 구조에 아주 근접하게 대응되는 간단한 구조다. 그림 3.3과 같은 활성 레코드 구조를 통해 각 도메인 객체가 직접 데이터베이스의 로드와 저장을 수행하는 것이 적절하다.

![image](https://github.com/jongfeel/BookReview/assets/17442457/c184068c-c807-4274-801e-ff8df78515e1)

활성 레코드를 이해하는 다른 방법은 행 데이터 게이트웨이로 시작한 후 클래스에 도메인 논리를 추가한다고 보는 것이다. 이런 상황에서는 게이트웨이를 통해 추가된 간접성이 그리 도움이 되지 않는다. 도메인 논리가 복잡해지면 점차 리치 도메인 모델에 가까워지고 활성 레코드의 간단한 접근법으로는 주체하지 못하게 된다. 도메인 논리를 작은 클래스로 팩터링 하기 시작하면 도메인 클래스와 테이블의 1:1 매칭이 깨지기 시작한다. 관계형 데이터베이스는 상속이 지원되지 않으므로 디자인 패턴과 객체지향 패턴을 적용하기 어렵다. 도메인 논리를 개발하는 동안 데이터베이스와 상호작용하지 않고도 도메인 논리를 테스트할 수 있는 방법이 필요하다.

이런 요인들로 인해 도메인 모델이 복잡해지면 간접성을 원하게 된다. 도메인 모델이 데이터베이스 스키마와 밀접하게 결합되는 것은 막지 못한다. 게이트웨이의 일부 필드가 도메인 객체의 필드로 변환되는 현상이 발생하고, 이런 변환은 도메인 객체를 복잡하게 만든다.

그래서 도메인 객체와 데이터베이스 테이블 간의 매핑을 간접 계층을 통해 처리해 도메인 모델을 데이터베이스로부터 격리하는 것이 나은 방법이다. 그림 3.4의 `데이터 매퍼`는 데이터베이스와 도메인 모델이 서로 독립적으로 작동할 수 있게 중간에서 로딩과 저장을 대신 처리한다. 데이터 매퍼는 두 계층의 격리라는 장점을 제공한다.

![image](https://github.com/jongfeel/BookReview/assets/17442457/a9dcfbe3-c412-4a94-b436-f0ae1b590195)

도메인 모델의 주요 지속성 매커니즘으로는 게이트웨이는 비추이고 활성 레코드가 간단한 방법이다. 더 복잡한 논리가 필요하다면 데이터 매퍼가 적합하다.

이런 패턴이 서로 상호배타적이지는 않다. 데이터 매퍼를 사용해도 게이트웨이를 사용해 테이블이나 서비스를 래핑하고 외부 인터페이스로 취급해도 아무 문제가 없다.

복잡한 도메인 모델이라고 해도 저장할 수 있는 가장 간단한 방법에 대해 알아둘 필요는 있다. 객체지향 초창기에 객체와 관계 간에 근본적인 인피던스 부정합(impedance mismatch)이 있다는 걸 알았다. 그래서 객체지향 데이터베이스를 만들려는 노력이 이어졌고 객체지향 패러다임을 디스크 저장소에서 실현할 수 있게 됐다. 여기서는 매핑을 신경 쓸 필요가 없다. 상호연결된 객체의 구조를 그대로 사용 가능하고, 객체를 디스크로 저장하고 가져오는 작업을 데이터베이스가 처리한다.

객체지향 데이터베이스의 장점은 생산성 향상이다. 유지 관리 비용이 계속 들어가는 관계형 데이터베이스 매핑 작업의 1/3 수준의 프로그래밍 작업으로 줄일 수 있다.

하지만 대부분 프로젝트에서 객체지향 데이터베이스는 사용하지 않는데, 그 이유는 위험성 때문이다. 기존 관계형 데이터베이스는 오래 사용해왔고, 여러 공급업체가 있으며 입증된 기술이다. 또 SQL은 모든 종류의 툴을 위한 표준적인 인터페이스가 있기 때문에 그렇다.

객체지향 데이터베이스를 사용하지 않더라도 설계에 도메인 모델이 있다면 O/R 매핑 툴을 도입하는 걸 고려해야 한다. 물론 데이터 매퍼를 만드는 방법을 익히고 이해할 수 있지만 여전히 복잡하고 힘들다. 직접 만드는 것 보다 정교한 결과를 제공하는 상용이나 오픈소스 O/R 매핑 툴이 있으므로 계층을 직접 작성하고 유지 관리하는 시간과 비용을 크게 절감할 수 있다.

좋은 O/R 툴은 데이터베이스 매핑에 대한 다양한 옵션을 제공하며 패턴을 잘 이해하고 있다면 어떤 옵션을 언제 사용해야 하는지 알 수 있다. 툴이 모든 작업을 대신하는 것은 아니다, 큰 도움이 되는 것은 사실이지만 O/R 툴을 튜닝하고 사용하는 데도 적지 않은 작업이 필요하다.

### 동작 문제

O/R 매핑을 할 때 어려운 측면은 O/R 매핑의 아키텍처와 동작 측면이다. 동작 문제는 객체가 데이터베이스에 저장 및 로드되는 방법에 대한 것이다. 고객 객체가 이 작업을 수행하는 로드와 저장 메서드를 가질 수 있다. `활성 레코드`의 경우 이 방법을 선택하면 확실하다.

객체를 읽고 수정하는 동안 사용하는 데이터베이스의 상태를 일관되게 유지해야 한다. 객체 읽기/쓰기 격리를 잘 하지 못하면 일관성 문제가 발생하게 된다.

`작업 단위`는 이런 문제를 해결하는데 꼭 필요한 패턴이다. 작업 단위는 데이터베이스에서 읽은 객체와 함께 이후 다양한 방법으로 수정한 객체를 추적하고 데이터베이스를 업데이트 한다. 저장 메소드를 호출하는 대신 작업 단위에 커밋 요청을 하는 방식이다. 커밋을 위한 복잡한 작업을 순서대로 처리한다.

작업 단위는 데이터베이스 매핑의 컨트롤러로 작동하는 객체라고 생각하면 이해하기 쉽다. 작업 단위는 데이터베이스의 매핑 컨트롤러의 동작을 별도 객체로 팩터링 해서 만든 것이다.

`식별자 맵`을 이용해 읽은 모든 행의 기록을 추적하면 같은 객체를 로드해서 처리하는 문제를 예방할 수 있다. 이미 읽은 데이터의 경우는 데이터에 대한 참조를 통해 업데이트를 조율할 수 있다.

`도메인 모델`을 사용할 때는 데이터베이스에서 객체를 로드할 때 연관된 객체가 함께 로드되도록 구성하는 것이 일반적이다. 여러 객체가 상호 연결된 경우 많은 양의 객체를 로드해야 하는데 이런 비효율을 예방하려면 한 번에 읽는 양을 줄이고 나중에 필요할 때 데이터를 가져올 수 있게 하는 `지연 로드`를 쓴다. 객체 참조 대신 자리 표시자(placeholder)를 이용하는 기법으로 실제 객체 대신 사용하다가 링크 참조를 따라면 실제 객체를 가져올 수 있게 하는 방법이다. 지연로드를 적절한 지점에 활용하면 데이터베이스에 대한 각 호출로 데이터를 필요한 만큼 가져올 수 있다.

### 데이터 읽기

데이터를 읽는 메서드는 SQL Select 문을 메서드 구조의 인터페이스로 래핑하는 검색기(finder) 역할을 한다. 데이터베이스와 상호작용하는 클래스가 테이블 기반이라면 테이블 마다 클래스 인스턴스가 하나씩 있고 검색기 메서드를 삽입 및 업데이트와 결합하는 방법을 쓸 수 있다. 상호작용 클래스가 행 기반이라면 이런 방법은 쓸 수 없다.

검색기 객체를 별도로 만들어서 SQL 쿼리를 캡슐화하는 여러 메서드를 포함시켜 쿼리를 실행하면 검색기 객체가 적절한 행 기반 객체의 컬렉션을 반환하게 하는 식으로 해결한다.

데이터 읽기에는 성능 문제가 생길 수 있다.

가급정 행을 한 번에 읽는다. 여러 행을 읽기 위해 반복적으로 쿼리를 하는 일이 없게 해야 한다.

조인을 이용해 쿼리 하나로 여러 테이블을 한번에 가져온다. 조인된 테이블의 데이터를 얻는 `게이트웨이`나 한 번의 호출로 여러 도메인 객체를 로드하는 `데이터 매퍼`를 사용할 수 있다.

데이터베이스 최적화 기법으로 데이터 클러스터링, 세심한 인덱스 사용, 메모리 캐시 활용 등이 포함된다.

특정 데이터베이스와 데이터를 사용해 애플리케이션 프로파일링을 통해 튜닝할 시간을 확보한다.

### 구조적 매핑 패턴

#### 관계 매핑

객체와 관계형 데이터베이스가 연결을 처리하는 방법의 차이로 두 가지 문제가 발생한다.

첫째는 참조 방법의 차이다. 관계형 데이터베이스는 다른 테이블에 대한 키를 생성해 연결을 처리한다.

둘째, 관계형은 정규화를 지원하기 위해 모든 연관 링크가 단일 값을 가져야 한다. 이에 따라 객체와 테이블 사이에서 자료 구조가 반전되는 현상이 발생한다.

참조 방법의 차이를 해결하려면 각 객체의 관계형 식별자를 객체의 `식별자 필드`로 유지하고 이 값을 조회해 객체 참조와 관계형 키 간의 매핑을 처리한다. 지루한 절차이긴 하지만 기본적인 기법을 이해하면 어렵지 않다.

- 디스크에서 객체를 읽을 때 `식별자 맵`을 관계형 키에서 객체로의 조회 테이블로 사용
  - 키가 없을 경우는 `지연 로드` 사용
- 외래 키는 `왜래 키 매핑`을 사용해 객체 간 참조를 적절하게 구성 (그림 3.5)

![image](https://github.com/jongfeel/BookReview/assets/17442457/9e7b63c8-734a-4a38-8fe5-ff1ad6431c0d)

컬렉션 처리는 더 복잡한 버전의 외래 키 매핑이 필요하다. (그림 3.6) 대규모 시스템에서는 메타데이터 기반의 처리 방법을 찾는 것이 합리적이다. 컬렉션 객체가 컬렉션 소유자의 범위 외부에서 사용되지 않는 경우 `의존 매핑`을 활용해 매핑을 간소화할 수 있다.

![image](https://github.com/jongfeel/BookReview/assets/17442457/c40836c7-e1a6-4410-aecd-1e4480665eda)

양쪽 끝에 컬렉션이 있는 다대다 관계는 `연관 테이블 매핑`을 사용해 다대다 관계를 처리하는 새 관계형 테이블을 만들어야 한다. (그림 3.7)

![image](https://github.com/jongfeel/BookReview/assets/17442457/20d7cb40-4e41-488d-a92e-6a355c2d6e95)

컬렉션을 다룰 때 저지르는 실수로 컬렉션 내의 순서에 의존하는 것이다. 관계형 데이터베이스는 순서가 있는 컬렉션을 유지하기는 어려우므로 순서가 없는 집합을 사용하는 걸 고려할 필요가 있다. 저장할 때 정렬 순서를 지정하면 되긴 하지만 그러면 성능이 크게 저하될 수 있다.

참조 무결성 때문에 업데이트가 복잡해지는 경우도 있다. 이 기능이 있으면 사용하면 좋고 아니라면 데이터베이스가 모든 쓰기 작업에 대해 검사한다. 이 경우 업데이트가 올바른 순서로 수행되도록 주의해야 한다.

외래 키로 변환될 객체 간 참조에는 `식별자 필드`가 사용되지만 모든 객체 참조를 이 방법으로 저장해야 하는 것은 아니다. 날짜나 금액과 같은 작은 `값 객체`는 별도 테이블에 나타낼 필요가 없다. 값 객체의 모든 필드를 연결된 객체에 `포함 값`으로 넣으면 된다. 값 객체는 시맨틱을 가지므로 읽을 때마다 `식별자 맵`에 신경쓸 필요 없이 간단하게 생성할 수 있다.

이런 작업을 대규모로 수행하려면 객체 클러스터 전체를 테이블의 한 열에 `직렬화 LOB`로 저장하면 된다. LOB는 Large OBject를 의미하며 이진 데이터(BLOB)나 텍스트 데이터(CLOB)를 포함한다. 계층적 객체 구조를 다룰 때는 객체를 XML 문서로 직렬화 하는 것이 합리적인 방법이다. 이렇게 하면 한번의 읽기 연산으로 연결된 객체 전체를 가져올 수 있다. 데이터베이스는 상호 연결된 다수의 작은 객체를 잘 처리하지 못하므로 데이터베이스 호출을 여러번 수행하면서 시간이 낭비될 수 있다. 계층적 구조와 관련된 작업에는 `직렬화 LOB`를 적용하면 데이터베이스 왕복을 크게 줄일 수 있다.

직렬화 LOB는 저장된 구조를 부분적으로 쿼리할 필요가 없는 경우에 가장 적합하다. 일반적으로 애플리케이션의 일부를 구성하는 비교적 격리된 객체 그룹에 사용하는 것이 좋으며 남용하게 되면 데이터베이스가 트랜잭션 파일 시스템과 비슷해지므로 주의해야 한다.

#### 상속

관계형 데이터베이스에서 문제가 되는 또 다른 유형의 계층으로 상속으로 연결된 클래스 계층이 있다. SQL에는 상속을 처리하는 방법이 없기 때문에 이 경우에도 매핑을 해야 한다. 상속 구조를 처리하는 세 가지 방법은

- 단일 테이블 상속(그림 3.8)
- 구현 테이블 상속(그림 3.9)
- 클래스 테이블 상속(그림 3.10)

이다.

각 방법의 장단점은 자료구조의 중복과 접근 속도의 차이에 있다.
클래스 테이블 상속은 클래스와 테이블 간의 관계를 단순하게 저장하지만 단일 객체를 로드하기 위해 여러 번 조인을 수행하므로 성능이 낮다.
구현 테이블 상속은 한 객체를 한 테이블에서 가져올 수 있지만 상위 클래스가 변경되면 모든 테이블과 매핑 코드를 함께 변경해야 하는 부분에 있어서 취약하다.
일부 데이터베이스에서는 공간 낭비가 단일 테이블 상속의 가장 큰 단점일 수 있다. 각 행에 하위 형식의 열이 있어야 하므로 빈 열이 포함되기 때문이다. 데이터베이스는 낭비된 테이블 공간을 압축하는 기능을 갖추고 있으므로 사실 크기 때문에 접근 시 병목현상이 발생할 수 있는 게 또 다른 문제이다. 반대로 생각했을 때는 장점인데 모든 정보를 한 곳에 저장하므로 수정이 쉽고 조인이 필요가 없다.

![image](https://github.com/jongfeel/BookReview/assets/17442457/e5a04df9-66a9-4254-9647-b8596aadb774)
![image](https://github.com/jongfeel/BookReview/assets/17442457/86a9dec9-8c01-4a5c-be5a-b8f785aceeaa)

역시 세 패턴은 상호배타적이지 않으므로 한 계층에서 여러 패턴을 혼합할 수 있다. 각 패턴의 장점을 사용할 수 있지만 혼합하게 되면 복잡도는 높아진다.

최상의 패턴을 꼽기는 어렵지만 사용하기 쉽고 여러 번 리팩터링 하기도 수월한 단일 테이블 상속을 추천한다. 불필요한 열이 낭비되는 문제를 해결해야 한다면 다른 두 패턴을 고려한다. 그리고 DBA에게 문의하는 것이 가장 좋다.

### 매핑

관계형 데이터베이스 매핑을 한다면 아래 상황 중 하나이다.

- 스키마를 직접 선택할 수 있다.
- 기존의 스키마로 매핑해야 하며, 스키마를 변경할 수 없다.
- 기존의 스키마로 매핑해야 하지만 합의를 통해 스키마를 변경할 수 있다.

가장 간단한 건 스키마를 직접 만들고, 낮은 복잡도의 도메인 논리를 위해 설계에 트랜잭션 스크립트나 테이블 모듈을 사용하는 경우이다. 데이터 중심으로 테이블을 설계하고 도메인 논리에서 SQL을 가져오는 데는 행 데이터 게이트웨이나 테이블 데이터 게이트웨이를 사용한다.

도메인 모델을 사용할 때는 데이터베이스 설계와 비슷한 설계를 조심한다. 데이터베이스는 객체의 데이터를 지속하는 한 방법으로만 취급한다. 데이터 매퍼는 유연성은 높지만 복잡하다. 데이터베이스 설계가 도메인 모델과 같은 구조라면 활성 레코드를 대신 사용하는 걸 고려한다.

모델을 먼저 구성하는 게 합리적이지만 이를 위해서는 개발 반복 주기가 단기여야 한다. 6개월 동안 데이터베이스 없이 도메인 모델을 구축하는 건 위험하다. 6주 이내의 반복 주기마다 데이터베이스를 구축하는 게 바람직하다. 이렇게 하면 실제 수행되는 방법에 대해 즉각적이고 지속적인 피드백을 얻을 수 있다. 모든 특정한 작업은 도메인 모델을 먼저 고려하고 진행하면서 도메인 모델의 각 부분을 데이터베이스에 통합한다.

스키마가 이미 있는 경우는 과정이 약간 다르다. 도메인 모델이 데이터베이스 설계와 일치하지 않을 가능성이 높다. 그래서 도메인 모델을 점진적으로 구축하면서 데이터를 기존 데이터베이스에 저장할 데이터 매퍼를 포함시킨다.

#### 이중 매핑

둘 이상의 데이터 원본에서 같은 종류의 데이터를 가져와야 하는 경우이다.
첫째는 여러 데이터베이스에 동일한 데이터가 포함되지만 복사/붙여넣기 재사용 방법으로 스키마에 약간의 차이가 있는 경우다.
둘째는 다른 메커니즘으로 저장하는 경우인데, 데이터를 때로 데이터베이스에 저장하고 때로 메시지에 저장할 수 있다.

가장 간단한 방법은 데이터 원본마다 하나씩 매핑 계층을 여러 개로 만드는 것이다. 데이터가 비슷할 경우 코드 중복이 심해질 수 있다. 이럴 때는 2단계 매핑 스키마를 고려할 수 있다.
첫 단계로 데이터를 인메모리 스키마에서 논리적 데이터 저장소 스키마로 변환한다. 논리적 데이터 저장소 스키마는 데이터 원본 포맷의 유사성을 극대화하도록 설계한다.
두 번째 단계는 논리적 데이터 저장소 스키마에서 실제 물리적 데이터 저장소 스키마로 매핑한다. 이 단계에서 차이를 해결한다.

데이터는 비슷하지만 물리 데이터 저장소에 차이가 있어 불편한 경우에만 이중 매핑을 사용한다.

### 메타데이터 사용

간단하고 반복적인 매핑은 간단하고 반복적인 코드를 만든다. 반복적 코드는 설계에 문제가 있다는 신호이므로 공통 동작을 상속과 위임을 통한 팩터링으로 분리하는 것이 바람직한 객체지향 방식이다. 이럴 대 `메타데이터 매핑`을 이용한 정교한 방식을 사용한다.

메타데이터 매핑은 데이터베이스의 열이 객체의 필드에 매핑되는 구체적인 방법을 메타데이터 파일에 기록하는 것이다. 메타데이터를 만든 후에는 코드 생성이나 리플렉션 프로그래밍을 통해 반복적 코드를 대신할 수 있다는 것이다. 상용 O/R 매핑 툴이 메타데이터를 주로 사용하는 이유는 이런 유용성 때문이다.

메타데이터 매핑은 인메모리 객체를 얻는 쿼리를 작성하는 데 필요한 기반 정보를 제공한다. `쿼리 객체`를 이용하면 SQL이나 관계형 스키마의 세부사항을 몰라도 인메모리 객체와 데이터를 얻는 쿼리를 작성할 수 있다.

이를 더 발전시키면 뷰에서 데이터베이스를 보지 않아도 되는 `리포지토리`를 만들 수 있다. 데이터베이스에 대한 모든 쿼리를 리포지토리에 대한 쿼리 객체로 만들 수 있으며, 개발자는 객체를 메모리에서 가져왔는지 데이터베이스에서 가져왔는지 구분할 수 없게 된다.

### 데이터베이스 연결

데이터베이스 인터페이스는 애플리케이션 코드와 데이터베이스 간의 링크 역할을 하는 데이터베이스 연결 객체를 사용한다. 이 연결이 열려 있어야 데이터베이스에 명령을 실행할 수 있다.

연결을 만드는 데 비용을 절약하기 위해 연결 풀을 사용하는 경우가 많다. 직접 연결을 만들고 닫는 대신 필요할 때 풀에서 요청해서 작업이 끝나면 다시 풀로 반환하는 것이다.

풀에서 연결을 얻을 때로 새로 연결을 했는지 풀에서 할당한 연결인지 구분할 수 없도록 인터페이스를 통해 세부사항을 감추는 경우가 많다. 풀 사용 여부에 대한 캡슐화는 바람직하다.

연결은 만드는 비용이 크던 작던 관리가 필요하다. 연결은 관리하는 데 비용이 많이 드는 자원이므로 사용이 끝나면 즉시 닫아야 한다. 일반적인 조언은 풀이나 연결 관리자를 호출해 명시적으로 연결을 얻은 후 작업이 끝나면 연결을 닫는 식으로 한다.

연결이 피룡한 곳에서 연결을 확보하는 방법은 두 가지이다.
첫째는 연결을 명시적 매개변수로 정달한다. 문제는 불필요하게 모든 종류의 메서드 호출에 연결을 함께 전달해야 한다는 것이다. 이 문제는 `레지스트리`를 통해 해결할 수 잇다.

연결을 명시적으로 닫는 방법은 문제의 여지가 많다. 잊어버리고 연결을 닫지 않는 경우가 너무 많기 때문이다. 오늘날 환경은 자동 메모리 관리와 가비지 컬렉션을 제공하므로 가비지 컬렉션을 사용하면 연결을 확실하게 닫을 수 있다. 이 방법의 장점은 메모리 사용/해제와 동일한 관리 체계를 사용하므로 익숙하다는 점이다. 단점은 가비지 컬렉터가 메모리 회수할 때가 돼야 연결을 닫기 때문에 연결의 마지막 참조를 끊은 후 시간이 지난 후에 연결이 닫힌다는 점이다.

가비지 컬렉션에 의존하기 보다는 직접 닫는 편이 낫다. 가비지 컬렉션은 다른 방법이 실패했을 때의 보완책으로 쓴다.

연결은 트랜잭션과 관련되어 있으므로 함께 관리하는 것이 좋은 방법이다. 트랙잭션 시작시에 연결을 하고 커밋이나 롤백할 때 연결을 닫는다.  트랜잭션과 연결을 함께 관리하는 데는 `작업 단위`가 적합하다.

트랜잭션 바깥에서 하는 읽기 전용 데이터 읽기으 경우 명령마다 새로운 연결을 사용한다. 단수명 연결(short-lived connection)을 맏는 데 관련된 문제는 풀링으로 해결할 수 있다.

연결이 끊긴 레코드 집합은 연결을 다시 열고 데이터를 레코드 집합으로 가져온 후 연결을 닫고 레코드 집합 데이터를 조작한다. 이 방식으로 작업할 때는 데이터를 조작하는 동안 레코드 집합이 변경됐는지 확인해야 한다. 이 주제는 동시성 제어를 다룰 때 필요하다.

### 기타 주의사항

일부 코드에 정해진 열의 이름이 아닌 select * from 형식의 select 문을 사용하는 경우가 있다. 이 코드를 사용하면 새 열이 추가되거나 열이 재정렬되면 데이터베이스 드라이버에서 문제가 발생할 수 있다. 열 재정렬을 수행할 경우 코드가 충돌하므로 인덱스를 사용해 열에서 정보를 얻을 때는 select * 를 사용하지 않는 편이 좋다.

열 번호 인덱스의 경우 열이 재정렬될 때 동기화가 손상되지 않도록 결과 집합에 대한 접근을 SQL 문 정의와 비슷하게 구성해야 한다. `테이블 데이터 게이트웨이`의 경우 검색을 실행하는 코드에 결과 집합이 사용되므로 열 이름 인덱스를 사용해야 한다. 또 데이터베이스 매핑 구조에 대해 간단한 생성/읽기/업데이트/삭제 테스트 케이스를 만드는 것이 좋다. 그러면 SQL과 코드의 동기화가 손상되는 경우를 포착하는 데 도움이 된다.

동적 SQL 보다 정적 SQL에 시간을 투자하는 건 가치가 있다. 대부분 SQL 사전 컴파일 메커니즘을 제공하기 때문이다.

### 참고 자료

객체-관계 매핑에 대해 다룬 글은 상당히 많다.  데이터베이스 매핑의 훌륭한 아이디어로 [Brown-Whitenack], [Ambler], [Yoder], [Keller-Coldewey] 등이 있다.