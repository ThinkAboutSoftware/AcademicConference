## 07장 분산 전략

객체를 분산하는 작업에는 많은 함정이 있다. [Waldo et al.] 공급업체에서 말하는 선전 문구를 믿어서는 안된다.

### 분산 객체의 매력

새로운 OO 시스템의 설계는 새 분산 객체 시스템으로 되어 있다. 이 설계에서는 고객, 주문, 제품, 배송을 위한 원격 객체가 각각 분리되어 있고, 각 객체는 별도의 프로세스 노드에 배치할 수 있는 별도 컴포넌트이다.

![image](https://github.com/jongfeel/BookReview/assets/17442457/18df1e30-08d7-4381-8c79-fa48d97a5df5)

많은 툴 공급업체는 분산 객체의 주 목적으로 다수의 객체를 필요에 따라 원하는 형태로 프로세싱 노드에 배치하기 위해서라고 설명한다. 그리고 미들웨어가 투명성을 제공한다고 한다. 투명성은 이런 구조에서 얘기할 것은 아니다. 객체가 다른 객체를 한 프로세스 안이나 프로세스 간에 호출할 수 있게 해주는 개념이기 때문이다.

투명성은 가치가 높고, 분산 객체의 여러 측면에 긍정적 영향을 주지만 일반적으로 성능에는 영향을 주지 않는다. 설계자가 성능을 위해서라고 설명한 설계로 구현한다면 실제로 성능이 저하되며 시스템의 구축이나 배포도 훨씬 어려워진다.

### 원격 및 로컬 인터페이스

클래스 모델별 분산이 안좋은 이유는 컴퓨터의 기본 작동 원리 때문이다. 한 프로세스 내의 프로시저 호출은 극도로 빠르지만 분리된 프로세스 간의 프로시저 호출은 수십 배 또는 수백 배 느리다. 다른 시스템에서 실행 중인 프로세스에 대한 프로시저 호출은 네트워크 토폴로지에 따라 다시 시십 또는 수백 배 느려진다.

따라서 원격으로 사용할 객체의 인터페이스는 같은 프로세스 내에서 로컬로 사용할 객체의 인터페이스와는 달라야 한다.

로컬 인터페이스는 가는 입자 인터페이스(fine-grained interface)일 때 가장 좋다. 예로 주소 클래스에서 시, 도에 해당하는 값을 설정하고 얻어올 수 있는 메소드가 모두 별도로 있다면 좋은 인터페이스이다. 이 방식이 바람직한 이유는 다양한 방법으로 재정의하고 결합해 향후 설계를 확장할 수 있는 작은 조각으로 정의하는 객체지향의 일반적 규칙을 따르기 때문이다.

가는 입자 인터페이스는 원격 환경에는 잘 맞지 않는데 메서드 호출이 느리기 때문이다. 따라서 인터페이스는 유연성이나 확장성이 아닌 호출 횟수 최소화를 위한 굵은 입자 인터페이스(coarse-grained interface)로 만들어야 한다. 이런 인터페이스를 사용한 프로그래밍은 불편하지만 성능을 위해서라면 어쩔 수 없다.

그래서 "객체를 분산하지 말라"를 분산 객체 설계의 첫 번째 규칙으로 제시할 수 있다.

다중 프로세서를 효과적으로 활용하려면 클러스터링(그림7.2)이 가장 적합하다. 모든 클래스는 단일 프로세스에 있고 해당 프로세스의 여러 복사본을 다수의 노드에서 실행하는 것이다. 이렇게 하면 각 프로세스가 로컬 호출로 작업을 처리해 더 빠른 속도로 실행할 수 있다. 프로세스 안에서는 가은 입자 인터페이스를 사용하는게 좋으므로 단순한 프로그래밍 모델을 바탕으로 관리 효율성을 높일 수 있다.

<img width="587" alt="image" src="https://github.com/jongfeel/BookReview/assets/17442457/6a32f47d-0402-40cb-8ba5-9209fbb71072">

### 분산이 필요한 상황

분산 경계를 최소화하고 클러스터링을 통해 노드를 활용해야 한다는 것은 좋은데 이런 노력에는 프로세스를 분리해야 하는 상황에는 한계가 있다.

- 확실한 분리는 비즈니스 소프트웨어에서 전통적인 클라이언트와 서버 간의 분리다. 이런 분리는 일반적인 프로세스간 분리로 본다.
- 서버 기반 애플리케이션 소프트웨어와 데이터베이스 사이의 분리다. 필수는 아니지만 실용적이지 않기 때문에 보통 프로세스를 분리하게 된다. 원격 호출의 비용을 지불해야 하지만 SQL은 원격 인터페이스로 설계됐으므로 비용을 최소화하도록 설정 가능하다.
- 웹 시스템에서 웹 서버와 애플리케이션 서버 간에도 프로세스의 분리가 필요할 수 있다. 두 서버는 단일 프로세스로 실행하는 것이 좋지만 항상 가능하지는 않다.
- 공급업체 간의 차이 때문에 분리해야 할 수 있다. 소프트웨어 패키지는 자체 프로세스 안에서 실행하게 되므로 분산이 적용된다. 적어도 좋은 패키지는 굵은 입자 인터페이스를 가진다.
- 애플리케이션 서버 소프트웨어를 분리해야 하는 합당한 이유가 있는 경우다. 어쩔 수 없이 분리해야 하는 순간에는 원격의 굵은 입자 컴포넌트로 나눈다.

정리하면, 객체 분산은 도저히 방법이 없을 때 사용하는 최후의 수단으로 미뤄야 한다.

### 분산 경계를 사용한 작업

내부적으로는 가는 입자 객체를 사용하고 이에 대한 원격 인터페이스를 제공하는 굵은 입자 객체를 분산 경계에 배치한다.
굵은 입자 객체는 위임 외에 다른 일은 하지 않으므로 가는 입자 객체에 대한 파사드라고 할 수 있다.
이 파사드는 분산 용도로만 쓰므로 `원격 파사드`라고 한다.

원격 파사드를 이용하면 굵은 입자 인터페이스를 사용할 때의 어려움을 최소화하는 데 도움이 된다. 투명성에는 분명히 장점이 있지만, 잠재적 원격 호출은 투명하게 처리할 사항이 아니다.

이런 방식으로 전체 분산 정책을 훨씬 명시적으로 만들 수 있다. `데이터 전송 객체`는 `원격 파사드`와 밀접하게 연관되며 주로 함께 사용된다. 굵은 입자 메서드만 필요한 것이 아니라 굵은 입자 객체를 전송하는 기능도 필요하다. 데이터 전송 객체는 전송 전후 양쪽에서 모두 사용하므로 양쪽에서 공유하지 않는 것을 참조하지 않아야 한다. 데이터 전송 객체는 일반적으로 다른 데이터 전송 객체와 문자열 등의 기본 객체만 참조한다.

브로커를 통해 객체를 프로세스 간에 마이그레이션해 분산을 구현하는 방법도 있다. 데이터베이스에서 지연 읽기를 수행하는 대신 `지연 로드` 체계를 사용해 객체를 전송하는 것이다.

### 분산을 위한 인터페이스

전통적으로 원격 프로시저 호출에 기반을 두지만 XML over HTTP에 기반을 두는 인터페이스가 등장했다.
SOAP는 이러한 인터페이스 가운데 흔한 형태로 많은 사람들이 이 기술을 사용하는 실험을 했다.

XML 기반 HTTP 통신에는 여러 장점이 있다. 많은 양의 데이터를 구조화된 형식을 통해 단 한번의 왕복으로 손쉽게 전송할 수 있다는 것이다. 이런 특성은 원격 호출을 최소화 하는 데 도움이 된다. HTTP는 보안이나 정치적 이유로 다른 포트를 열기 어려울 때 방화벽을 통과하기가 쉽다.

전송한 데이터를 XML 구조와 문자열로 옮기는 과정은 원격 호출에 적지 않은 부담이 된다. 양쪽에서 동일한 바이너리 매커니즘을 사용한다면 XML은 그저 장식에 불과할 수 있다. 두 시스템에 동일한 플랫폼으로 구축된 경우라면 해당 플랫폼이 제공하는 원격 호출 매커니즘을 사용하는 것이 좋다. 서로 다른 플랫폼 간에 통신을 할 때에만 웹 서비스가 유용하다.

객체지향 인터페이스 위에 HTTP 인터페이스 계층을 추가해 양쪽 세계의 장점을 취하는 방법도 있다. 이 방법은 원격 객체지향 인터페이스를 위한 장비와 웹 서버가 모두 필요하므로 더 복잡하다는 단점이 있다. 이 방식은 HTTP와 원격 객체지향 API가 모두 필요하거나 원격 객체지향 API로 보안과 트랜잭션을 처리할 때 문제 해결이 더 용이한 경우에만 사용해야 한다.

여태까지는 동기식 RPC 기반 인터페이스에 대한 내용이었지만 이 방식이 분산 시스템을 운영하는 최상의 방법은 아니다. 근본적으로 비동기적인 메시지 기반 방식이 더 좋다.