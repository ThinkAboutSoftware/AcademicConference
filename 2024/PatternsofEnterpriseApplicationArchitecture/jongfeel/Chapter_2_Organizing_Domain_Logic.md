## 2장 도메인 논리 구성

도메인 논리는 `트랜잭션 스크립트`, `도메인 모델`, `테이블 모듈`의 세 가지 주요 패턴으로 분리했다.

도메인 논리를 저장하는 가장 간단한 방식은 `트랜잭션 스크립트`다. 
트랜잭션 스크립트는 프레젠테이션에서 입력을 받고, 유효성 검사와 계산을 통해 입력을 처리한 다음, 데이터베이스에 데이터를 저장하고, 다른 시스템에서 작업을 호출하는 프로시저다. 핵심 개념은 각 작업마다 프로시저 하나를 사용한다. 소매 시스템이라면 체크아웃, 장바구니에 상품 추가, 배송 상태 표시 등은 각각의 트랜잭션 스크립트가 있을 수 있다.

트랜잭션 스크립트의 장점은

- 간단한 절차적 모델이다.
- `행 데이터 게이트웨이`나 `테이블 데이터 게이트웨이`를 적용해 데이터 원본 계층과 함께 사용하기에 적합하다.
- 트랜잭션의 경계를 설정하기가 쉽다. 트랜잭션 열기로 시작하고 닫기로 종료한다.

단점은 도메인 논리가 늘어나면서 복잡도가 상승하는 결과로 나타난다. 여러 트랜잭션이 비슷한 작업을 주행하므로 코드가 중복된다.

복잡한 논리는 객체를 통해 해결할 수 있으며, 이 문제를 해결하기 위한 객체지향적 방법이 바로 `도메인 모델`이다. 

트랜잭션 스크립트 대신 도메인 모델을 사용하는 것은 객체지향 지지자들이 많이 이야기하는 패러다임의 전환을 의미한다. 한 루틴이 한 가지 사용자 작업의 논리를 처리하는 것이 아니라 각 객체가 관련된 논리의 일부를 담당한다.

두 패턴의 차이점을 이해하는 가장 쉬운 방법은 두 방식의 순서도를 보는 것이다. 문제의 핵심은 상품의 종류에 따라 계약의 수익을 인식하는 알고리즘이 다르다.

![image](https://github.com/jongfeel/BookReview/assets/17442457/c3865515-b7dc-478b-ae10-ca83dc385204)

2.1에서는 트랜잭션 스크립트 메서드가 모든 일을 다 한다.
2.2에서는 여러 객체가 있어서 최종적으로 전략 객체가 결과를 내놓을 때까지 각 객체가 동작의 일부를 다음 객체로 전달한다.

도메인 모델에 익숙해지면 복잡한 논리를 체계적으로 관리할 수 있는 다양한 기법을 활용할 수 있다. 객체에 대한 기본 개념이 정립된 후에는 간단한 경우에도 도메인 모델을 선호하게 된다.

도메인 모델을 사용하는 데 따르는 비용은 사용의 복잡성과 데이터 원본 계층의 복잡성이다. 익숙해지는데 시간이 필요한데 프로젝트 기간인 몇 달 동안 작업한 후에야 비로소 사고방식의 전환을 이루는 경우도 있다.

사고방식을 전환해도 데이터베이스 매핑으 여전히 해야 한다. 도메인 모델이 풍성해질수록 관계형 데이터베이스 매핑도 복잡해진다. 정교한 데이터 원본 계층은 거의 고정 비용이라고 볼 수 있다. (보통은 `데이터 매퍼`를 사용한다)

도메인 논리 구조의 세 번째 선택으로 `테이블 모듈`이 있다. 테이블 모듈은 도메인 모델과 비슷해 보이지만 두 패턴의 가장 중요한 차이는 도메인 모델은 데이터베이스에서 각 계약마다 계약 인스턴스가 있지만, 테이블 모듈은 인스턴스가 단 하나라는 것이다. 테이블 모듈은 레코드 집합과 함께 사용하도록 설계되어 있다. 

테이블 모듈은 트랜잭션 스크립트와 도메인 모델의 중간 성격을 많이 띤다. 테이블 기준으로 도메인 논리를 구성하므로 구조를 만들고 중복을 찾아 제거하기가 수월하다.

![image](https://github.com/jongfeel/BookReview/assets/17442457/6f7e8cb3-42f7-42c3-90f7-b140e350639c)

테이블 모듈의 가장 큰 장점은 아키텍처의 나머지 부분과 잘 맞는다는 것이다. GUI 환경은 레코드 집합으로 구성된 SQL 쿼리의 결과를 활용하는데 테이블 모듈 역시 레코드 집합을 이용해 작업할 수 있다. 테이블 모듈 안에 유효성 검사와 계산에도 사용할 수 있다. 마이크로소프트의 COM과 .NET을 비롯한 여러 플랫폼에서 이런 식의 개발 방법을 많이 활용한다.

### 선택

도메인 논리가 얼마나 복잡한지에 따라 어떤 패턴을 선택할지 결정해 볼 수 있다.

도메인 논리가 간단하면 도메인 모델의 매력이 떨어진다. 그러나 도메인 논리가 점차 복잡해지면 효율이 떨어지고 더 기능을 추가하기가 아주 어려워지는 수준에 이르게 된다.

![image](https://github.com/jongfeel/BookReview/assets/17442457/0bcbaaa1-f0b7-4e34-9168-a3117ff42e39)

도메인 논리의 복잡도가 어느 정도 이상이면 도메인 모델을 사용하는 것이 바람직하지만, 도메인 논리의 복잡도를 측정하는 방법은 아무도 도른다는 점이 문제이다.

그래프 곡선에 영향을 미치는 요소가 몇 개 있다.
개발팀이 도메인 모델에 익숙하다면 이 패턴을 사용하기 위한 초기 비용이 낮아진다.
테이블 모듈에 대한 선호도는 레코드 집합을 얼마나 잘 지원하느냐에 따라 달라진다. .NET이나 Visual Studio와 같이 레코드 집합과 관련된 툴이 많은 환경이면 테이블 모듈이 훨씬 매력적이다. 실제 .NET 환경에서는 트랜잭션 스크립트를 사용할 이유가 거의 없다.

결정을 내린 후에 바꾸는 것이 불가능하진 않지만 바꾸기가 까다로울 수는 있다.
트랜잭션 스크립트를 선택했는데 잘못된 길이라고 판단되면 지체없이 도메인 모델로 리팩터링을 시작한다.

세 패턴은 상호배타적인 선택은 아니다. 일부 도메인 논리는 트랜잭션 스크립트를 사용하고 나머지는 테이블 모듈 혹은 도메인 모델을 사용하는 경우도 있다.

### 서비스 계층

도메인 논리를 처리하는 일반적인 방법은 도메인 계층을 둘로 나누는 것이다. 이 경우 서비스 계층을 기반이 되는 도메인 모델이나 테이블 모듈 위에 배치한다. 도메인 계층을 둘로 나눈 경우 프레젠테이션 계층은 애플리케이션의 API 역할을 하는 서비스 계층과 단독으로 상호작용한다.

서비스 계층은 명확한 API를 제공하며 트랜잭션 제어와 보안과 같은 기능을 넣기도 좋은 위치다.

서비스 계층을 사용할 때는 얼마나 많은 동작을 넣을지 결정하는 것이 아주 중요하다. 소극적 사례로 서비스 계층을 파사드로 만들고 실제 동작을 기반 객체에 넣은 다음에 서비스 계층이 파사드에 대한 호출을 하위 객체로 전달하게 하는 것이다. 이 경우 서비스 계층은 유스 케이스를 반영해서 구성된 사용하기 쉬운 API를 제공한다.

반대로 극단적 사례는 대부분의 비즈니스 논리를 서비스 계층 안의 트랜잭션 스크립트에 넣는 것이다. 기본 도메인 객체가 도메인 모델을 경우 데이터베이스와 1:1 매칭 되므로 활성 레코드 같은 간단한 데이터 원본 계층을 사용할 수 있다.

양 극단의 중간 성격으로 행동을 혼합한 컨트롤러-엔티티 형식이 있다. 이 형식의 요점은 한 트랜잭션이나 유스 케이스에 적용되는 논리를 트랜잭션 스크립트에 넣는 것이며 일반적으로 이를 컨트롤러나 서비스라고 한다. 여기에서 얘기하는 컨트롤러는 MVC의 엽력 컨트롤러나 애플리케이션 컨트롤러와는 다르므로 유스 케이스 컨트롤러라는 용어로 쓴다. 둘 이상의 유스 케이스에서 사용되는 동작은 엔티티라고 하는 도메인 객체에 배치한다. 다만 이 방식은 코드 중복을 많이 유발하므로 권장하지 않는다.

절차형 서비스 객체는 논리를 팩터링 하는 아주 유용한 방법이지만, 이를 아키텍처의 필수 계층으로 활용하기 보다는 필요에 따라 이용한다. 즉, 보통의 경우엔 사용할 필요가 없다고 가정하며, 애플리케이션에서 꼭 필요하다고 판단될 때만 최대한 간소화한 서비스 계층을 사용한다.