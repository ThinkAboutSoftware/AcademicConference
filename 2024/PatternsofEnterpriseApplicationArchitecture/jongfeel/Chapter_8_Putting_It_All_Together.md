## 08장 종합

현재 진행 중인 프로젝트에 대한 설계 결정을 내리는 건 자기 자신이 가장 잘 알고 있다는 걸 명심해야 한다. 전문가가 겪는 어려움은 사람들이 설계상의 조언이나 프로세스상의 결정에 대해 묻는 것인데, 짧은 시간에 나눈 대화로 어떤 문제에 대한 구체적인 조언을 하기란 불가능하다.

이런 맥락에서 여기에 정리한 내용은 있는 그대로 받아들이기 보다 각자의 사고를 촉진하는 재료로 활용해야 한다.
결국 결정을 내리고 그 결과를 책임지는 건 자기 자신이다.

다행인건 영구적인 결정이란 없다는 점이다. 아키텍처 리팩터링은 힘들고 예기치 못한 비용이 많이 들지만 불가능한 것은 아니다.
익스트림 프로그래밍 [Beck XP] 전체가 마음에 들지 않아도

- 지속적 통합 [Fowler CI]
- 테스트 주도 개발 [Beck TDD]
- 리팩터링 [Fowler Refactoring]
 
이라는 세 가지 기술적 기법은 진지하게 고려해 볼 수 있다.
이런 기법이 만병통치약은 아니지만 마음을 바꿀 필요가 있을 때 해야 할 일을 훨씬 쉽게 만들어준다.
운과 실력이 좋은 사람이 아니라면 이런 기법은 반드시 필요할 것이다.

### 도메인 계층으로 시작하기

프로세스의 시작은 어떤 도메인 논리를 사용할지 선택하는 것이다.
여기에 고려할 수 있는 세 가지 패턴은 `트랜잭션 스크립트`, `테이블 모듈`, `도메인 모델`이다.

이 패턴을 고려할 때 가장 중요한 요소는 도메인 논리의 복잡도이다. 하지만 나중에 어떻게 복잡해질지 예측하기는 어렵다.
이 결정에 영향을 미치는 다른 요소로 데이터베이스 연결의 난이도가 있다.

트랜잭션 스크립트는 가장 간단하다. 그리고 가장 큰 단점은 복잡한 비즈니스 논리에 대처하기 어렵고 중복 코드가 늘어나는 것에 취약하다.
간단한 카탈로그 애플리케이션이라면 트랜잭션 스크립트가 적합하다.

도메인 모델은 반대의 성격을 가지는데, 도메인 논리가 복잡할 수록 도메인 모델 보다 효과적으로 어려운 문제를 해결할 수 있는 방법은 없다.
그리고 익숙해지면 간단한 문제도 쉽게 해결할 수 있다.
단점은 사용법을 배우는 것이 어렵다는 점이다. 그 다음 어려운 점으로 관계형 데이터베이스와의 연결이다. 객체 모델은 관계형 모델과 잘 어울리지 않는다. 그래서 여러 O/R 매핑 패턴이 복잡할 수밖에 없다.

테이블 모듈은 중간 쯤에 해당하는 매력적인 대안이다. 트랜잭션 스크립트보다는 도메인 논리를 원활하게 수행할 수 있고, 도메인 모델만큼 복잡한 도메인 논리에 매끄럽게 대처할 수는 없지만, 관계형 데이터베이스를 사용하는 데 아주 적합하며 여러 장점이 있다. `레코드 집합`과 관련된 툴이 있는 .NET과 같은 환경을 사용하는 경우 테이블 모듈을 선택하면 관계형 데이터베이스의 강력한 기능을 매끄럽게 활용할 수 있으며 도메인 논리의 팩터링도 합리적인 수준에서 가능하다.

이론적으로 아키텍처에 맞는 툴을 선택하는 것이 이상적이지만, 실제 보유한 툴에 따라 아키텍처를 맞춰야 하는 상황도 흔하다. .NET 환경의 경우 플랫폼 자체가 레코드 집합을 활용하는 데 적합하게 설계돼 있기 때문에 테이블 모듈과 아주 잘 어울린다.

### 데이터 원본 계층

데이터 원본과 연결하는 방법은 도메인 계층의 선택에 따라 달라진다.

#### `트랜잭션 스크립트`의 데이터 원본

간단한 애플리케이션을 만든다고 해도 데이터베이스를 분리하는 방법을 사용한다.
이 경우 데이터베이스 패턴은 `행 데이터 게이트웨이`와 `테이블 데이터 게이트웨이`다.

행 데이터 게이트웨이를 사용하면 각 레코드를 확실하고 명시적 인터페이스가 있는 객체로 읽는다.
테이블 데이터 게이트웨이를 선택하면 데이터에 접근하는 접근자 코드가 필요 없기 때문에 코드의 양은 줄지만 난해한 레코드 집합 구조에 접근하는 암시적인 인터페이스를 사용해야 한다. 플랫폼에서 레코드 집합과 잘 맞는 UI 툴이나 트랜잭션 비연결 레코드 집합을 지원하는 경우 테이블 데이터 게이트웨이 방향으로 가게 될 것이다.

이 맥락에서 다른 O/R 매핑은 필요가 없다. 스크립트가 시스템 트랜잭션과 거의 일치하므로 동시성 문제도 신경 쓰지 않아도 된다.

#### `테이블 모듈`의 데이터 원본

테이블 모듈을 선택하는 이유는 좋은 `레코드 집합` 프레임워크가 있기 때문이다. 그려면 `테이블 데이터 게이트웨이`가 매력적인 선택이다. 이 둘은 서로 잘 어울린다.

#### `도메인 모델`의 데이터 원본

`도메인 모델`의 가장 큰 약점은 데이터베이스에 대한 연결이 복잡하다는 것이다.

도메인 모델이 데이터베이스와 비슷하게 20개 정도의 클래스를 사용한다면 `활성 레코드`를 선택하는 것이 합리적이다.
결합을 느슨하게 한다면 `테이블 데이터 게이트웨이`나 `행 데이터 게이트웨이`를 사용한다.

복잡한 경우에는 독립적 운영을 위해 `데이터 매퍼`를 사용하는 것을 고려해야 한다. 데이터 매퍼를 선택하면 O/R 매핑과 관련된 대부분의 패턴이 개입된다. 동시성 제어의 구심점 역할을 하는 `작업 단위`를 적극 추천한다.

### 프레젠테이션 계층

리치 클라이언트 인터페이스와 HTML 브라우저 인터페이스 중 무엇을 선택하느냐에 있는데,
가급적이면 HTML 브라우저를 선택한다. 리치 클라이언트는 프로그래밍에 더 많은 노력이 필요하다.

그 다음 애플리케이션 기본 설계로 `모델 뷰 컨트롤러`를 우선적으로 추천한다.
툴에 따라서 그 다음이 결정되는데

- 비주얼 스튜디오를 사용하는 경우: `페이지 컨트롤러`, `템플릿 뷰`를 선택
- 자바 웹 스트럿츠(Struts)를 사용하는 경우: `프런트 컨트롤러`, `템플릿 뷰`를 선택

페이지 컨트롤러는 문서 기반이고 정적/동적 문서가 혼재되어 있을 때 사용한다.
프런트 컨트롤러는 복잡한 탐색 및 UI가 필요한 경우에 사용한다.

`템플릿 뷰`와 `변환 뷰` 중 무엇을 선택할지는 팀에서 프로그래밍에 서버 페이지와 XSLT 중 무엇을 사용하느냐에 따라 달라진다.
공용 사이트를 여러 다른 외형과 느낌으로 표시해야 하는 경우에는 `2단계 뷰`를 고려해야 한다.

하위 계층과 통신하는 방법으로는 한 프로세스에서 실행하는 방식으로 한다.
이렇게 하면 속도가 느린 프로세스 간 호출을 사용하지 않아도 된다.
한 프로세스를 사용할 수 없을 때는 도메인 계층을 `원격 파사드`로 래핑하고 `데이터 전송 객체`를 사용해 웹 서버와 통신한다.

### 몇 가지 기술 관련 조언

자바와 .NET은 아픙로 엔터프라이즈 애플리케이션 개발의 가장 일반적인 플랫폼이 될 것으로 예상한다.
파이썬이나 루비와 같은 동적 스크립트 언어도 좋은 경쟁상대가 될 수 있다.

#### 자바와 J2EE

자바 빈즈가 얼마나 가치있느냐가 주된 주에인데, EJB 2.0 까지 나왔지만 꼭 EJB를 써야 하는 건 아니다.
POJO(Plain Old Java Object)와 JDBC로도 상당히 많은 일들을 할 수 있다.

EJB에서 `트랜잭션 스크립트`를 `게이트웨이` 위에서 사용하는 경우 세션 빈을 `트랜잭션 스크립트`로, 엔티티 빈을 `행 데이터 게이트웨이`로 사용한다. 도메인 논리가 복잡하지 않다면 합리적인 아키텍처이다.

EJB를 쓰지 않으면 `행 데이터 게이트웨이`나 `테이블 데이터 게이트웨이` 위에 `트랜잭션 스크립트`로 POJO를 사용하는 것이다.

`도메인 모델`을 사용하려면 엔티티 빈을 사용하는 것이 일반적이다. 엔티티 빈은 `활성 레코드`가 된다.
그리고 엔티티 빈을 `원격 파사드` 역할을 하는 세션 빈으로 래핑하는 것이 좋다.

`도메인 모델`이 어느 수준 이상으로 복잡해질 경우에는 도메인 논리를 EJB 컨테이너의 변덕에 영향받지 않고 작성, 실행, 테스트할 수 있도록 EJB 구조에서 독립할 필요가 있다. 이런 모델은 POJO를 `도메인 모델`로 사용하고 `원격 파사드` 역할을 하는 세션 빈으로 이를 래핑한다. POJO 도메인 모델을 사용할 때는 O/R 매핑 툴을 활용하거나 직접 만든 데이터 매퍼에도 POJO를 사용하는 것이 바람직하다.

엔티티 빈을 사용할 때는 원격 인터페이스를 적용하지 않도록 주의하자. 엔티티 빈과 원격 인터페이스는 서로 맞지 않는다.
엔티티 빈은 주로 `도메인 모델`이나 `행 데이터 게이트웨이`로 사용된다.
이것들이 제 역할을 하려면 가는 입자 인터페이스가 필요하다.
원격 인터페이스는 굵은 입자여야 하므로 엔티티 빈은 로컬 전용으로 유지해야 한다는 걸 기억해야 한다.

`테이블 모듈`은 자바 세계에서는 흔하지 않다.

#### .NET

주된 패턴으로 `테이블 모듈`이 있으며 `트랜잭션 스크립트`와 `도메인 모델`의 중간 성격을 지닌 유용한 대안이며, `레코드 집합` 역할을 하는 범용적인 데이터 집합을 활용한 광범위한 툴을 보유하고 있다.
그래서 테이블 모듈 대신 트랜잭션 스크립트를 사용할 이유가 거의 없다.

`도메인 모델`도 사용할 수 있지만 테이블 모듈에서 제공하는 추가적인 툴의 도움을 받을 수 없으므로 약간의 불편함을 감수해야 한다.

애플리케이션 안에서 웹 서비스를 사용하는 건 권장하지 않는다.
또 하나의 .NET 애플리케이션에서 웹 서버와 도메인 논리를 별도의 프로세스로 만들 이유가 없으므로 `원격 파사드`도 유용성이 떨어진다.

#### 저장 프로시저

저장 프로시저는 데이터베이스와 동일한 프로세스에서 실행되며, 느린 원격 호출을 줄일 수 있기 때문에 작업을 가장 빠르게 실행하는 방법일 수 있다.

대부분 저장 프로시저 환경은 구조화 하는 좋은 메커니즘을 제공하지 않으며, 특정 데이터베이스 공급업체로 고착되는 문제가 있다.

모듈성과 이식성을 이유로 비즈니스 논리에 저장 프로시저를 기피하지만 성능이 크게 향상되는 경우가 흔하다. 이런 경우는 도메인 계층의 메서드를 가져와서 저장 프로시저로 옮긴다. 이 방식은 아키텍처 원칙이라기 보다는 최적화 단계 중 하나로 본다.

저장 프로시저의 일반적인 용도는 `테이블 데이터 게이트웨이`와 함께 데이터베이스에 대한 접근을 제어하는 것이다. 저장 프로시저든 SQL이든 동일한 패턴으로 데이터베이스 접근은 격리해야 한다.

#### 웹 서비스

웹 서비스는 애플리케이션 구축 보다는 통합을 위헌 것으로 전체 패턴에서 차지하는 비중이 그리 높지 않다.
꼭 필요한 경우가 아니면 한 애플리케이션을 서로 통신하는 웹 서비스로 분할하면 안된다. 애플리케이션에서 여러 부분을 웹 서비스로 노출하고 웹 서비스를 `원격 파사드`로 취급하는 것이 좋다.

### 다른 계층화 체계

#### [Brown et al.] 에 소개된 브라운 모델

**Table 8.1. Brown Layers**
| Brown | Fowler |
|--------|---------|
| Presentation | Presentation |
| Controller/mediator | Presentation (Application Controller) |
| Domain | Domain |
| Data mapping | Data source(Data Mapper) |
| Data source | Data source |

기본 적인 세 계층 사이에 두 중재 계층이 추가된 형식이다.

- 컨트롤러/중재자: 프레젠테이션과 도메인 계층 중재
- 데이터 매핑: 도메인과 데이터 원본 계층을 중재

패턴의 관점에서
`애플리케이션 컨트롤러`는 프레젠테이션과 도메인 간의 중재자이며,
`데이터 매퍼`는 데이터 원본과 도메인 간의 중재자다.

추가된 계층은 유용하지만 필수는 아니다. 

#### [Alur et al.] 코어 J2EE

**Table 8.2. Core J2EE Layers**
| Core J2EE | Fowler |
|------------|---------|
| Client | Presentation that runs on client (e.g., rich-client systems) |
| Presentation | Presentation that runs on server (e.g., HTTP handlers, server pages) |
| Business | Domain |
| Integration | Data source |
| Resource | External resource that data source communicates with |

비즈니스 계층 - 도메인 계층, 통합 계층 - 데이터 원본 계층과 간단하게 대응된다.
리소스 계층은 통합 계층이 연결하는 외부 서비스로 구성된다.
기본 계층과의 차이점은 프레젠테이션 계층을 클라이언트에서 실행되는 계층인 클라이언트와 서버에서 실행되는 계층인 프레젠테이션으로 분리했다는 것이다.

#### [kirtland] 마이크로소프트 DNA

**Table 8.3. Microsoft DNA Layers**
| Microsoft DNA | Fowler |
|------------------|--------|
| Presentation | Presentation |
| Business | Domain |
| Data access | Data source |


기본 계층의 개수와 거의 그대로 일치한다.
차이점은 데이터 접근 계층에서 데이터가 전달되는 방법인데, 마이크로소프트 DNA의 모든 계층은 데이터 접근 계층에서 수행한 SQL 쿼리를 통해 생성된 레코드 집합을 이용해 작업한다. 그래서 비즈니스와 프레젠테이션 계층이 데이터베이스에 대한 정보를 포함하는 결합(coupling)이 발생한다.

DNA에서 레코드 집합은 계층 간의 `데이터 전송 객체`의 역할을 한다.
비즈니스 계층이 프레젠테이션 연결 단계에서 레코드 집합을 수정하거나 생성할 수도 있다.
프레젠테이션에서 비즈니스 계층에서 수정된 데이터를 비롯 데이터 인식 GUI 컨트롤을 사용할 수 있다는 큰 장점이 있다.

이 경우 도메인 계층은 `테이블 모듈`의 형태로 구성되고
데이터 원본 계층은 `테이블 데이터 게이트웨이`를 사용한다.

#### [Marinescu] 계층

**Table 8.4. Marinescu Layers**
| Marinescu | Fowler |
|-------------|--------|
| Presentation | Presentation |
| Application | Presentation (Application Controller) |
| Services | Domain (Service Layer) |
| Domain | Domain (Domain Model) |
| Persistence | Data source |

이 모델에서는 `애플리케이션 컨트롤러`를 분리해 프레젠테이션을 두 개의 계층으로 나눴다.
도메인 역시 도메인 계층을 두 부분으로 나누는 아이디어를 반영해 `도메인 모델`과 `서비스 계층`으로 나눴다.
이 방식은 EJB를 `도메인 모델`로 사용할 때 적용되는 제한을 고려한 일반적인 방식이다.

도메인 계층에서 서비스 계층을 분리하는 아이디어는 순수 도메인 논리에서 워크플로 논리를 분리하는 아이디어에 바탕을 두는 것이다. 서비스 계층은 일반적으로 단일 유스 케이스에 해당하는 논리나 메시징과 같은 다른 인프라와 통신하는 코드를 포함한다.

#### [Nilsson] 계층

**Table 8.5. Nilsson Layers**
| Nilsson | Fowler |
|---------|---------|
| Consumer | Presentation |
| Consumer helper | Presentation (Application Controller) |
| Application | Domain (Service Layer) |
| Domain | Domain (Domain Model) |
| Persistence access | Data source |
| Public stored procedures | Data source (may include some domain) |
| Private stored procedures | Data source (may include some domain) |

닐슨은 저장 프로시저를 광범위하게 사용했고 성능상의 이유로 저장 프로시저 안에 도메인 논리를 넣는 것을 장려했으므로 이 계층에 매핑하는 작업은 복잡해진다. 닐슨의 저장 프로시저 계층은 데이터 원본과 도메인 논리를 모두 포함한다.

[Marinescu]와 마찬가지로 닐슨은 도메인 논리에 분리된 애플리케이션과 도메인 계층을 사용한다.
소규모 시스템에서는 도메인 계층을 생략할 수 있는데, 소규모 시스템에서는 `도메인 모델`의 중요성은 낮다고 볼 수 있다.