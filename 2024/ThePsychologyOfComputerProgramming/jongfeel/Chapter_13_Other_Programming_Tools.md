### 13장 그 외의 프로그래밍 도구들

```
논의주제)
문서화의 중요성에 대해서는 다른 분이 해주실 거라 믿고
다른 논의 주제를 잡아 봤습니다.

저는 컴퓨터와 질문 답변을 단일 저장소에 저장한다는 개념의 문서화 방식의 내용을 보고 너무 신기하고 놀라웠다고 생각했습니다.
그게 현재의 웹 사이트 검색과 ChatGPT, copilot 시스템을 사용하는 것과 크게 다르지 않다고 생각해서 저도 잠깐 상상을 해봤습니다.
저자의 생각과 비슷하게 미래지향적인 문서화에 대한 아이디어가 있다면 얘기해 보면 좋겠습니다.

저는 이제 코드 블럭에 따른 설명 까지는 chatGPT가 설명은 해 주니까 copilot 처럼 코드에 대한 설명이 자동으로 생성되면
그 문서를 학습시켜서 원하는 방향으로 제목을 붙이고 수정을 해서 문서를 만들어 주는 거죠.
그리고 그 문서의 내용을 요약해서 매일 일일 업무 정리를 해주는 걸 더 해보면 어떨까 생각해 봤습니다.
```

프로그래머가 사용하는 도구에는 언어만 있는 것은 아니다. 프로그래머는 문서를 읽거나 쓰고 버그를 잡는 데 많은 시간을 소비한다. 심리학적인 관점에서 볼 때 그런 작업들은 프로그래밍 언어보다도 더 무시받아 왔다.

#### 프로그램 테스트 도구

프로그래밍이 근본적으로 해결해야 하는 문제는 프로그램을 올바르게 작동하도록 만들고 증명하는 것이다.
프로그래밍은 오직 테스트 관점에서만 다루어도 충분히 말이 되는 분야다.

프로그래밍에서는 잘못의 크기와 그로 인해 발생하는 문제 사이에 아무런 연관 관계가 없다. 그것이 프로그래밍의 본질이다. 따라서 프로그램 테스트 작업의 목표를 어떤 공식으로 제시하기란 어렵다. 모든 오류의 제거를 목표로 하는 건 불가능한 일이다.

이상적인 테스트 도구는 우리가 프로그램을 신뢰할 수 있을 만큼만 신뢰하도록 도와주는 장치이다.
예를 들어, 어떤 프로그램의 테스트 결과를 신뢰할 수 있으려면 얼마나 많은 코드가 그 테스트의 대상이 되었는지 알아야 한다. 테스트 도구가 테스트 과정에서 실행되는 코드 영역과 그렇지 않은 영역을 기록해 나중에 결과와 함께 출력하는 것이다.

사람들은 자신의 프로그램을 낙관적으로 보고 신뢰하는 경향이 있으므로, 테스트 도구는 그 신뢰를 깨는 데 원칙을 두고 설계되어야 한다.

프로그램에 대한 프로그래머의 과신을 깨는 데에는 시스템적으로 테스트 도중에 무작위로 오류를 발생시키는 방법이 있다. 시스템에 그런 오류의 위치와 성격을 기록하되 프로그래머는 모르게 하는 것이다. 그리고 프로그래머가 알려진 오류를 발견하고 제거하는 확률을 통해 알려지지 않은 오류를 찾아 수정하는 확률을 추정할 수 있다. 이와 비슷한 기법이 항공관제에 쓰인다.

하지만 항공관제의 레이더 화면에 가짜 비행기를 띄우듯이 프로그램에 그럴듯한 오류를 심는 건 어렵다. 일부러 만들어 내야 하기 때문이다. 그럼에도 프로그래머의 테스트 능력을 훈련하거나 평가할 때 이 기법을 활용할 수 있다. 이건 자신이 만든 프로그램의 오류를 잘 찾아내지 못하는 근본적인 이유와 관련이 있다. 자신의 잘못이든 아니든 오류가 존재하고 자신이 찾아내지 못한다면 다른 사람들이 곧 알게 되는걸 프로그래머가 인식하면 오류를 찾아 고치는 데 좀 더 열성적인 태도를 보일 것이다.

테스트 결과의 신뢰도를 결정하는 요인에는 테스트의 과정 뿐 아니라 어떤 프로그램을 얼마나 많이 테스트해야 신뢰할 만한 결과를 얻을 수 있는지 경험에 비추어 판단하게 된다.

사용한 언어가 제공했든 프로그램 구조에 의한 효과든, 같은 양이라도 일관성이 높으면 테스트 결과에 대한 신뢰도가 커진다. 따라서 일관성이 뛰어난 언어와 프로그램 구조에 기반해야만 최고의 테스트 도구를 만들 수 있다.

이와 비슷하게 근접성과 간결성이 뛰어난 프로그램일수록 테스트하기 더 쉽다고 할 수 있다.

테스트 도구를 쓰면 프로그램의 일관선, 근접성, 간결성을 평가할 수 있는지에 대해서 아직 그런 테스트 도구가 개발될 수 있다는 실험적 증거는 없다. 하지만 연구 방향에 대해 여러 제안은 해볼 수 있다. 근접성은 레이블, GO TO 문장, 다른 페이지에 선언된 변수를 참조한 횟수 등으로 측정할 수 있다. 

일관성과 간결성은 근접성 보다 측정하기는 조금 어렵다. 간결성의 경우 길이가 어느 정도인 프로그램이 필요할지를 판단하는데 쓰는 기법을 참고할 수 있다. 또 각 변수를 참조한 횟수가 일관성이나 간결성의 척도가 될 수 있다. 배열 표현식 외의 방식으로 참조되는 경우가 많은 것도 일관성이 떨어지는 상황이라고 볼 수 있다.

코드에 나타나는 특정 패턴이 일관성과 간결성의 결여를 나타내기도 한다. 비슷한 이름의 변수들은 배열에 넣고 사용한다면 일관성이 있을 것이고 비슷한 코드가 되풀이되면 하위 루틴이나 매크로를 통해 코드를 더 간결하게 만들 여지는 있다. 아무 의미가 없을 수도 있는데 이건 프로그래밍 심리학에서 계속 연구해야 할 주제이다.

프로그래머는 테스트 초기에 OK가 되면 테스트를 끝내 버린다. 이건 초기 자료일수록 더 많이 신뢰하게 되는 심리 현상에 해당한다.  그런 실수를 줄이려면 테스트를 시작하기 전에 모든 테스트 케이스를 준비해야 한다. 그리고 가능하다면 코딩을 시작하기도 전에 테스트 케이스를 먼저 작성해 두는 편이 좋다. 테스트는 오류를 발견하는 것에서 시작된다. 따라서 오류를 발견하기 위한 테스트 케이스를 미리 만들어 두는 작업은 큰 의미가 있다.

테스트를 빨리 끝내려는 유혹을 이기기 위해 테스트 분량을 미리 계획해서 명시하고 시스템 차원에서 강제하는 것도 좋은 방법이다. 어떤 시스템의 경우 프로그램이 수정될 때마다 미리 저장되어 있던 테스트 케이스들을 자동으로 실행시킨다. 그래서 이전의 결과와 새로운 결과를 자동으로 비교해 차이가 있으면 통보하도록 할 수 있다.

심리적인 측면에서 프로그래머가 테스트 작업을 하는 걸 도울 수 있는 방법이 있다. 디버깅을 못해 고생하고 있는 동료에게 줄 수 있는 가장 큰 도움은 그가 다른 곳을 보게 만드는 것이다. 그래서 프로그래머가 한 영역에 집착하지 않도록 하는 것이다.

#### 운영체제

프로그래밍 언어 설계에서 디버깅 도구가 어디에 위치해 있어야 좋은가 하는 문제가 있다.
언어에 디버깅 도구가 포함되어야 한다는 쪽은 프로그래머가 디버깅을 위해 새로운 언어를 하나 통째로 배워야 하는 건 불합리하다고 말한다. 그러나 언어를 통해 디버깅을 하면 프로그래머와 실제 운영체제 사이에 언어라는 계층이 위치해서 운영체제의 실질적인 측면을 프로그래머가 보지 못할 수 있다.

심리학적인 입장에서 프로그래밍 언어를 확장해서 운영체제의 실질적인 측면을 가리지 않도록 만드는 정도가 적절한 타협점일 수 있다. 운영체제를 구현하는 입장에서는 일관성을 제공하기가 쉬운 일은 아닌데, 운영체제가 지원하는 프로그래미 언어가 하나 이상이기 때문이다. 그래서 운영체제를 만드는 사람은 언어 하나를 새로 만들어서 프로그래머들이 그 언어를 터득하도록 하는 방식을 택하기 쉽다.

작업제어 언어의 형식을 결정할 때는 키워드로 인자를 구분하거나 순서로 인자를 구분하는 방식 등을 고려하지 않았을 것이다. 운영체제 구현이라는 큰 문제에 비하면 사소한 것이기 때문이다. 비슷한 이유로 사용량 정보와 같이 성능을 평가하는 문제도 운영체제 설계자에게 외면 받았을 것이다.

프로그래머의 일은 디버깅이 끝이 아니다. 프로그램이 실행되긴 하더라도 그 비용이 너무 커서 문제가 될 수도 있다. 운영체제 설계자들은 프로그램을 실행하는 데 소요되는 시간, 시스템 자원의 양, 파일 레코드 개수, CPU 점유율 등의 정보를 알려 주지 않으려는 경향이 있다. 프로그래머가 프로그램의 성능을 높이는 방법을 배우려면 사용량 정보가 반드시 필요하다. 

사용량 정보 중 관심을 많이 가지는 항목은 배치(batch) 시스템의 평균 회송시간(turnaround time)일 것이다. 하지만 이건 운영체제가 제어하지 않으므로 운영체제가 제공하는 사용량 정보는 전체 회송과정을 대상으로 측정한 것은 아니다. 그리고 이 정보만으로 이상적인 회송 체계에 대한 문제는 해결되지 않는다. 이 문제는 심리적인 요소가 강하기 때문이다.

회송 시간에 대해 실행 결과가 빨리 나오면 그 실행을 가치가 없다고 느끼거나 회송 시간이 너무 길면 실행을 한 번 의뢰할 때마다 거의 노이로제 상태가 될지도 모른다.

최적의 회송 시가늘 단정하기는 작업마다 성격이 다르므로 불가능하다. 그래도 굳이 일반화해 보면 한 프로그램을 하루에 4~5회 이상 실행시킬 수 있다면 회송이 너무 바르다고 볼 수 있다. 2회 이하라면 프로그래머들은 불안해 하며 편법을 동원하게 된다. 하지만 작업 초반 단계는 최대한 자주 실행시켜 보는 게 좋으므로 하루 4회 실행을 보장하는 회사에서는 그렇지 못한 곳에 비해 프로그래머들이 사소한 잘못을 덜 걱정한다.

심리학적으로는 평균 시간보다 더 중요한 건 편차다. 어떤 날은 6회 회송하고 어떤 날은 0회라면 업무를 효과적으로 계획할 수 없기 때문이다.

우선순위의 문제도 감정을 자극하는 요인이 될 수 있다. 우선순위를 정하는 체계를 만들면 처음에는 저항감이 있지만 적용 효과가 분명하게 드러나면서 자리를 잡게 된다. 운영 통계를 잘 만들어서 공유하면 각자 그에 맞춰 자신에게 유리한 결과가 나오도록 프로그램을 조정할 수 있다. 자신의 프로그램이 높은 우선순위를 받을 수 있도록 수정하게 되고 실행 시간과 메모리 사용량을 더 정확하게 추정하려고 노력하게 된다.

프로그래머는 운영 환경이 어떻든 간에 결국에는 자신에게 유리한 방향으로 적응하게 된다. 운영 환경이 좋든 나쁘든 상관이 없다. 프로그램의 예상 실행 시간을 15분을 넘기지 않으면 동일하게 취급한다는 운영 규칙이 있을 경우, 프로그래머는 1분이면 실행하기 충분한 프로그램도 15분이라고 말하게 된다. 불필요한 규칙이나 제약을 만들면, 체제에 영향을 받는 사람들의 불만만 쌓일 뿐이다.

프로그래머는 자신의 업무에 영향을 미치는 모든 환경 요소에 적응한다. 그 요소를 시스템 관리자가 시스템의 일부로 취급하느냐 아니냐는 전혀 상관없다. 전문 프로그래머는 자신과 동료들이 시스템의 특성에 적응하는 걸 경험한다.

시스템이 효과적이고 능률적으로 사용되도록 하려면 그 사용법을 가장 쉬운 사용법으로 만드는 게 최선이다. 설계가 잘 된 운영체제라면 가장 많이 사용하는 작업제어 루틴 목록을 사용자에게 제공할 수 있을 것이다. 그렇다면 프로그래머들은 자연히 시스템을 잘 사용하게 된다.

#### 시분할(time-sharing) 대 배치(batch)

시분할 방식은 배치 방식보다 더 비효율적이기 때문에 시스템 제조사들이 제 주머니를 불리려는 수작일 뿐이라는 비판이 많았다.
반면에 시분할 방식이 효과가 있다고 믿거나 그렇게 믿고 싶어하는 사람도 많았다. 그래서 옹호하는 쪽과 반대하는 쪽 사이에 불가피한 논쟁이 시작됐다. 하지만 컴퓨터 분야의 혁신은 항상 그래왔듯이 이런 논쟁 중에는 실리학적인 논증은 찾아볼 수 없었다.

새크만이 시분할 시스템과 배치 시스템을 실험적으로 비교 평가한 연구 결과를 발표했는데 컴퓨터 관련 문제를 심리학적 방법이 도움이 되는지 의심하는 사람은 새크만의 책을 읽어봐야 한다.

시분할과 배치에 대한 논쟁을 통해 얻을 수 있는 교훈이 몇 가지 있다. 우선 연구자들마저 당연하게 받아들인 가정은 없었는지 따져봐야 한다. 새크만은 한 개인을 단위로 연구하는 것이 적절하다는 가정의 의문을 제기한 적이 없다. 당연하게도 모든 시분할 시스템의 하드웨어와 소프트웨어가 이 가정을 바탕으로 만들어져 있기 때문이다. 새크만의 실험은 학교 학생들을 대상으로 했으므로 이 가정은 더 당연해지는데 반대로 공군 사관학교에서 프로그램을 협력해서 작성했다면 규칙 위반이 된다.

새크만 처럼 뛰어난 연구자도 실험 결과를 잘못 해석할 때가 있다는 점에도 주목해야 한다. 배치 시스템에서 실행 횟수에 따른 문법 오류의 평균 개수를 그래프로 나타낸 후에 전통적인 오류 소멸 곡선이라고 해석했다. 문법 오류가 소멸된 건 맞지만 심리학에서 말하는 소멸과는 다른 의미가 있다. 이건 새크만이 프로그래머가 아니어서 배치 시스템을 사용하는 프로그래머는 컴파일이 되는 상태를 1차 목표로 하고, 그 후에 의미론적으로 정확한 코드를 만드는 작업을 하는데 한 문장을 수정한 후 바로 실행해 보는 식으로 작업한다.

새크만은 나쁜 시분할 시스템은 좋은 배치 시스템보다 못하고, 좋은 시분할 시스템은 나쁜 배치 시스템보다는 낫다는 결론을 내린다.

마지막으로 개인 간의 편차는 두 시스템을 비교하는 일에 노력을 들인 만큼 가치가 없일지도 모른다. 개인차의 문제에 대한 새크만의 글을 인용하자면 다음과 같다.

> ... 모든 실험 결과에서 성능에 주된 영향을 미친 요소는 시스템의 차이가 아니라 개인 간의 차이였다. (예외는 전혀 없었다)
> 시스템 효율성을 획기적으로 반전시킬 수 있는 돌파구는 개인별 차이의 성격과 구조 그리고 인간의 문제 해결 방식에 있다.
> ... 인간이 컴퓨터와 의사소통을 하면서 문제를 해결하는 방식에 대한 근본적인 이해가 있어야지만 그 목적을 효율적으로 달성할 수 있을 것이다.

#### 문서화

문서화는 프로그래밍에서 파마자유와 같은 존재다. 관리자는 문서화가 프로그래머에게 유용한 작업이라고 생각하지만, 프로그래머는 문서화를 싫어한다.

*파마자유: 20세기 초 미국에서 파마자유가 몇 가지 질병을 고치는 효능이 있다고 믿다 보니 부모들이 아이들에게 억지로 파마자유를 먹였다.

현재 수행되는 방식의 문서화는 별 쓸모없다는 걸 알리기는 쉽지 않다. 문서화는 잘할 때에만 가치고 있으며 그렇지 않다면 안 하느니만 못하다.

프로그래머가 좋은 문서를 만들도록 강제할 방법은 없다. 잘 하는척 하면서 쓸모없는 문서를 만드는 방법은 너무나 다양하므로 강제로 시켜봤자 종이 값도 안나오는 문서가 나올 가능성이 높다. 유일한 희망은 문서를 잘 쓰면 자신한테도 이득이라고 프로그래머를 납득시키는 방법뿐이다. 만약 쓸모 없다고 생각한다면, 문서화는 작업량을 최소화하는 방향으로 진행될 것이다.

우리는 어느 정도 적당함 목적을 하나 세우고 그에 부합하는 좋은 문서를 만드는 노력을 해야 한다. 문서가 어떤 목적에 맞지 않다면 그것을 위한 문서를 별도로 만들던지 아니면 없는 채로 지내야 한다.

어떤 프로그램에 대한 문서를 활용하려면 반드시 노력과 사전 지식이 어느 정도 필요하다. 대수학을 모르는 사람에게 미분 방정식의 해를 구하는 프로그램의 사용법을 이해할 수는 없으므로 그런 프로그램의 문서는 고등학교 교육을 받은 사람이 봤을 때 내용을 이해할 수 있을지 판단할 수 있을 정도로 작성해야 한다.

깊이는 문서화에서 중요한 개념 중 하나다. 일정 규모 이상의 시스템에서는 문서를 읽는 사람마다 얻으려 하는 정보의 상세 수준이 다르다. 깊이가 얕은 문서라도 읽는 사람이 읽을 수 있는지 여부를 판단할 만큼 충분히 상세해야 한다. 문서는 각 수준마다 한 단계 얕은 문서와 한 단계 깊은 문서에 대한 참조를 제시해야 한다. 문서의 깊이 그리고 어떤 사전지식이 필요한지도 알려줘야 한다.

읽는 사람도 이런 구조 정보를 이해하고 사용하는 데 시간이 필요하다. 그래서 물리적으로 존재하는 모든 문서에는 반드시 일종의 안내 정보가 있어야 한다.

책이라는 매체는 한계가 있다.

첫째, 책은 최신 내용을 담아서 전달하는데 적합할 정도로 유연한 매체가 아니다. 책이 쓰이고 독자에게 읽기기까지 최소 수 개월이 걸린다. 근본적으로 책이라는 매체의 변화 속도는 대규모 시스템의 프로그래밍 문서가 갱신되는 속도를 따라잡을 수 없다.

둘째, 시스템의 일반적인 개념이 있는 문서라면 책도 어느 정도 적절할 수 있지만 구체적인 기술 문제에 대한 해답을 전달하는 매체로는 적합하지 않다. 시스템이 복잡하면 책보다는 훨씬 능동적인 안내자가 필요하다. 그 역할에 가장 적합한 매체는 컴퓨터 단말기 화면일 것이다.

문서화에 드는 비용이 프로그래밍 비용의 일부라는 생각에 익숙하지 않다. 좋은 문서가 있으면 좋지만, 별도로 비용을 지불할 가치가 있다고 생각하지는 않는다.

문서화를 자동으로 하겠다는 계획도 있다. 자동으로 만들면 번거롭지 않고 비용도 들지 않을 수 있다고 생각할 수 있다.

*흐름도 추출 프로그램의 예 => 디버깅을 더 잘할 수 있게 만들어주는 도구는 될 수 있지만, 문서라고 보기 어렵다.

흐름도의 가치가 전반적으로 크지 않다고 해도 문서화 기법의 하나로 사용해야 할 이유로 여러 가지가 있다. 첫째, 흐름도는 컴퓨터가 자동으로 만들어 내므로 컴퓨터가 점점 강력해질수록 그 비용이 줄어든다. 둘째, 흐름도는 코드에서 직접 파생되기 때문에 코드와 문서가 불일치할 가능성이 전혀 없다는 장점이 있다. 코드와 문서의 불일치는 어떤 문서화 체계에서든 치명적인 문제가 된다.

문서는 코드 자체로부터 나와야 한다는 생각의 극단적인 형태로 클래러와 메이의 예에서 찾을 수 있다. 문서 보다는 코드를 직접 실험하면서 배우길 바란다는 사실을 밝혔다. 사실 이건 과거의 방식으로 돌아가는 것에 불과하다.

과거에는 사람과 컴퓨터의 의사소통이 쉽지 않았기 때문에 컴퓨터가 문서의 역할을 맡기에는 무리가 있었다. 컴퓨터를 문서로 더 많이 활용하려면 컴퓨터가 하는 말을 다양한 방식으로 이해해야 한다. 프로그램을 이해하고 디버깅하는 데 가장 큰 장애가 심리작 자세라면 사고 유연성을 줄 수 있는 기법을 디버깅과 문서화 도구로 고려해야 한다.

프로그램을 다양한 관점으로 바라보는 것의 효용성을 주제로 연구를 진행했고, 코드를 변수 이름 또는 글자 단위로 거꾸로 인쇄하여 어떤 일이 발생하는지 관찰할 수 있다.

> 18가지 방식 나열, 첫 번째 방법은 키워드를 굵은 글씨체로 표시하거나 밑줄을 긋는다이고, 두 번째는 키워가 아닌 코드를 굵은 글씨체로 표시하거나 밑줄을 긋는다이다.

이런 방식은 모두 프로그램의 물리적 의미를 바꾸는 방법이 아니라 심리적 의미를 바꾸는 것이다. 디버깅과 문서화의 문제를 컴퓨터가 해결하도록 노력하는 것이 아니라, 인간이 심리적 자세를 극복하고 내재된 막대한 심리적 자원을 이용할 수 있도록 컴퓨터가 돕게 만들려는 것이다.

이런 시도를 통해 문서화 문제가 해결된다면 좋을 수 있다. 그리고 유용한 방법이 하나 더 있는데 프로그래머가 프로그램 작성을 마친 후에 프로그램에 포함된 여러 요소인 변수나 분기 등에 대해 컴퓨터의 질문에 답을 하는 것이다. 컴퓨터가 프로그래머의 대답을 기록해 뒀다가 다른 사람이 그 프로그램을 요청하면 대답을 같이 보여주는 식이다. 그러면 다들 코드를 읽다가 궁금한 부분을 컴퓨터에게 물어볼 수 있고 문서를 뒤지는 수고를 컴퓨터가 덜어주는 것이다. 존재하는 정보는 언제나 단말기를 통해 얻기 때문에 잘못된 문서를 보고 헤맬 일이 없다.

여기에는 문서 내용이 제대로 입력되어 있어야 한다는 근본적인 문제가 남아 있다. 컴퓨터와 대화하면서 문서 작성을 하는 건 의욕이 생기는 일이긴 하지만 문장력이 떨어지는 사람이 갑자기 글을 잘 쓰게 되지는 않는다. 그래서 이걸 보완하기 위해 문서의 내용을 미리 검증하는 방법이 있다. 컴퓨터가 프로그래머의 답변 중에 일정 수준 이상의 점수를 받을 때만 저장하는 식이다.

더 훗날에 가능할 개념인데, 더 좋은 방법으로 모든 질문과 답변을 단일 저장소에 모으는 것이다. 문서의 내용을 항상 최신으로 유지하는 방법을 만든다면 이 방식은 프로그래머가 곧 문서이던 시절로 우리를 돌려놓을 것이다. 시스템 규모가 작을 때는 프로그램을 직접 만든 사람에게 물어보는 편이 더 쉽다. 하지만 프로그래머가 회사를 떠나면 쓸모 없는 방법이라서 그 전에 비자아적 프로그래밍을 실천하고 있어야 한다.

하지만 나중에는 직접 물어보는 방식은 한계점에 도달하게 된다. 또 프로그래머가 계속 회사에 남아 있다고 해도 사람의 기억은 영원하지 않다. 5년 전 작성한 프로그램의 어떤 위치에 어떤 내용이 있는지 기억하는 프로그래머는 드물다. 프로그래머 한 명이 작성하는 규모의 프로그램이라면 오래 사용하리라는 예상은 할 수 없으므로 문서화가 잘 되어 있다 한들 기존 프로그램을 버리고 새로 시작하는 편이 더 나은 시점은 오게 마련이다. 

따라서 프로그램을 어떻게 문서화할지 결정할 때에는 문서의 사용할 사람과 사용될 방식, 장소, 기간을 고려해야 한다.
한정된 장소에서만 문서를 사용하고, 프로그래머를 아는 사람들이 애초에 설계한 목적과 같은 종류의 일에만 사용하며, 1년에서 3년 정도만 쓸 예정이라면 문서를 정교하게 작성하는데 투입할 돈을 다른 프로젝트에 투입하는 편이 더 나을 것이다.

어떤 프로그램을 시장에 내놓을 상품으로 준비할 때 그 프로그램의 사용자는 문서에도 전문가 수준의 품질을 기대할 권리가 있다. 전문 프로그래머가 전문가 수준의 문서를 작성할 수 있다고 믿을 근거는 하나도 없다. 그래서 문서를 전문가 수준의 문서를 작성하려면 프로그래머가 직접 작성하는 것이 아니라 문서 전문가가 프로그래머의 도움을 받아 작성해야 한다.

좋은 프로그래머는 아무나 할 수 있는 것이 아니다. 배경 지식도 갖추고 훈련도 받아야만 할 수 있다. 이 사실은 프로그래머 스스로 잘 안다.
그런데 그 프로그래머들이 문서화 작업은 아무나 할 수 있다고 생각하는 건 무슨 이유일까, 문서화에 대해 심리학적으로 논해야 할 유일한 사항은 프로그래머들이 문서화는 누구나 잘 할 수 있거나 똑똑하지 않은 사람이 하는 업무라고 착각하고 있다는 사실이다.

#### 요약

시스템은 복잡하다. 하드웨어, 소프트웨어, 사람, 절차, 업무 부하, 사용자의 태도와 경험 들에 뚜렷한 경계선이 없다. 언어는 도구로, 도구는 문서로, 문서는 훈련으로 융합된다. 이 모든 것이 한데 섞여 시스템이 사용되는 사회적 풍토를 만든다.

우리에게 필요한 건 정답이 아니라 그것을 찾는 과정에서 얻는 경험이다.

#### 질문

##### 관리자에게

1. 디버깅 컴파일러 등의 디버깅 도구를 구매하라는 제안을 받아 본 적이 있는가? 구매하거나 거절하는 결정은 어떤 과정으로 내렸는가?

```
이미 회사에서 정한 기술 스택에 맞춰서 도구는 구매 했을텐데, 만약 추가 구매가 필요하고 회사쪽에 이유를 설명할 수 있다면
되도록 구매하는 쪽으로 추진한다.
```

2. 디버깅이 끝난 프로그램에 대해 프로그래머가 스스로 어느 정도의 자신감을 갖는지 물어보는가? 당신은 자신감을 어느 정도 갖게 되는가? 그런 결정을 내릴 때에는 어떤 요소들을 고려하는가?

```
설명에 확신을 갖는지를 보고 판단해 본다. 프로그래머가 그렇다고 하면 되도록 자신감을 가져도 좋다고 생각한다.
구현하려는 목표에 맞는 실행의 결과가 확인이 되면 그 외의 요소는 크게 중요하지는 않을 수도 있다.
```

3. 회사에서 사용하고 있는 시스템 성능의 평가 자료에 대해 설명해 보라. 관리자로 그것을 어떻게 사용하는가? 어떤 정보가 더 필요한가? 쓸모없는 정보는 어떤 것들인가?

```
아직 성능 평가 자료에 대해 크게 접해본 적이 없다. 현재 회사는 없다. 그러므로 사용하지 못했다.
만약 있다면 서비스 기획팀과 상의해서 성능상의 평가 지표를 만들어 줄 수는 있을 것 같다.
쓸모 없는 정보라고 하면 상식 수준을 기대하기 어려운 지표인데 객관성이 부족하고 주관적인 기준의 성능을 요구할 때이다.
```

4. 배치 시스템에서 이상적인 회송이란 어떤 것이라고 생각하는가? 온라인 시스템에서 이상적인 단말기 접근은 어떤 상황이라고 생각하는가? 이 문제들에 대해 당신의 프로그래머들은 어떻게 생각하는가?

```
이상적인 회송은 하드웨어 성능에 맞게 최적화된 컴파일러의 비동기적 실행 시간을 고려해
가장 빠른 프로그램 실행 결과를 보여주는 것이다.
온라인 시스템에서의 이상적인 단말기 접근은 상시 이용가능해야 하고 개인화된 정보를 바탕으로
언제든 사용하는데 문제가 없어야 하는 상황일 것이다.
프로그래머들도 당연히 그렇게 생각할 것이다.
```

5. 배치 시스템에 대해 특정 프로그래머에게 높은 우선순위를 주는가? 온라인 시스템은? 그 때문에 역효과가 생기지는 않았던가? 사람들의 감정을 상하게 하지 않고 우선순위를 차별하려면 어떻게 해야 한다고 생각하는가? 우선순위를 차별하여 얻는 이득보다 감정 대립 대문에 생기는 손해가 더 클 수도 있다고 생각하는가?

```
책이 쓰여진 시점의 질문인데, 현재 시점에서는 맞지 않는 내용들이라 답변을 해도 의미가 없어 보인다.
마지막에 감정 대립 때문에 생기는 손해가 꼭 이 상황의 질문 뿐 아니라 
거의 모든 상황에서 손해가 더 큰 상황이라고 생각할 수 있다.
```

6. 프로그래밍하기에는 배치와 온라인 시스템 중 어느 쪽이 더 좋은가?

```
사실 프로그래밍으로는 배치 시스템이 더 좋을 것이다.
이건 현시대의 상황이 아니라 그 시대의 상황을 고려해서 한 대답이다.
책에서도 설명되어 있지만 온라인 시스템은 사용자 별로 메인 시스템의 메모리와 CPU 자원 경합이 생기게 되므로 문제가 생길 여지가 있다.
```

7. 당신의 회사에서는 어떤 사람에게 문서 작성 업무를 맡기는가? 문서화 규칙이 프로그램의 종류에 따라 문서의 종류도 달리할 수 있을 정도로 충분히 유연한가? 문서화 작업에 대한 불만은 없는가? 만약 있다면, 원인은 무엇이며 어떻게 해소할 수 있으리라 생각하는가?

```
현재는 담당 프로그래머가 문서 작성 업무가 같이 부여된다.
문서화 규칙이 따로 있지는 않기 때문에 프로그램의 종류와 상관 없이 자유롭게 문서 작성을 할 수 있다.
문서 작업에 대한 불만은 없고 오히려 더 권장해서 해야 한다고 생각한다.
원인은 다들 담당하는 업무가 있고 직접 물어보는게 확실히 파악할 수 있는 문화이다 보니
나중에 규모가 커지게 될 때 문서화의 중요성에 대해 언급하고
규모가 커지고 공유 및 소통에 문제가 생길 때 쯤 문서화를 권장하는 것으로 해소할 수 있을 것으로 본다.
```

##### 프로그래머에게

1. 사소한 실수 하나가 엄청나게 큰 손해를 초래한 경험이 있는가? 어떤 디버깅 도구나 기법이 그 실수를 막을 수 있었을까? 그 실수 때문에 초래된 비용보다 그 디버깅 도구나 기법을 사용하는 비용이 더 컸을까?

```
보통 당연하게 생각하지만 체크를 잘 하지 않는 null 체크가 있고
그 문제로 인해 일정 지연과 초과 업무를 한 경험이 있다.
물론 디버깅을 해 보면 쉽게 파악할 수 있는 문제긴 하지만
내 프로그램에 문제가 있을리 없다는 심리적인 문제로 인해 그 실수를 조기에 막을 수는 없었다고 본다.
그런 관점에서 디버깅 도구나 기법을 사용하는 비용은 엄청나게 저렴하다고 볼 수 있다.
```

2. 프로그램 테스트 중에 너무 빠른 회송 때문에 영향을 받은 적이 있다면 좋은 경우였든 나쁜 경우였든 예를 들어 보라. 관리자를 기쁘게 하고 싶은 욕구나 프로그램 구조에 관한 지식, 다른 프로그램 또는 프로그래머들과의 상호작용 등 당신의 디버깅 전략에 영향을 끼쳤던 요소들을 나열해보라.

```
과거에는 회송 시간으로 인한 문제점이 있을 수 있지만, 현재는 그런 문제는 거의 없다.
예상하는 시간 보다 짧은 회송 시간이라고 한다면 오류가 발생하는 상황 정도일 것이다.

나의 경우 프로그래머들과의 상호작용이 디버깅을 하는데 있어서 많은 도움을 받은 적이 많다.
혼자 생각한대로의 문제 해결방법은 항상 정답이 아니고 
모르거나 확인해야 하는 지점들을 건너뛰고 다른 문제에만 몰두한다면 문제가 빠르게 해결되지는 않는다.
따라서 주의를 환기시킬 겸 다른 프로그래머들과 대화를 하다 보면 디버깅 하는데 좋은 힌트를 얻을 수 있다.
```

3. 배치 시스템에서 이상적인 회송이란 어떤 것이라고 생각하는가? 온라인 시스템에서 이상적인 단말기 접근은 어떤 상황이라고 생각하는가? 이 문제들에 대해 당신의 관리자는 어떻게 생각하는가?

```
현 시대에는 일어나지 않는 문제이긴 한데
그래도 이상적인 회송이라 하면 예측이 가능한 실행 시간과 그것을 보여주는 진행상황 표시 등이 있을 것이다.
현재는 1인 컴퓨터를 쓰는 시대이므로 온라인 단말기에 대한 질문에 대답하기가 어렵고
관리자 역시 컴퓨터 사용 말고 소프트웨어 개발 결과와 문제에 대한 공유와 해결 방안을 알고 싶어할 것이다.
```

4. 자신의 경험에 비추어, 인간이 시스템의 특징에 적응해 행동을 바꾸는 예를 들어 보라.

```
보통은 빌드 시간에서 이런 상황들이 생기는데
오래 걸리는 프로그램의 경우 빌드 시간은 수 분을 기다려야 하는 상황이 생긴다.
이런 과정을 반복하면 적응하게 되고 그 시간에 뭔가 다른 유용한 걸 해야 한다는 생각을 자연스럽게 하게 된다.
유용한 것: 담배 피우러 가기, 화장실 들렀다 오기, 잠깐 일어나서 스트레칭 하기, 다른 관심 있는 주제에 대한 웹 사이트 검색 등
```

5. 프로그래밍하기에는 배치와 온라인 시스템 중 어느 쪽이 더 좋은가?

```
관리자 관점도 그렇지만 프로그래머 관점에서도 배치 시스템이 더 좋다.
```

6. 프로그램을 보는 여러 관점 중에 운영체제나 컴파일러가 제공해 주었으면 하고 바라는 것은 무엇인가? 각각 구체적인 예를 들고, 그 관점이 어떻게 도움이 될지 설명해 보라.

```
현재는 운영체제와 컴파일러의 발전이 거의 완성단계에 있으며 발전 속도도 매우 빠르다.
그렇기 떄문에 운영체제나 컴파일러 레벨에서 바라는 점은 거의 없다고 본다.
```

7. 문서화 작업에 대해서 어떻게 생각하는가? 문서화 작업을 잘하는 사람들에 대해서 어떻게 생각하는가? 여러분이 문서화 작업을 잘 하려면 어떤 점들이 바뀌어야 할까?

```
문서화 작업은 반드시 필요하며, 잘 하는 것도 프로그래밍 능력 만큼 중요하다고 생각한다.
문서화를 잘 하려면 문서화를 해야 한다는 의식을 항상 가져야 하고
사람들과 상호작용을 통한 피드백 그리고 중요하다고 생각하는 내용을 공유하는 차원에서 문서화를 하면 좋으므로
우선은 문서화를 해야 한다는 의식을 갖는게 매우 중요하다고 볼 수 있다.
```

#### 참고 문헌

- Robert Rosenthal < On the Social Psychology of the Psychological Experiment > American Scientist, 1963년 6월

로젠탈은 실험 결과를 왜곡시키는, 특히 실험자가 특정 결과를 기대하기 때문에 생기는 요인들을 연구하는 분야의 선구자다.
이는 디버깅과 유사하므로 이 논문의 결과들을 그대로 자신의 작업 습관으로 옮길 수 있다.

- Emanuel Parzen < Modern Probability Theory and Its Applications > New York, Wiley, 1960년

일반적으로 프로그래머가 디버깅을 확률적인 작업으로 취급하면 이점이 않다. 이 책이 출발점이 될 것이다.

- G. M. Weinberg < Pl/1 Programming-A Manual of Style > New York, McGraw-Hill, 1970년

프로그램 테스트에서 올바른 언어와 프로그램의 구조의 중요성에 대해 언급한다.

- Edmund C. Berkeley < The Personality of the Interactive Programmed Computer > Computers and Automation, 1965년 12월, 42-46쪽

피상적이긴 하지만 시스템이 사용자에게 드러내는 성격에 대한 흥미로운 질문을 제기한다. 새크만이 언급한바 사용자가 시스템을 사용하는 능력은 시스템을 대하는 태도에 따라 달라진다. 그리고 사용자가 시스템에 익숙해질수록 점점 더 많이 인정하게 된다. 사용자가 시스템을 받아들이는 과정에서 시스템의 성격이 모종의 역할을 한다는 점에서 의심의 여지는 없다. 여러 다른 시스템의 성격이 사용자에게 어떻게 인식되고 있는지를 조사한다면 프고그래머들이 어떤 성격의 동료를 좋아하는지 알 수 있을 것이다.

- Harold Sackman < Man-Computer Problem Solving: Experimental Evaluation of Time-Sharing and Batch Processing > Princeton, N.N., Auerbach Publishers, 1970년

이 책은 이 쪽 분야의 현재까지 이루어진 연구들을 집대성한 책이며, 운영체제의 비교 연구를 계획하고 있는 사람이면 반드시 읽어야 할 책이다.

- G. H. Stange , The Initial Effects of the Installation of Two Remote Computer Access Systems >
- R. G. Salsbury < Ideal Turnarround-An Opinion Survey >
- William J. Heiss, Frederick Schwartz < Positional versus Keyword Coding >

출판되지 않은 수업과제 보고서이다. 굳이 이상하고 어려운 실험을 하지 않아도 이 분야에서 쓸모 있는 연구를 얼마든지 할 수 있음을 보여준다.

- Robert F. Rosin < Supervisory and Monitor Systems > Computing Surveys, 1, 1권 (1969년 3월)

로진은 운영체제에 대한 일반적인 개괄과 중요한 논점들을 10여 쪽으로 정리해 냈다. 오늘날 시스템에 있는 심리학적 틈들을 파악하면 미래의 운영체제가 어떤 모습일지 예측 가능할 수 있다.

- Ralph L. London < Bibliography on Proving the Correctness of Computer Programs > Machine Intelligence, 5, New York, American Elsevier, 1970년

디버깅을 하는 사람은 모든 컴퓨터가 어떤 프로그램이 맞았는지 틀렸는지 스스로 판단해서 알려줄 날을 꿈꾼다. 아직까지는 해결책이 없어서 디버깅에 적용할 수 있는 방법이 없다. 여기의 관련 연구 몇 가지는 디버깅 하는 사람들이 읽어볼 만하다.

- G. M. Weinberg, G. K. Gresset < An Experiment in Automatic Verification of Programs > Communications of the ACM, 6, 10 (1963년 10월), 610-613쪽.

컴파일러의 오류를 검출하는 속성과 사용 환경 사이에 어떤 연관이 있는지를 보이려는 연구를 설명한 글이다.
현실에서 오류 검출의 성능을 향상시키기 위한 몇 가지 아이디어를 제시했다.

- E. T. Irons < An Error Correcting Parse Algorithm > Communications of the ACM, 6, 11 (1963년 11월), 6690673쪽
- Jacques LaFrance < Optimization of Error Recovery in Syntax-Directed Parsing Algorithms > ACM SIGPLAN Notices, 5, 12권 (1970년 12월), 2-17쪽.

아이언스의 논문에서 컴파일러의 문법 오류를 자동 교정하는 기능을 최초로 다뤘다. 라프랑스의 논문이 최근 자료 중 하나다.
자동 교정은 오류를 대체할 여러 후보 중 하나를 결정해야 하는데, 근접성이라는 개념이 필요하다.

- W. Teitelman < PILOT: A Step Toward Man-Computer Symbiosis > (Doctoral Dissertation, M.I.T.,) Cambridge, mass., 1966년 6월.

PILOT 시스템은 LISP 프로그래머들의 프로그램 수정 작업을 돕기 위해 개발된 도구로, LISP으로 작성됐다. 이쪽 방향으로 연구를 할 때 유용한 자료이다.

- Thomas G. Stockham Jr. < Some Methods of Graphical Debugging > Proceedings of the IBM Scientific Computing Sysmposium on Man-Machine Communication, 1966년

스톡햄은 동적인 디버깅을 위해 CRT 장비가 사용된 역사를 고찰한다. 1958년 부터 이뤄진 초기 실험들이 널리 채택되지 않음을 안타까워하는데 그 원인이 여러 가지 기술적 그리고 경제적 이유라고 밝힌다.

- Harlan D. Mills < Syntax-Directed Documentation for PL360 > Communications of the ACM, 13, 4 (1970년 4월)

밀스는 프로그램을 작성하는 과정에서 문서화를 위한 자료를 축적하고 나중에 컴퓨터로 처리해서 문서를 만들어 내는 꽤 원대한 계획을 제시했다.
정말 사용할 수 있을 만한 문서가 나오는지 필요한 종류의 문서인지 시험해볼 가치는 있다.

- M. Klerer, J. May < Reference Manual > 개정판, Dobbs Ferry, N.Y., Columbia University Hudson Labs, 1965년 7월.

두 쪽 자리 문서는 Klerer-May 시스템의 사용자가 시스템 탐험을 시작할 때 받는 유일한 지도다. 이 문서와 한 쪽짜리 부록은 사멧의 < Programming Languages > 에 실려 있다.

- H. D. Leeds, G. M. Weinberg < Computer Programming Fundamentals/Based on the IBM System/360 > New York, McGraw-Hill, 1970년.

프로그램의 문서화에 대해 광범위한 내용이 있다. 흐름도에 대한 내용도 한 챕터를 할애했고, 짧은 문서(writeup)들에 대해서도 한 챕터를 할애했으며 문서화의 다른 여러 측면도 책 전체에 걸쳐 다룬다.

#### 13장에 보태는 글: 그 외의 프로그래밍 도구들

지금 다시 이 책을 쓴다면 프로그래밍 언어는 두 단락으로 줄이고, 13장의 내용을 5권, 10권으로 늘릴 것이다.

언어를 다른 도구들보타 특히 중시하는 편견은 오랫동안 지속됐고, 지금도 여전하다. 현재 테스트 도구는 넘쳐나고 과거에는 상상도 하지 못한 도구도 있다. 그런데 실제 이런 도구들이 현업에서 사용되는 예는 많지 않다. 따라서 코드의 품질이 저하될 위험은 여전하다. 테스트 전문가의 지위가 제대로 인정받지 못하는 상황도 그대로여서 이를 해결하려면 테스트 도구가 아니라 관리 방법을 개선해야 한다.

PC가 등장하면서 프로그래밍 언어와 운영 환경 사이의 경계가 희미해졌다. 25년 전에 논했던 논점들이 지금은 심리학적인 문제로 중요하지 않게 됐다. 단지 편리성의 문제가 됐을 뿐이다.

소프트웨어 개발자에게 완전히 통합된 개발/테스트/유지보수 환경을 제공하려면 아직도 멀었다. 우리는 더 많은 통합을 이룰 기회가 어디에 있는지조차 모른다는 생각이 든다. 통합이 계속 되면 현재 핵심이라 생각되는 프로그래밍 작업은 미래에는 그렇게 중요하지는 않게 될 것이다. 프로그래밍의 역사는 과거에 핵심적이었지만 부차적인 것으로 전환되는 과정을 통해 발전해 왔다.

천공카드로 프로그래밍 했던 방식이 그립지는 않다. 그런데 기다려야 했던 시간 그리고 업무에 대해 숙고할 여유를 줬던 그 시간은 어느 정도 그립다. 프로그래밍이 어떻게 변하더라도 아무 생각 없이 있기보다는 끊임없이 고민하고 생각하는 편이 여전히 더 가치가 있으리라고 확신한다.

문서화가 지닌 다른 가치는 모두 차치하더라도, 자신이 미래에 어느 방향으로 가게 될지를 예측하는 데에 과거에 어디 있었는지를 기억하는 것은 도움이 된다.

소프트웨어 문서화는 25년 간 발전된 점이 별로 없다. 코드 포맷터, 온라인 도움말, 하이퍼텍스트 같은 멋진 도구들이 생겨나긴 했지만 제일 중요한 내용의 수준을 높여 주는 도구는 여전히 존재하지 않는다. 정보에 더 쉽게 접근할 수 있도록 기술이 발전해도 자신이 원하는 정보가 아니라면 별 의미가 없다. 인터넷을 통해 가끔 그런 경험을 한다.

문서 내용에 가장 큰 영향을 준 변화는 소프트웨어 산업에서 문서화가 독립된 작업으로 다뤄진 것이다. 이제 상용 소프트웨어 회사는 개발자에게 문서 작성을 요구하지 않는다. 소프트웨어 사용자가 볼 문서는 더욱 그렇다.