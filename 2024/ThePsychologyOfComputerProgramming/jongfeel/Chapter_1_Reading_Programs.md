### 1장 프로그램 읽기

```
논의주제)
프로그램 읽기를 통해 인간 행위를 밝힐 수 있다는 점에서 재미있는 접근이라는 생각을 했습니다.
저는 코드 리뷰를 할 때 읽는 것 자체는 자세하게 읽는 편은 아닌 것 같습니다. 다만 이 코드를 생성하게 된 맥락이나 의도등을 파악하는 걸 더 즐겨 하는 것 같습니다.

그래서 다른 분들은 코드 리뷰를 할 때 그런 맥락과 의도가 궁금해서 코드 리뷰를 요청한 사람과 실제 대화를 해보고 알아낸 적이 있는지, 그리고 그게 의미가 있었는지 얘기해 보면 좋겠습니다.
```

COBOL이 프로그래밍의 희망이었던 시절 경영자들이 프로그램을 읽을 수 있는 가능성에 대해 얘기를 했다.
하지만 경영자들의 주머니를 노린 것에 불과했고 아무도 프로그램을 읽게 될 수 있을거라 믿지 않는다.
왜냐하면 프로그래머 조차도 프로그램을 읽지 않는데 왜 경영자가 프로그램을 읽을 수 있어야 할까?

프로그램을 읽는 것은 프로그래밍을 배운다는 의미에서 나쁜 일은 아니다.

프로그래밍은 작문의 일종이다. 직접 써보는 것도 방법이지만 읽어 보는 것도 방법이다.
프로그래머들은 실행 결과를 기다리는 동안 다른 사람이 작성한 프로그램을 읽으며 시간을 보냈다.

다른 사람이 작성한 프로그램을 감상하는 것 보다 거대한 컴퓨터와 씨름하는 것이 더 흥분되는 일인건 분면한데
프로그래밍 능력을 키우는 데 더 도움이 되는 것일까? 생각해 봐야 한다.

다른 사람의 프로그램을 읽어서 뭔가 얻을 수도 있다. 나쁜 예제라면 반면 교사로 삼으면 된다.
프로그래밍이 어떤 과정으로 이루어지는가를 밝히고 싶다면, 프로그램을 읽어서 무엇을 배울 수 있는지를 아는 것이 그 출발점이 될 것이다.

#### 예제

PL/1 코드 예제: 1000번의 루프문을 10번씩 돌려 합을 구하는 프로그램

프로그램의 각 부분의 발단으로 구성된 개념적인 프레임워크를 토대로 프로그램을 읽어야 한다.
즉, 코드를 한 줄 만날 때마다 이 코드가 왜 여기 있을까?를 생각하는 것이다.

#### 기계의 한계

예제 코드는 숫자 데이터 10000개를 읽어서 그 총합을 구하는 프로그램인데 1000개씩 묶어 10번 읽도록 되어 있다.
가용 메모리의 양이 40000 바이트가 안됐기 때문에 프로그래머는 데이터를 분할하고 반복문을 사용할 수 밖에 없었다. 

프로그래머들은 기계의 한계를 인식하기 보다는 무의식중에 엄연한 사실로 인정해버리는 경향이 있다.
그럴수록 프로그래밍의 어려움은 더 커지며, 프로그래머를 골치 아프게 만드는 기계의 한계를 기계 설계자들이 인지할 가능성은 더 적어진다.

기계의 한계가 드러나는 다른 부분은 보조 기억장치인데, 필요한 코드의 양이 훨씬 늘어난다.
장치마다 특성이 있기 때문에 경우의 수를 처리하는 일은 프로그래머의 몫이 된다.

#### 언어의 한계

기계어 보다 높은 수준의 언어를 사용할 때 생기는 문제점 중 하나는 하드웨어의 특정 기능을 사용할 수 없다는 점이다.
FORTRAN 언어는 파일의 끝을 처리하는 기능을 제공하지 않으므로 프로그래머가 임의로 정한 특수 문자를 파일의 끝으로 정하는 방식을 사용한다.
이건 언어의 한계가 프로그램과 데이터 모두에 영향을 주는 예이다.

PL/1은 배열 내의 값을 합산하는 SUM 함수를 제공하는데 SUM은 당시에 산술(arithmetic) 함수가 아는 수학(mathmatical) 함수였다. 함수 내부에서 데이터를 부동소수점수로 간주하고 필요하면 입력값을 부동소수점으로 변환한다.
그러면 고정 자리수의 10진수의 경우 부동소수점으로 변환하면서 정밀도에 손실이 생기게 된다.
SUM 함수를 이용해 은행 계좌의 잔고를 계산하면 몇 원씩 모자란 결과가 나왔고 부정확한 값으로 고생했었다.
그래서 나중에 SUM의 정의가 산술 함수로 바뀌게 되었다.

제약에 대해서는 FORTRAN에서
DO 반복문 역순 실행 못함 - 반복 제어를 증분이나 경계값으로 표현할 수 없음
배열 첨자는 반드시 1부터 시작
배열 첨자로 수식을 사용할 때는 몇 가지 정해진 형식만 가능

그런데 이런 제약은 사라지기 전까지 제약으로 인식되지 못할 수도 있다.
마치 교외에 나가서야 도시의 공기가 혼탁했다는 사실을 알게 되는 것처럼.

따라서 나중에 새로운 프로그래밍 언어가 등장하면
현재는 인식 못해도 PL/1의 한계가 드러날 수 있다고 보는 것이 옳다.
이건 심리학적인 문제이다.

#### 프로그래머의 한계

프로그래머 자신에 대한 지식이나 이해가 부족함으로 인해 얼마나 많은 코드를 쓸데없이 추가하느냐를 볼 필요가 있다.
PL/1은 배열 이름만 있어도 배열의 데이터를 읽어올 수 있다.
이 기능을 프로그래머가 알고 있다면 예제 코드는 더 간결해 질 수 있다.

물론 프로그래머의 한계는 언어에 대한 지식 부족 외에도 여러 종류가 있다

#### 역사의 흔적

.SUM 함수가 산술 함수로 바뀐 뒤에 예제 프로그램 같은 프로그램이 존재할 이유는 없게 된다.
그러나 SUM 함수를 바로 반영할 프로그래머는 얼마나 있을까?
몇 년 후에 신입 프로그래머가 그런 프로그램을 발견하고 수정하면서 원작자 보다 PL/1을 더 많이 안다고 생각할 수도 있고 원작자를 깔볼 수도 있다.
이런 상황은 프로그래머 인생에서 언젠가는 겪게 될 또 다른 심리학적 현실이다.

프로그램의 규모가 클수록 과거의 선택이 더 큰 영향을 끼친다. 
프로그램 구조 자체도 작성한 프로그래밍 그룹의 규모나 인원 구성에 따라 결정될 수 있다.
프로그래밍 그룹의 사회적 구조는 프로그래밍 심리학을 연구하는 사람들의 주된 관심사이다.

#### 명세

여러가지 한계를 극복하기 위한 코드는 무시하고 실질적인 작업을 하는 핵심 코드만으로 그 프로그램의 명세를 밝힐 수 있다고 생각하는 것은 오산이다. 작성된 명세만 보고 효율적인 코드를 만들어 내기는 어렵기 때문이다. 더 큰 원인은 문제를 해결하려고 프로그래밍을 시작하기 전까지는 그 문제 자체를 정확히 이해할 수 없다는 데 있다.

명세는 프로그램, 프로그래머와 함께 진화한다. 프로그램을 작성하는 것은 일종의 학습이다. 이 과정은 특정 기계, 특정 프로그래밍 언어, 특정 작업 환경에서 일하는 특정 프로그래머 또는 팀에서 코드가 하는 일까지도 좌지우지 하는 일련의 역사적인 사건들로 이뤄진 문맥 내에서 일어난다.

#### 요약

어떤 프로그램이 현재의 모습을 갖게 된 데에는 다 이유가 있다. 코드를 세심히 읽기보다는 그저 훑기만 하는데 그치기 때문에 모든 이유를 알 수는 없다.
최종 산출물에 포함된 코드에는 각각 나름의 이유가 있고, 그 이유들에는 심리적인 면이 있다.
그러므로 프로그래밍을 인간 행위로 연구하면 많은 혹은 예상하지 못한 소득을 얻게 될 것이다.

#### 질문

##### 관리자에게

1. 담당 프로그래머가 작성한 프로그램을 읽을 능력이 있는가? 구세대 프로그래밍 언어 까지만 가능하지는 않은가? 읽을 능력이 있다면 프로그램을 실제로 읽어 보는가? 아니라면 이유는 무엇인가?

```
어떤 관리자인가에 따라 다를 것이라고 보는데 읽을 능력은 있어야 한다고 본다.
구세대 프로그래밍 언어 보다는 관리자 자신이 사용했던 언어라고 보는 게 정확할 것 같다.
읽을 능력이 있어도 읽어 볼 시간이 없다고 보는 게 맞다. 만약 코드 리뷰 승인을 해야 한다고 하는 절차를 꼭 밟아야 하는 약속 정도를 하지 않는 이상
```

2-1. 고위 관리자라면 일선 관리자들에게 프로그래머가 작성한 프로그램을 읽을 능력이 있는지 확신하는가? 프로그래머들에게 직접 물어보고 질문에 다시 답해보자. 

```
코드 리뷰 프로세스가 있다면 읽을 능력이 있고 읽기는 할 것이다. 내 관점에서는 그 일선 관리자가 그 프로젝트에 얼마나 많이 참여하고 시간을 보내는지에 따라 다를 것이다. 만약 다른 프로젝트 관리를 한다거나 외근, 미팅 등 다른 업무가 많다면 프로그램을 읽을 능력이 없을 확률이 높을 것이다.
```

2-2. 일선 관리자들이 프로그램을 읽는 능력이 있다고 해도 실제로 프로그램을 읽어 보는 지 확인하라. 조사에 따르면 관리자 열에 아홉은 이런저런 이유로 프로그램을 읽지 않는다. 어떤 프로그래머가 얼마나 유능하고 일을 잘 하고 있는지 관리자가 판단할 수 있다고 생각하는가?

```
보통 관리자가 일을 잘한다고 판단하는 건 정해진 기간 내에 일을 끝내는지 여부이지 프로그래밍 능력으로 판단하거나 하지 않는다. 그리고 일을 제때에 끝내는 모습을 자주 보여주면 일을 잘 한다고 판단할 것이다. 거기에는 프로그래밍을 잘 할 것이라는 추측성 근거를 통해 믿을 것이라 본다.
그리고 프로그램을 읽지 않는 건 90% 까지는 아니더라도 읽지 않을 확률은 50%는 넘을 것이라 본다.
```

##### 프로그래머에게 

1. 마지막으로 다른 사람이 작성한 프로그램을 읽어 본 적이 언제였는가? 왜 그 사이에는 그렇게 하지 않았는가? 마지막으로 다른 사람이 당신의 프로그램을 읽고 당신과 함께 토론한 것은 언제였는가? 그는 상사였는가?

```
어느 회사에서 어떤 일을 하는지에 따라 다르고 어느 시점에  이 책을 읽고 대답하느냐에 따라 답변 내용이 달라질 것으로 보는데
우선은 코드 리뷰 프로세스가 있다는 가정하에는 지난 평일 출근했던 날이다. 즉 거의 매일이라고 보면 된다.
토론을 한 건 지난 주 목요일 쯤으로 상사는 아니고 팀원이었는데, 프로그램의 동작이 계속 일관되지 않고 수정이 계속되는 이유에 대해 코드에 어떤 부분이라고 얘기를 나눈 적이 있었다.
```

2. 프로그램 라이브러리나 동료에게서 프로그램을 하나 구하라. 그리고 코드 한 줄 한 줄이 그렇게 작성된 이유를 밝혀보라, 이 연습을 하면서 당신이 배운 것은 무엇인가?

```
다음 주에 해당 issue 글 코멘트를 통해 추가 답변을 진행해 볼 예정이다.
```

3. 한 달 이상 전에 당신이 직접 작성했던 프로그램을 대상으로 2번과 같은 연습을 하라. 이 연습으로 당신은 무엇을 배웠는가?

```
이것도 팀원의 양해를 구하고 해본 뒤에 추가 답변을 진행할 예정이다.
```

#### 참고문헌

- Werner Bucholz 편저 < Planning a Computer System : Project Stretch > New York, McGraw-Hill, 1962

컴퓨터 하드웨어가 지금과 같은 모습이 되었는지를 설명한 글.
프로그래밍에 기계의 한계 문제에 대한 통찰을 제공한다.
https://amturing.acm.org/Buchholz_102636426.pdf

- < PL/1 Language Log > IBM 내부 문건

PL/1이 현재 모습이 되기까지 있었던 수많은 논쟁과 그 결과가 반영된 변화 등을 정리한 총체적인 기록이다.

- Gerald M. Weinberg < PL/1 Programming : A Manual of Sytle > New York, McGraw-Hill, 1970

프로그램이 어떻게 현재와 같은 모습이 되었는지에 대한 내용

- Fred Gruenberger < Fourth Generation Computers : User Requirements and Transition > Englewood Cliffs, N.J., Prentice-Hall, 1970

Murray Laver는 설계자와 판매사원, 제조사가 고객보다 더 큰 영향력을 지니게 된 이유를 밝힌다.
Jacques Bouvvard는 소프트웨어 차원의 시스템 설계에서 사용자가 좀 더 중시되어야 할 필요성에 대해 논한다.

#### 1장에 보태는 글: 프로그램 읽기

프로그램 읽기는 여전히 프로그래밍의 과정을 이해하는 중요한 열쇠다.
25년이라는 시간이 있었으므로 코드에 반영된 역사의 흔적이 더 늘어났다. 그 흔적을 인지하고 코드가 현재 모습이 된 이유를 설명하는 자료를 얻을 수 있다면 프로그래밍을 인간 행위로 연구하는 데는 좋은 재료가 될 것이다.
코드를 아무리 많이 읽어도 어떤 코드가 좋고 나쁜지를 판단할 능력이 없다면 별 도움이 안된다. 이건 25년 전이나 지금이나 변하지 않았다.

프로그래머들은 자신의 코드를 다른 사람에게 검토해 달라고 요청하거나 다른 사람의 코드를 보며 자신의 능력을 키우는 것에는 인색한데
이상한 점은 정말 유능한 프로그래머는 이런 일을 더 중요시 한다는 점이다.
그래서 부익부 빈익빈 현상이 발생한다. 