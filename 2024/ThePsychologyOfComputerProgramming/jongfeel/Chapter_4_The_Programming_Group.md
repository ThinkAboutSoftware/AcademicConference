### 4장 프로그래밍 그룹

```
논의 주제)
비자아적 프로그래밍이 유익하다는 주장이 있는데, 저도 적극적으로 동의하는 바입니다.
특히 코드를 잘못 작성해서 일어나는 에러나 버그가 나면
내 코드는 오류가 날리가 없어서 컴퓨터에 문제가 있다는 생각은 안하는 것 같습니다.

그러면 반대로 강한 자아를 가진 프로그래머의 사례가 있다면 어떤 일이었는지 얘기해 보면 좋겠습니다.
저는 거의 대부분 컴퓨터가 주인을 닮아서 그런 거다라는 농담을 자주 하곤 하는데 어디까지나 농담이고
자기가 작성한 코드에 강한 애착과 자아를 가지는 분이 있을까요?
```

우리가 사회심리학에서 가장 먼저 배워야 할 것은 공식 그룹과 비공식 그룹의 차이점이다.

#### 공식 조직과 비공식 조직

사람 사이의 상호관계는 좁지도 단선적이지도 않다. 또 조직도에 나와 있는 방향대로만 이뤄지지도 않는다. 공식적인 구조만이 어떤 조직 내의 유일한 구조라는 생각은 수많은 실수들을 불러왔다.

비공식 구조는 항상 기존 공식 구조의 기능을 정정하고 보완하는 방향으로 자라난다. 상위 결정권자가 현명하다면 그런 개혁적인 비공식 구조는 공식 구조가 되기도 한다.

예1) 엔지니어링 컨설팅 회사의 전산실, 작업 완료 시점을 알기 위해 여비서에게 전화로 물어보다, 30분 간격으로 자동 응답 서비스를 하게 된 경우 => 전산실 관리부에서는 비공식 서비스의 기능을 인지하고 대처함
예2) 대학 전산실의 자판기 위치, 프로그래머들이 종종 자판기 앞에 모여 프로그램에 대한 대화를 하고 결과를 공유했으므로 위치를 옮기면서 부터 컨설팅 서비스를 이용하지 않아도 되는 문제개 해결 => 자판기가 없어지자 비공식적으로 컨설팅 서비스에 부하가 생기게 되는데 관리자는 이를 인지하지 못함

이 일화의 요점은 비공식 조직은 항상 존재하고 그것을 깊이 이해하지 않은 상태에서 바꿔버리면 위험하다는 것이다. 그러면 원활하게 돌아가던 시스템을 교란시기는 일이 되기 때문이다. 이런 교란은 물리적인 배치를 변경하면서 발생하므로 관계를 살펴볼 필요가 있다.

#### 물리적 환경과 사회적 조직

관심을 가져야 하는 부분은 작업 공간 배치가 사회적인 상호작용에 미치는 영향이다. 그 상호작용이 다시 작업 결과에 영향을 주기 때문이다.

예) 수동 조작 승강기 기사가 프로그래머 사무실과 전산실이 있는 위치를 알려주는 역할을 했는데, 자동 승강기로 바꾸면서 프로그래머가 어디 있는지 찾으러 다니는데 드는 손실이 증명됨

1956년 경에는 전산실의 대기실에서 디버깅 시간 15분을 기다리며 줄을 서 있었고 프로그래머 끼리 얘기를 하면서 놀라울 정도로 유용한 정보들이 전달 됐다. 운영체제가 등장하면서 이런 사회적 구조가 사라졌다. 개인에게 결과를 통보해 주는 서비스가 생기자 프로그래머가 고립되서 이런 상호작용을 할 수 없게 되어 버렸다. 그리고 원격 작업도 가능하게 되었으므로 고립이 더 심해질 것이다.

#### 프로그램의 오류와 프로그래머의 자아

대부분의 프로그래머는 고정된 장소에서 다른 사람의 방해를 받지 않고 혼자 일하는 편이 좋다고 할텐데
그런 생각이 프로그래밍 능력을 향상시키는데 가장 무서운 장벽이다.

개인의 성격 유형은 고분고분한지, 공격적인지, 고립적인지로 분류해볼 수 있는데
모든 사람에게 이 세 가지 성향이 모두 존재하지만 대부분의 사람은 그 중 한 성향이 두드러지게 발현된다.

프로그래머는 대다수 고립적인 성향이 강하다. 개인의 선택 문제도 있지만 그런 성향인 프로그래머를 고용하는 방침 때문이기도 하다. 프로그래밍 업무 상당 부분은 홀론 창조적으로 해야 하는 것이기에 그런 프로그래머를 선택하는 편이 어느 정도는 좋다.

하지만 고립성은 종종 지나쳐서 자신의 프로그램에 애착을 두게 된다. 화가나 작가, 건축가 역시 자신의 작품을 자신의 것으로 여기는데 프로그램도 동일하지 않을까? 하는 생각을 해볼 수 있다. 프로그램을 사람들이 읽는다는 조건에서는 그렇다. 사람들은 프로그램을 읽지 않는다. 어떤 프로그래머를 흠모한다고 해서 그 프로그래머의 작품을 모방하게 되지는 않는다. 단지 매너리즘을 부추길 뿐이다. 예술계에서 흔히 나타나는 현상으로 어떤 화가처럼 보이는 방법은 알고 있지만 그 화가처럼 그리는 방법을 아는 사람은 거의 없다.

누구의 것인지 중시하는 프로그래밍에서 나타나는 실질적인 문제점에는 또 다른 원인이 있다. 그림, 소설, 건물이 열등하다는 생각은 취향의 문제이지만 어떤 프로그램이 열등하다는 생각은 객관적인 증명 또는 반증이 가능하다. (물론 좋은 프로그램을 정의하기가 어렵다는 사실은 차차하고서라도)
프로그램은 컴퓨터에서 실행해서 나오는 결과를 볼 수 있다. 화가는 경우에 따라 비판을 수용하지 않을 수 있지만 프로그래머가컴퓨터의 판단을 무시할 수 있을 것인가?

자기 프로그램에 대한 프로그래머의 애착은 자화상에 심각한 손상을 남길 수 있다. 컴퓨터가 자신의 프로그램에 오류가 있다는 결과를 내면 결함이 자신에게 있다는 가혹한 평가를 내릴 수 있다.

사회심리학자인 페스딩거(Festinger)를 필두로 인지부조화(cognitive dissonance)라는 심리 현상의 실체를 규명하고자 수많은 실험이 행해졌고 전형적인 인지부조화 실험은 다음과 같다.

> 피험자들에게 자신이 강하게 부정하는 논제를 긍정하는 방향으로 논증하는 글을 쓰도록 한다. 피험자들을 두 그룹으로 나누고 한 그룹은 답례로 1달러를 다른 그룹에는 20달러는 주기로 한다. 실험 후에 피험자들의 의견을 다시 조사한다. 상식적으로 20달러를 받는 사람들이 자신의 의견을 바꿀 가능성이 더 높아 보인다.  그러나 인지부조화 이론에 따르면 1달러를 받는 사람들이 더 많이 자신의 의견을 바꿀 것이고 이는 여러 실험을 통해서 사실로 확인됐다.

자신이 믿지 않는 것을 주장하는 행동을 위선이라 하는데 위선은 사회적으로 좋게 평가되지 않는다. 따라서 부조화 상황이 발생한다. 이론에 따르면 사람은 이런 부조화 상태에서 매우 불편하고 불안감을 느끼기에 어떤 식으로든 빨리 해소하고 싶어 한다. 부조화를 해소하려면 그것을 이루는 요소 중 하나 이상을 포기해야 하는데 일반적으로 개인의 자화상만은 절대로 포기하지 않는다. 자화상은 기적적인 과정을 통해 살아남는다.

20달러를 받은 사람들은 자신의 부조화 상황을 쉽게 해결한다. "물론 내가 쓴 글의 내용을 정말로 믿는 건 아냐, 단지 돈을 벌려고 했을 뿐이야". 돈을 받기 위해 자신의 의견에 반하는 글을 쓰는 일도 그다지 바람직하지 않지만, 자신의 믿음을 스스로의심하게 되는 것보다는 훨씸 나삳.

1달러를 받는 사람들은 사정이 다르다. 1달러는 그렇게 의미있는 액수가 아니기 때문에 돈을 위해 글을 썼다는 위안도 소용없다. 그래서 다른 방법으로 부조화를 해소해야 하고 쉬운 방법으로 자신이 반대하는 의견에도 어느 정도 타당성이 있음을 인정하는 것이다. 그래서 그 글을 쓴 건위선이 아니고 양쪽 의견 모두 살려서 공평하고 정직한 마음을 기르려는 훈련이었다고 주장한다.

인지부조화 이론을 적용하면 자동차 구입과 같이 큰 돈을 지출한 후의 심리를 예측할 수 있다. 포드 차를 구입한 사람에게 자동차 광고 여러개를 보라고 하면 거의 포드 광고만 보려고 한다. 이는 부조화에 빠질 가능성이 있는 경우 그 원인이 될 수 있는 정보를 일부러 피하는 예다. 

이제 인지부조화와 프로그래머가 겪는 모순에 어떤 관계가 있는지 확인할 수 있다. 자신의 프로그램이 자아의 외연이라고 진심으로 믿는 프로그래머는 프로그램에 있는 오류를 찾아내려 하지 않을 것이다. 오히려 그 프로그램의 정확성을 증명하려 노력할 것이다. 모든 프로그래머는 이런 부조화에 매우 익숙하다.

예로 프로그램이 동작하지 않는 상황에 그 상황을 숨길 수 없다면
"전공기 기사가 실수를 했어"
"컴퓨터 관리자가 내 카드드르이 순서를 엉망으로 만들어 놨어"
등의 변명을 하지만
"내가 또 바보짓 했어"
라는 말은 절대 하지 않는다.

사람의 눈은 보고 싶지 않은 것을 보지 않는 데 거의 무한한 재능을 지녔다.
프로그래머 자신의 눈에만 의존하는 디버깅을 한다면, 다른 사람에게는 대번 눈에 띄는 심각한 오류도 모르고 지나갈 수 있다.
따라서 좋은 프로그램을 만들기 위해서는 확실한 반증이 있음에도 자신의 프로그램은 정확하다고 믿으려는 완전히 정상적인 사람의 성향에 대해 뭔가 조치를 취해야 한다.

#### 비자아적 프로그래밍

프로그래밍에서 자아 문제는 어떻게 대처할 수 있는가
관리자는 오류를 더 적극적으로 찾아보라고 할 테지만 이건 개인적인 심판으로 받아들일 수 있으며 심리학 지식을 거스르는 방법이다.

직접적은 요구(공격)는 해결책이 되지 않는다. 그러면 빠져나갈 구멍(방어)을 찾게 되고 그런 자세는 우리가 가지면 안되기 때문이다. 자아의 문제는 사회적 환경과 더불어 프로그래머들의 가치 체계를 재구성함으로 극복해야 한다.

폰 노이만(John von Neumann)은 자신의 작업을 스스로 검토하는 것이 적절하지 않다는 걸 제일 처음 인식한 프로그래머 중 한명이다. 자신은 형편없는 프로그래머라고 생각했고, 프로그램을 사람들에게 보여주면서 오류나 서툰 부분을 알려달라고 끊임없이 부탁했다. 현재 폰 노이만은 모든 업적에 전혀 결점이 없는 컴퓨터 천재로 평가받는다. 폰 노이만의 천재성에 대해서는 인간이 지닌 한계를 인식하는 능력에서 부터 출발했다고 볼 수 있다.

보통 사람도 훈련을 하면 인간으로서의 한계가 있음을 인정하고 존중할 수 있다. 그렇다면 동료와 협력하여 그 한계를 극복하고 프로그래밍을 성공적으로 수행할 수 있다.

일화) 우주 추적 시스템을 만들던 빌은 전체 네트워크와 실시간 데이터 입력을 위한 시뮬레이터를 개발하면서 실제 네트워크에 연결하지 않고 전체 시스템을 실시간으로 점검하는 코드를 13개의 명령어로 된 루프 문으로 작성했다.
이후 자신의 작업을 비판해줄 동료인 메럴린에게 에게 13줄 짜리 코드에 17개의 버그를 찾아준 것으로 코딩이 되지 않은 날이라며 얘기했고, 메러린도 또 다른 사람에게 부탁해 추가 버그 3개를 더 발견했다.
이후 버그가 수정된 컴퓨터에 실행했을 때 오류가 발견되지 않았는데, 이후 9년 동안 새로운 오류를 발견하지 못했다.

만약 다른 사람이 오류를 찾아낼 때마다 자존심에 상처를 받았다면 (멍청함을 광고하는 꼴) 위 예제의 일화는 어떻게 달라졌을까?

비자아적 프로그래밍(egoless programming)이 널리 실천되지 않는 이유는 무엇인가? 
성공적인 소프트웨어 회사는 대부분 이런 형태의 협업을 근간으로 한다.
이것이 성공적이라는 지식 자체를 가치 있고 그들이 가지고 있는 지적 소유권이 있는 정보라 생각한다.
또 이런 방식으로 일하는 그룹의 구성원들은 스스로 매우 만족하며 안정감을 느끼는 경향이 있어 일자리를 잘 옮기지 않는다. 

이 방법이 널리 알려지지 않은 다른 이유는 이 방법으로 작업한 결과와 개인이 고립된 환경에서 작업한 결과의 질적 차이를 연구한 적이 없었기 때문이다. 프로그래머의 생산성에 영향일 미치는 요인에 대한 연구는 소수 있었고 프로그래밍의 기계적인 측면에 대해서만 연구했지 사회적인 측면은 고려하지 않았다는 문제가 있다.

비자아적 프로그래밍의 이점은 오류를 찾는 데에만 있지 않다. 비자아적 프로그래밍의 효과는 좋은 프로그래밍의 네 가지 요소와 관련지어 살펴보면 유용하다.

1.
요구 명세 충족이라는 문제에서는 그 가치가 분명하다. 일정과 작업을 완료하는 평균 시간에 미치는 효과는 분명하지 않지만 변동에 미치는 효과는 명확하다. 사전 동료 검토를 하지 않는다면 버그를 고치기 위해 더 시간이 필요할 가능성이 높다.

2.
동료 검토를 통해 프로그램에 익숙한 사람이 여러 명이 되면 작업 진척도를 실질적으로 측정하기가 더 쉬워진다. 이제 한 사람이 내린 판단에 의존하지 않아도 되기 때문이다. 그러면 프로그램의 적응성 역시 향상된다. 이는 상황에 따라 장점이 되는데, 프로그래머 중 한 명이 아프거나 출산을 하는 이유로 자리를 비워도 전체 작업에는 큰 지장이 없기 때문에 일정의 변수가 줄어들기 때문이다.

3.
효율성의 문제는 성급하게 확언할 수 없다. 그러나 비자아적 프로그래밍 방식으로 개발된 프로그램이 효율성에서 뒤쳐질 이유가 없는 건 확실하다. 효율성은 원래 프로그램을 작성한 사람의 구조에 영향을 받겠지만, 다른 사람의 검토를 거친다면 적어도 너무 뚜렷하게 비효율적인 부분은 미리 없어지기 때문이다.

4.
마지막으로 볼 이점은 다른 사람이 작성한 프로그램을 읽는 사람에게 미치는 효과이다. 프로그램 읽기에 내포된 가치를 제대로 평가했다면, 비자아적 프로그래밍 방식으로 작성된 프로그램을 읽는 사람은 더 나은 프로그래머가 될 것이다. 비자아적 프로그래밍을 실천하는 그룹의 능력 수준은 특별한 교육이 없어도 저절로 높아진다.

#### 프로그래밍 환경의 조성과 유지

이미 조성된 환경을 유지하는 건 쉬운데, 기존에 그룹을 새로운 환경으로 이끌려면 사회적 구조의 정착화 또는 고착화 현상이라는 난관에 부딪힌다. 고착화는 어떤 상황이 자신을 유지하기에 더 적합한 환경을 만들어 내는 것을 말한다.

한 회사에서 프로그래밍 언어를 한 가지만 사용하는 것은 프로그래밍 환경에 관련된 사회적 고착화 현상의 전형적인 예다. 한 언어만 쓰기 시작하면, 다른 언어가 새로 들어설 자리가 없어진다. 기존 언어를 쓰는 사람들이 같은 식의 이득을 계속 보고 있을 것이기 때문이다.

사회적 환경은 비자아적 프로그래밍을 장려하거나 억제하는 방향으로 조성될 수 있다. 새로 들어온 프로그래머의 마음가짐은 기존 구성원들이 어떻게 반응하느냐에 따라 다르게 형성되기 때문이다. 그것도 모르냐는 식의 조롱 보다는 잘 도와주고 감사해 한다면 거리낌이 없어질 것이다. 우리가 취하는 행동의 상당 부분은 주위 사람의 행동에 영향을 받는다. 프로그래밍 그룹에 새로 합류한 사람은 그 그룹의 철학에 맞춰 사회화된다.

구성원이 새로 합류하는 것 보다 더 큰 위기에 직면하기도 하는데, 고위 관리자가 비자아적 프로그래밍 철학을 위협하는 일이 자주 있다. 관리자들은 공격적인 축에 속하는 경우가 많고, 돈과 명예를 추구하지 않는 사람들을 이해하기 어려워 한다.

일화1) 공격적인 경영진과 유순한 프로그래밍 그룹 사이에 발생하는 충돌
성과급 보너스를 그룹의 개인에게 주려고 했는데 그 사람은 모두에게 지급되는게 아니면 받을 수 없다고 했다. 하지만 경영진은 그런 사고방식을 이해하지 못했고 강제로 그룹 대표에게 보너스를 주고 그룹을 해체시켰지만, 보너스를 받은 대표는 그룹에게 보너스를 균등하게 나눠주고 그룹 전체가 회사를 옮겼다.

일화2) 프로그래머 10명으로 구성된 그룹이 다른 나라로 배치되게 되자 이사가기 싫어서 모두 다른 회사로 옮김

#### 요약

프로그래머의 작업 환경은 복잡하고 인간관계와 그 변화 그리고 오해를 불러일으킬 만한 상황들로 가득 차있다.
그 환경을 이해하려면 공식적 구조와 비공식적 구조의 차이를 이해하고 물리적 환경에서 개인의 자아까지 환경에 영향을 미치는 다양한 요소들도 이해해야 한다.

프로그래밍 환경에는 외부에서 발생한 변화에 저항하는 자기보존성이 있다. 공식적/비공식적인 것의 차이를 이해하지 못하면 더욱 그렇다. 자기보존성은 사회에 존재하는 현상이고 좋은 것도 나쁜 것도 아니다. 그저 프로그래밍의 현실일 뿐이다.

#### 질문

##### 관리자에게

1. 당신의 관할 또는 주변 조직을 보여 주는 조직도가 있는가? 그 조직도의 사본에 당신의 조직에서 발생하는 상호 작용을 물결선으로 표시하라, 물결선이 조직도에 원래 있던 직선과 일치하는가? 만약 그렇다면, 책상에서 나와 밖에서 실제로 어떤 일이 벌어지고 있는지를 확인하라.

```
조직도를 그리려다가 설명으로 대체할 수 있어서 적어보면
조직 구성은 기능적 구성이다. 백엔드/서버 파트, 클라이언트 파트, 서비스 기획 파트, 디자인 파트 이렇게 크게 나눠볼 수 있는데
사실 조직도는 같은 직군의 사람들을 그냥 모아놓은 것에 불과하고
프로젝트별로 모인 사람들 끼리 상호작용이 일어나므로 물결선은 엄청나게 복잡하게 된다.
프로젝트 조직이 아닌 이상 기능 조직은 원래 직선과 일치하기는 거의 불가능하다.
```

2. 직원들이 자리 배치를 언제 마지막으로 바꿨나? 그 이후 원래 의도했던건 아니지만 어떤 변화가 발생했는가? 만약 지금 자리 이동을 다시 계획한다면 어떻게 다르게 하겠는가?

```
2024년 1월 초 새로운 사무실로 이사오면서 자리 배치를 바꿨다.
변화가 일어나지는 않았는데, 만약 자리 이동을 다시 한다면 프로젝트별 인원이 모일 수 있는 자리 배치를 할 것이다.
```

3. 당신과 프로그래머들 사이에 있었던 일들을 되돌아보라. 당신의 언행 중 프로그래머들을 인지부조화 상태에 빠뜨려 그들의 자아가 방어를 해야 하게끔 만든 것은 없는가? 그런 상황에서 항상 당신이 의도한 방향으로 부조화를 해소했는가? 또는 프로그래머가 일정 지연이나 오류를 고치기보다 숨기려 하는 것을 경험한 적이 있는가? 그럴 때 당신의 접근은 부조화 상태를 완화하는 것이었나 아니면 조직 전체의 목적에 좀 더 도움이 될 방향으로 해소시키는 것이었나?

```
그런 적은 없었던 것 같다.
만약에 그렇다면 유닛 테스트를 통과하는 코드를 작성하지 않고도 버그 수정을 덜 할 수 있도록 개발 시간을 압축해서 요구할 것이고
그게 인지 부조화로 작용할 것 같다.
```

4. 당신의 회사에 비자아적 프로그래밍을 도입하려면 어떤 일을 해야겠는가? 그 과정에서 어떤 저항에 부딪힐 것이며, 또 저항을 어떻게 해결하겠는가? 시간은 얼마나 걸리고 성공 확률은 얼마나 되겠는가?

```
경험에 비추어 보면, 우선 팀에서 하나의 프로젝트/제품을 개발한다는 인식을 만들고
코드를 공유해서 서로 확인하게 하는 GitHub와 Pull request 리뷰 프로세스를 도임할 것이다.
저항이 있다면 그런 프로세스가 정말 도움이 되는지 입증하는 것 정도인데,
이미 좋은 사례들에 대한 예시 글을 통해 주장의 근거를 만들고
실제 진행하면서 어떤 부분에 변화가 생겨서 비자아적 프로그래밍이 도움이 됐는지를 얘기해 줄 것이다.
당장 회사가 납품 일정을 맞추지 못하면 망하는 수준이 아니라면 성공한다고 보면 좋을 것 같고
1~2주 정도의 적응 기간, 한달 정도라면 팀원들 끼리의 비자아적 프로그래밍을 위한 도입은 완료할 수 있다.
도입 후 정착은 다른 논의 문제라고 한다면 재택 근무 때문에 원격에서 일하는 것만 아니라면 더욱 좋고 더 기간이 짧아질 수 있다.
```

##### 프로그래머에게

1. 전산실의 작업 처리 속도가 완벽히 일정하다면, 어떤 작업의 처리 여부에 관한 정보를 만드는 비공식 조직은 필요치 않을 것이다. 프로그래밍이 복잡하기 때문에 발생하는 변수가 비공식적인 사회 구조를 증가시키는 방식에는 또 어떤 것이 있을까? 당신의 경험을 토대로 예를 들어 보라.

```
흔히 경험했던 사례로 코드 공유는 GitHub를 통해서 어느 정도 상식으로 올라왔는데,
빌드/테스트/배포 자동화에 대해서는 특정 조직에는 정착이 잘 안되어 있는 경우가 많고,
비공식적인 경로를 통해 백엔트 팀의 개발자와 기획 팀의 팀원 끼리의 1:1 슬랙 메시지를 주고 받으면서
앱 배포가 되었는지 안되었는지를 얘기하는 경우가 예일 것 같다.
```

2. 단말기 시스템을 정기적으로 사용하고 있다면, 단말기 시스템의 다른 사용자들과 어떻게 정보를 교환하고 있는가? 다른 사용자와 메시지를 교환하는 기능을 단말기 시스템이 제공하는가? 만약 제공한다면, 그 기능이 다른 수단에 비해 실제 의사소통에 얼마나 가치 있는가?

```
1960년대의 컴퓨터 상황을 상상해 본다면, 터미널에 채팅 기능이 탑재된 건 비교적 최신 기능에 속해서 이런 질문이 있는 것 같다.
현재로 생각해 보면 개발용 노트북에 슬랙 앱으로 의사소통 하는게 얼마나 가치가 있는지를 보는 것일 것 같다.
그런 관점이라면 결정을 위한 논의 토론 정도가 아니라면 실제 의사소통과 거의 유사한 가치가 있다고 볼 수 있다.
설명과 질문이 계속 발생하는 수준의 얘기라면 슬랙 보다는 직접 의사소통을 하는게 더 빠르고 좋다.
```

3. 당신이 한 작업을 내 프로그램이라고 말하는가? 일주일 동안 프로그램을 지칭할 때 개인의 소유격을 사용하지 않아본 후 그 효과를 말해 보라.

```
사실 팀의 결과물이고 코드에 자아를 부여하지 않으므로 내 프로그램이라고 말하지 않는다. (말했던 시기가 있긴 했는데 그 마저도 15년 전 얘기다)
```

4. 너의 프로그램에는 오류가 있다며 다른 사람을 비난한 적이 있는가? 천공기나 자기테이프와 같은 무생물을 비난한 적이 있는가? 다른 사람이나 사물을 비난할 대 당신이 옳았던 경우가 몇 번이나 되는가?

```
공개적으로 비난하지는 않지만, 속으로 의문을 품을 때는 많다. 노트북이 주인을 닮아서 느리다던지 먹통이 된다던지 하는 비난은 종종 한다. 하지만 그런 비난이 옳은 경우는 없다고 볼 수 있다. 옳고 그름의 문제라기 보다는 가볍게 얘기하는 농담 수준이라고 볼 수 있다.
```

5. 당신의 프로그램에 어떤 오류가 있을 때 불운함을 탓했던 적이 있는가? 얼마나 자주 그랬는가? 다른 프로그래머들도 당신만큼 불운하던가? 아니라면, 왜 운명이 유독 당신만 박대한다고 생각하는가? 그 액운을 떨치려면 어떤 굿판을 벌여야 한다고 생각하는가?

```
Bad luck에 대해서는 생각은 할 수 있지만, 거의 대부분 나의 실수로 인한 일이 많았다. 컴퓨터는 보통 잘못이 없고 개발자의 부주의로 인한 문제가 더 많기 때문에 운에 기대는 프로그래밍은 바람직 하지 않다고 본다.
```

#### 참고문헌

- Kevin Lynch , < The Image of the City > Cambridge, M.I.T Press, 1960년

우리를 둘러싼 물리적 환경에 대한 이미지가 우리 삶에 미치는 영향을 탐구한다.

- Frank Lloyd Wright < An Organic Architecture: The Architecture of Democracy > London, Percy Lund, Humphries & Co., Ltd., 1939년

'형태는 기능을 따른다'는 생각을 설파함. 양복을 입을 사람에게 맞춰 재단하듯 물리적 환경도 그 안에서 수행될 업무에 맞춰 설계해야 한다는 뜻이다. 감수성이 예민한 관리자라면 이 책을 통해 물리적 환경을 제고할 필요가 있다.

- Erving Goffman < The presentation of Self in Everyday Life > Garden City, N.Y., Doubleday, 1959년

일하는 사람들은 물리적 환경 외에도 사회적 환경에 대한 이미지에도 영향을 받는다. 외부 또는 새로 들어온 사람들에게 보이는 이미지를 형성하기 위해 개인과 그룹이 벌이는 전쟁 같은 과정을 탐구한다.

- Edward T. Hall < The Silent Language > garden City, N.Y., Doubleday, 1959년

홀은 조직의 이미지에 대해 다른 관점을 취하여 우리가 살고 있는 그룹의 공식 도는 비공식적 구조를 바라보는 우리의 시각이 어떻게 얻어지는지 설명한다.
홀의 이러한 접근법으로부터 프로그래머가 사회화되는 과정과 학교나 책에서는 가르치지 않는 프로그래밍 지침을 우리가 익혀 가는 과정에 대한 많은 통찰을 얻을 수 있다.

- L. A. Festinger < A theory of Cognitive Dissonance > Evanston, 3., Row, Peterson, 1957년

이번만은 프로그램이 동작한다거나 방금 것이 마지막 버그였다는 등의 예언이 매번 틀리는 환경에서 일하는 사람들에게는 인지부조화가 남의 얘기가 아니게 된다.

- Mason Haire < Psychology in Management > 2판, New york, McGraw-Hill, 1964년

관리자가 아닌 사람들이 어떻게 동기 부여를 하는지 이해하는 데 어려움이 있는 관리자라면 이 책이 좋은 출발점이 된다.

#### 4장에 보태는 글: 프로그래밍 그룹

배치 처리 시스템으로 운영되던 전산실은 이미 역사의 뒤안길로 사라졌지만 물리적인 공용 공간의 사회적 기능은 여전히 존재한다. 25년 전과 달리 이메일을 어디서나 쓸 수 있지만 공용 공간의 사회적 기능을 모두 대체한 건 아니다. 이메일의 장점이 상대적인 비가시성인데 관리자가 불만이 있다고 해도 이메일을 통한 의사소통 시스템은 한 순간에 무너뜨리기 어렵다.

현업 관리자들이 심리학 연구 결과를 무시한다는 증거 중 하나로 사무실 공간을 분할하기 위해 파티션을 쓴다는 점이다. 관리자들의 심리는 생산성 보다는 자신의 사회적 지위를 더 과시하고 싶어 한다. 그래서 디마르코와 리스터가 쓴 < 피플웨어 > 를 통해 그런 문제가 사라질 거라 보진 않는다.

이에 대해 브라이언 피오렉은 다음과 같이 말을 했다.

> ... 관리자들은 자신의 업무 수행에 대해 훈련 받지도 않을 뿐더러 스스로 공부하지도 않는다. 관리자들은 개발자였던 시절에는 지위가 약했으므로 그만큼 권력에 더 집착하는 편이다. ...

프로그래머들은 다른 프로그래머와 교류할 필요가 있다. 1971년에 원격 시스템이 등장해서 프로그래머의 고립이 심해질 것이라 예측했지만, 형편없이 관리되는 일부 조직만 그렇고 보통 프로그래머는 프로그래머가 아닌 사람들이 많은 회사에서 오래 머물러 하고 싶어 하지 않는다.

프로그램 오류와 프로그래머의 자아를 심리학적으로 다루는 글을 쓴다면 고분고분, 공격적, 고립적과 같은 용어 보다는 MBTI(Myers-Briggs Type Indicator) 시스템을 차용할 것이다. 프로그래머와 관리자의 행동에서 나타나는 경향성을 이해하는 데 MBTI 시스템이 크게 도움이 됐고, < Quality Software Management > 시리즈를 저술할 때 일부 응용했다.

비자아적 프로그래밍은 이 책에 가장 많이 인용됐고 또 가장 많은 오해와 반박을 받은 개념이다. 만약 덜 자아적인 프로그래밍(less-ego programming) 정도의 약한 표현 정도였으면 반론이 적었을 수도 있다. 더불어 더 나은 그리고 더 많은 예제 및 실험에 의한 증거가 더 있으면 좋았을 것이다.

비자아적 프로그래밍에 대해 언급할 때
비자아적 프로그래밍을 통해 작업한 결과와 개인 프로그래머가 고립된 상태에서 작업한 결과의 질적 차이를 연구한 결과가 없기 때문에 널리 알려지지 않았다고 했다.

하지만 25년 간 상황이 나아져서 지금은 상호 검토를 거치면 더 저렴하고 꾸준하게 신뢰성 있는 코드를 만들어 낼 수 있다는 증거는 부족하지 않다. 지금은 전부 그런 것은 아니지만 25년 전 보다는 훨씬 많은 상호 검토를 표준 업무 절차에 포함시키고 있다.

그 동안 또 배운 것이 있다면 자신의 코드를 다른 사람이 검토하는 것을 원하지 않는 이유가 논리적이지 않다면, 그런 태도를 바꾸는 데 논리적인 설득 또한 소용 없다는 점이다. 비논리적인 행도응ㄹ 하는 사람의 직업 정신은 제한적일 수 밖에 없다.

일 잘하는 팀을 꾸리는 능력이나 산출물의 품질은 관리자 입장에서 큰 문제가 아니다.
=> 이런 상황이면 관리자는 프로그래머에게 단기적인 성과를 재촉하게 된다
=> 일부 프로그래머가 그런 법칙을 이해하고 같은 방식으로 행동한다.
=> 팀의 가치를 믿지 않는 또 한 명의 관리자가 되는 기술을 연마하게 된다.
=> 그리고 관리자가 되면 같은 과정이 반복된다.
=> 결국 그렇게 잘못된 관리자가 점점 더 늘어난다.