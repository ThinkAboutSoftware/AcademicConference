### 7장 프로그래밍 작업의 다양성

```
논의주제)
프로와 아마추어에 대한 논의는 아마 다른 분이 해주실 거라 믿고 다른 주제를 선택해 보려 합니다.

프로그래머가 하려는 것은 무엇인가? 라는 소주제를 가지고 방대한 분량을 연구 분석한 것 중에
프로그래머가 일을 잘 하는지 알아 보려면 적절한 수준으로 작업하고 있는지를 보면 된다고 했고
그 수준을 조절할 수 없으면 프로가 아니라고 했습니다.

다른 분들은 적절한 수준으로 작업하는지에 대한 판단을 어느 정도 하는지 얘기해 보면 좋겠습니다.
물론 판단은 선임/팀장/리더가 하고 작업만 하시는 분은 예외입니다.
```

어떤 행위를 더 깊이 설명하기 위해서는 더 가까이 뛰어 들어야 하고
이것이 프로그래밍에 관한 몇몇 미신적인 통념을 없애고 싶은 우리들이 해야 할 일이다.

#### 프로그래밍의 프로와 아마추어

고등학생과 직업 프로그래머가 양 극단을 대표한다고 했을 때 이 양 극단은 다를 수도 혹은 같을 수도 있다.

그 차이는 분명한데, 아마 누가 그 프로그램을 사용할 것이냐에 있을 것이다.
자신이 사용할 것인지, 혹은 다른 누군가가 사용할 것인지.
프로도 자신이 사용할 프로그램을 만들기도 하지만 다른 사람이 그 프로그램을 사용할 경우를 대비한다.
즉, 다른 사람이 사용한다는 사실 하나가 프로그래머의 작업에 여러가지 영향을 미친다.

보통 문제를 단순하게 만들어 버리는 것은 문제를 정의하는 사람이 프로그램 자신일 경우밖에 없다. 프로는 자리에서 일어나 프로그램 수정을 허락하거나 요구 명세를 명확히 규정해 줄 다른 사람을 찾아가야 하기 때문이다.

프로는 프로그램을 잘 포장해서 냉혹한 세상으로 내보내야 한다. 그 후에는 자신에게 돌아오는 신랄한 비판에 따라 프로그램을 여러모로 수정해야 한다. 진정한 프로는 수정할 여지가 없을 만큼 완벽에 가깝게 만들겠지만, 이건 프로그래밍 전에 많은 고민을 해야 한다는 것과는 다른 문제다.

프로는 다른 사람을 위한 것이 아니더라도 작성한 프로그램에 대해 아마추어와 같이 깔끔하게 잊고 살 수 없다.

오늘날에는 아마추어가 하려는 작업을 대부분 시스템이 알아서 처리해주기 때문에 큰 격차가 생기고 있고, 그 격차는 점점 더 커지고 있다. 역설적이게도 그 격차가 커질수록 아마추어는 격차의 존재를 더욱 더 알지 못한다. 이유는 시스템이 어떤 일들을 자동으로 해주는지 점점 더 모르게 되기 때문이다.

시스템 설계자가 일을 더 잘 할수록 사용자에게 그의 존재는 점점 더 잊혀진다. 이는 관리자가 훌륭할수록 직원들이 그의 존재를 크게 의식하지 않게 되는 것과 같은 이치다.

관리자는 프로그래밍에 대해서는 아마추어이다. 그들은 강좌를 통해 프로그래밍 과제를 수행했고, 여러 방해가 있었지만 프로그램을 완성했다. 그리고 다음과 같이 생각했다.
"우리도 정해진 시간 내에 프로그램을 다 만들었는데, 프로그래머들이 못할 이유는 뭐지? 우리가 일주일 만에 배울 수 있는 프로그래밍이 뭐가 어렵다는 걸까?"

이건 아마추어 자신이 프로와 별 차이 없다고 생각하는 것과 같은 종류의 착각인 것이다.

- 경영진은 스스로 만든 프로그램을 프로가 만드는 프로그램과 동일시 하는 의미론적 착각을 했다.
  - 경영진은 단순 계산을 통해 문제를 해결하는 프로그램을 만든 반면
  - 프로는 운영체제, 컴파일러, 유틸리티 등의 프로그램을 만든다고 생각하면 된다.
- 조교의 도움을 그다지 많이 받지 않았다라는 착각을 했다.
  - 프로그래밍의 복잡성을 잘 이해하지 못한 문제
  - 조교들은 일부러 간단한 문제도 해결하지 못할까봐 복잡한 내용은 숨겼다.

이런 배려는 프로그래머의 어려움을 경영진이 더 잘 이해할 수 있도록 하려는 의도와 달리 역효과를 낳고 말았다.

프로와 아마추어의 차이는 과거의 경험에 있다고 할 수 있다.
과거에 어떤 프로그램들을 만들어 봤는가뿐만 아니라 미래에 어떤 프로그램을 만들 것인가에도 큰 차이가 있다.

아마추어는 목적만 달성하는 프로그램의 결과를 얻을 뿐 어떻게든 만드는 데에 집중한다.
어려운 부분은 극복하는 게 중요하지 과정은 신경 쓰지 않는다.

그러나 프로는 눈 앞의 문제를 우회할 여러 가지 방법이 있으며 그 중 하나를 통해 급한 불을 끌 수도 있다.
그러나 그 일은 거기가 끝이 아니라 시작을 뿐이다. 자신이 왜 이해하지 못하는지를 이해해야만 하기 때문이다.
나중에 그 이해가 필요한 프로그램을 만들어야 할 때를 대비하는 것이다.

아마추어는 주어진 문제에 대해 배운다. 그리고 배운 것은 뽑낼 만한 장식이 될 수 있지만 발전의 장애가 되기도 한다.
프로는 자신의 직업에 대해 배운다. 지금 다루는 문제는 발전하는 과정의 한 단계일 뿐이다.

프로는 어떤 문제도 아마추어 만큼 심각하게 생각하지 않는다. 버그는 항상 있어왔기 때문이다.
이런 태도의 차이는 아마추어와 프로 간의 끊임 없는 마찰로 이어진다.

프로는 아마추어들이 잘못된 결과에 대해 여러 방면(컴퓨터, 운영자, 시스템, 천공기, 언어, 정부 등등)탓을 하는 것에 좋은 시선을 가지고 있지 않다.
아마추어는 프로들이 급한 상황인데도 너무 느긋해서 책임감이 없어 보인다고 여긴다.

#### 프로그래머가 하려는 것이 무엇인가?

아마추어와 프로의 관계에는 불균형이 있다. 프로는 아마추어의 작품을 전문성이 떨어진다고 생각하지만, 이는 아마추어가 자신과 프로의 차이를 과소평가하는 것보다 더한 잘못이다. 진정한 프로는 아마추어보다 훨씬 잘 알아야 한다.

프로그램은 사람이 만드는 다른 모든 물건처럼 명확한 수명과 활용 범위를 염두해 두고 설계된다. 수백 년 동안 유지될 수 있을만큼 논리적인 방법으로 만든 장인의 작품처럼, 프로그램에는 과도하게 설계된 부분도 미진하게 설계된 부분도 있어서는 안 된다. 하지만 프로그래머는 가장 많은 작업을 요구하는 부분보다 가장 흥미로운 지적 도전을 질길 수 있는 부분에 더 많은 시간을 할애하는 직업병이 있다.

프로그램을 개발할 때는 그 용도에 따라 적절한 수준으로 노력을 기울여야 한다. 적절한 수준 이상으로 작업하는 것은 차라리 그 이하로 작업하는 것보다 더 프로답지 못하다. 프로그래머가 일을 잘하고 있는지 알려면 그가 주어진 문제에 대해 적절한 수준으로 작업하고 있는지를 보면 된다. 작업의 수준을 적절히 조절하지 못하는 사람은 프로가 되기에는 항상 실격이다.

프로그래머는 문제를 해결하고자 기울이는 노력 수준을 조정하는 데 보통 실패한다. 풀어야 할 문제가 무엇인지를 모르기 때문이다. 과거의 경험을 기반으로 현재의 문제를 가정하므로 일이 끝날 때까지 주어진 문제를 제대로 파악하지 못한다.

프로그래밍 목표를 어떻게 가정하느냐에 따라 성과가 얼마나 달라지는가를 알아보고자 작은 실험을 진행했다.
프로그래머 네 명에게 동일한 문제를 주고 문제 명세까지도 동일하게 줬다.
두 명과 나머지 두 명에게는 마지막에 다른 명세를 줬다.

> 프로젝트의 목표: 완전히 디버깅되고 최대한 효율적인 프로그램을 만드는 것
> 제약: CPU 시간을 최소로 사용하고 메모리는 128K까지 필요한 만큼 사용.
> 일정: 9주차 말 까지 완성

> 프로젝트의 목표: 완전히 디버깅된 프로그램을 최대한 빠른 시일 안에 만드는 것
> 제약: 프로젝트 완료에 영향을 주지 않는 한 속도, 메모리 사용량 등 효율성을 고려할 필요 없음. 프로그램의 크기는 128K 미만이어야 함.
> 일정: 하루에 정해진 시간인 업무 시간의 1/5 이상을 사용하면 안됨

프로그램을 가능한 바른 시일 안에 만들기를 지시받은 조는 다른 조에 비해 평균 2/5 컴퓨터 시간과 1/3의 개인 작업 시간을 사용했다.
그러나 만들어진 프로그램의 속도는 평균적으로 약 10배나 느렸다. (표 7-1의 인덱스 문제)
효율적인 프로그램을 요구받은 조의 프로그램의 속도가 다른 조에 비해 50% 더 빨랐다. (표 7-1의 파일 문제)

| | | | | |
|-|-|-|-|-|
| | INDEX PROBLEM | INDEX PROBLEM | FILE PROBLEM | FILE PROBLEM |
| | MEAN # OF RUNS | MEAN EXECUTION TIME | MEAN # OF RUNS | MEAN EXECUTION TIME  |
| EFFICIENT PROGRAM | 78 | 1 | 60 | 1 |
| FAST PROGRAMMING | 30.5 | 10 | 27 | 2 |

**표 7-1 환경이 성과에 미치는 영향**

위 실험은 문제 유형도 노력해서 향상시킬 수 있는 효율성의 정도에 영향을 끼친다는게 드러난다.
목표에 대한 인식 차이가 프로그래머가 어떤 일을 수행할 때에 행동 차이를 낳는다는 사실은 알 수 있다.

효율성을 추구하는 그룹이 더 많은 컴퓨터 시간과 개인 시간을 사용한 원인을 분석해 보면
빨리 완성하려는 그룹은 현재 방법이 맞지 않으면 버리고 다른 방법을 찾는데 비해
효율성을 추구하는 그룹은 어려움이 생겨도 접근 방법을 중간에 바꾸지 않는다. 그러면 효율성을 어느 정도 잃기 때문이다.

심리학적인 관점에서 보면 교훈은 명확하다. 동일한 객관적 사건이라고 해도 목표에 따라 프로젝트에 미치는 영향은 다르다.
따라서 프로그래머의 성과를 측정하거나 언어, 운영체제의 성능을 비교하려면 주어진 문제가 정확히 동일함이 보장되어야 한다.

실생활에서 두 그룹이 정확히 동일한 문제를 다루는 경우가 없으므로 한 그룹 내의 관리자와 프로그래머들이 전혀 다른 목표를 추구하고 있더라도 그 사실을 인지할 수 없을지도 모른다. 끊임없이 의사소통하여 목표를 공유하지 않는다면 일정이 지연되거나 프로그램의 속도가 느리거나 메모리를 많이 사용하는 등의 문제가 생긴다 해도 놀라지 말아야 한다.

하지만 목표를 아무리 잘 공유해도 어느 정도의 위험은 피할 수 없다. 목표가 추정에 영향을 주기 때문이다.
앞의 실험에서 목표가 성과에 미치는 영향을 발견한 후에 프로젝트 시작 전에 완료 시점까지 프로그램을 실행시켜 볼 횟수와 소요 기간을 각 프로그래머가 추정하도록 했다.

| | | | | |
|-|-|-|-|-|
| | RUNS | RUNS | DAYS | DAYS | DAYS |
| | ESTIMATED | ACTUAL | ESTIMATED | ACTUAL  | % LATE |
| EFFICIENT PROGRAM | 22 | 69 | 48 | 76 | 75 |
| FAST PROGRAMMING | 39 | 29 | 68 | 65 | 25 |

결과는 표 7-2와 같은데 빨리 완성하려는 그룹의 프로그래머는 상대적으로 훨씬 보수적인 추정치를 제시했다.

또 다른 흥미로운 결과는 목표를 명확히 수립할 때 두 가지 영향이 생긴다는 점이다.
프로그래머는 다른 목표를 희생해서라도 그 명확한 목표를 달성하려고 한다. 그리고 목표를 충족하기 위해 보수적으로 추정하게 된다.

목표 일정은 주어진 시간 자체에 영향을 준다는 것을 확인했다. 일이 주어진 시간을 다 채울 때까지 늘어날 수 있는 이유는 일정에 대한 다른 목표들의 상대적 중요성이 명확하지 않기 때문이다.

"프로그래밍 프로젝트는 제때에 끝날 수 없다"는 통념을 낳은 오해들을 불식시킬 수 있을 것이다.

#### 프로그래밍 작업의 단계

"프로그래밍은 단일한 재능이 요구되는 단일한 작업이다" 라는 통념에 비해
프로는 요구 명세 수집에서 부터 최종 프로그램 납품에 이르는 과정 동안 다양한 재능이 필요한 다양한 작업을 해야 한다.

시스템 설계 업무에는 숲의 전체 모습을 놓치지 않는 시야가 필요하고
디버깅 업무에는 나무 하나하나를 자세히 살필 눈이 필요하다.

코딩을 할 때에는 쓸데없는 부분은 모두 없애야 하지만,
문서를 작성할 때에는 문단의 크기를 맞춰 때로는 간단한 문장도 늘려 써야 한다.

능력 있는 프로그래머가 관리자로는 실패할 수도 있는 것처럼,
훌륭한 설계자도 디버깅에는 서투를 수 있다.

적재적소에 필요한 재능을 투입하려면, 프로그래밍 작업을 단순히 프로그래밍이란 한마디로 싸잡을 것이 아니라 더 정밀하게 세분화해야 한다.

일반적으로 프로그래밍은 문제 정의, 분석, 흐름도 작성, 코딩, 테스트, 문서화로 이어지는 과정이 있는데 몇 가지 점에서 진실을 왜곡한다.

- 작업의 순서가 그렇게 고정되어 있지는 않다.
- 새로운 플랫폼이나 언어로 포팅하는 경우 모든 단계가 항상 필요하지는 않다.
- 각 과정을 일차원적으로(sequential) 진행할 필요는 없다.

실제로 프로그래밍 프로젝트를 명확하게 정의된 단계로 나누는 것이 가능하다 할지라도 그다지 바람직하지는 않다. 업무마다 필요한 재능이 다르고, 프로젝트에 참여한 프로그래머들은 각자 다양한 종류의 재능을 가지고 있다. 작업을 여러 부분으로 분리하고 각 부분 작업을 해당 단계에서 동시에 수행하는 편이 좋을 수도 있다. 그러면 작업의 진척이 좀더 일정해지고 매일 변동될 프로그래밍 환경이나 프로그래머 컨디션에 영향을 덜 받을 것이기 때문이다.

이상적인 프로젝트에서는 모든 인력을 동시에 프로그래밍의 특정 단계로 몰아넣지 않아야 한다. 다행인 점은 각 단계의 구분이 실제로 그렇게 명확하지 않다는 점이다. 훌륭한 프로그래머는 어떤 작업에서 장애물에 맞닥뜨렸을 때 다른 작업으로 의식적이든 무의식적이든 전환한다. 일종의 경계 허물기를 한다.

프로그래밍이란 이름 아래 행해지는 작업이 지닌 다양성으로 인해 프로그래밍에 대한 심리학적 연구 결과에는 어느 정도 과정이 섞이게 된다. 집요하게 파고 들어야 하는 문제에 우월한 능력을 보이는 프로그래머가 있을 것인데 문제가 바뀌어 세부 사항보다는 전체 그림을 넓은 시각에서 바라보는 능력이 필요하다면 상황은 역전될지도 모른다. 이런 이유로 비슷한 연구인데도 결과가 30배가 차이나는 경우가 있다.

프로그래머들에게 규모가 큰 문제를 주면 극적이었던 차이는 줄어들게 된다. 문제의 규모가 크면 각 프로그래머가 잘하는 부분과 못하는 부분이 섞여 있을 것이기 때문이다.

30배라는 수치도 프로그램이 아닌 작업의 성격으로 프로젝트를 분리한다면 30배의 생산성 차이를 볼 수 있다. 비자아적 프로그래밍을 실천할 때의 결과가 이런 것임에 주목해야 한다. 프로그래머들이 프로그램을 소유한다면, 이런 잠재적인 생산성을 실현하지 못할 것이다.

버그를 찾는데 천재적인 사람들이 버그를 수정하는 임무에는 적절하지 않을 수도 있다. 이미 발견된 버그는 흥미를 끌지 못하기 때문이다. 버그를 프로그램에 적절한 방식으로 어느 정도 우아하게 수정하려면, 다른 특성을 지닌 프로그래머가 필요하다.

버그를 찾는 사람에게는 분석적인 사고력이 필요한 반면
버그를 수정하는 사람에게는 종합적인 사고력이 필요하다.
한 사람이 두 가지 일에 모두 뛰어날 수도 있지만, 그런 사람을 찾기 보다는 두 가지를 다 잘하는 팀을 찾는 편이 더 쉽다.
각 팀원의 소질과 단점을 인정하는 감각과 겸손함을 갖췄다면, 그 팀의 능력은 팀원 각자의 능력을 능가할 것이다.

#### 요약

프로그래밍은 획일적인 한 덩어리의 행위가 아니다. 프로그래머 자신도 새 프로그램을 만들 때마다 다른 일을 하고 있다는 사실을 자주 잊는다.

프로그래밍에 관한 논의를 활성화시키려면 논의의 수준을 낮출 수밖에 없다.
"무엇이 좋은 프로그래머를 만드는가?"란 주제에서 결론을 얻으려면 논의되는 내용보다 더 세부적인 면까지 고려해야 한다.
좋은 프로그래머를 만드는 요소가 훌륭한 우정을 만드는 요소와 비슷하다는 사실을 발견할 수 있는데
그건 상호 관심과 개성 존중이다.

#### 질문

##### 관리자에게

1. 경영진을 대상으로 한 프로그래밍 강좌에 참여한 적이 있는가? 그 강좌에서 당신은 무슨 일을 했고, 그 일이 직업 프로그래머의 업무와 어떤 관련이 있는지 설명하라. 그리고 프로그래밍의 성격에 대해 당신이 오해하도록 만든 내용이 있었다면 설명하라.

```
아직은 없다. 있다면 파이썬으로 하는 업무 자동화 정도일 것 같은데
만약 그걸 했다면 직업 프로그래머가 하는 일의 일부를 맛본 것 정도라고 생각해 볼 수 있다.
하지만 나는 프로그래밍 일을 오래 했으므로 오해하도록 만든 내용이 있으면 금방 알아챌 것이다.
```

2. 당신은 프로그래밍 작업의 복잡도를 어떻게 추정하는가? 요구 명세를 검토하는가? 작업을 맡은 프로그래머가 하는 말을 참고하는가? 여러 사람의 의견을 듣는가?

```
답변을 길게 적었다가 관리자 관점이 아니라는 점을 발견하고 다시 적어 본다.
복잡도의 추정은 개인적으로 할 수 있지만 전적으로 프로그래머에게 맡기는 편이다.
하지만 요구하는 일정이 있으므로 프로그래머가 제시한 일정과 협의를 볼 것이다.
요구 명세를 검토하고 대략의 설명까지도 할 수 있다.
작업을 맡은 프로그래머가 하는 말을 참고 정도가 아니라
전적으로 믿는 쪽으로 가야 할 것이며 여러 사람의 의견을 듣는 것 역시 관리자의 미덕이라 볼 수 있다.
```

3. 당신이 내리는 지시는 다음에 나열한 요소 간의 상대적 중요성을 얼마나 명확히 담고 있는가?

- 일정 준수
- 요구 명세 충족
- 실행 속도
- 메모리 사용량
- 문서화
- 기타 요소

```
다시 관리자의 관점에서 잘 살펴봐야 한다. `당신이 하는 일`이 아니라 `당신이 내리는 지시`다.
즉 자신이 실행 하는 게 아니다.
그런 관점이라면

일정 준수
요구 명세 충족
문서화 - 메뉴얼 관점에서
실행 속도
메모리 사용량
기타 요소

라고 볼 수 있다.
```

4. 현재 프로젝트에서 계획된 작업의 순서를 설명하라. 실제 작업이 처음에 계획한 순서대로 진행되는가? 끝까지 그런 식으로 진행되기를 바라는가?

```
특정 마일스톤에 따라 진행하는데 특별히 설계 보다는 구현 중심의 작업이고
그마나 테스트 과정이 조금 추가되고 있다는 점과 리팩터링이 병행되고 있다는 작업의 특징이 있다.
처음 계획한 순서대로 절대 진행되고 있지 않다.
중간에 다른 이벤트가 있어서 작업 흐름이 끊기기도 하고
순서대로 진행되지 않기도 한다.
그런데 사실 이런 식으로 진행되기 보다는 
애자일 스크럼 조직을 통해 이런 이벤트 변화를 받아들이지 않는 방향으로 갔으면 하는 바램이 있다.
```

5. 진행 상황 보고의 양식이 실제 진행되는 프로그래밍 업무에 얼마나 잘 부합하는가? 실제 업무에 부합하는지를 판단하고자 어떤 검사를 하는가? 잘 부합한다면, 프로그래머에게 실제 업무의 필요보다 양식에 맞추기 위해 일하도록 은근히 강요하기 때문은 아닌가?

```
프로그래밍 작업의 결과로 보고 양식이 정해지므로 동작하는 결과를 보고 판단한다.
결국 관리자는 유닛 테스트를 믿기 보다는 본인이 직접 해보는 AdHoc 테스트를 하게 되는 것 같다.
초기에는 잘 부합하는 것처럼 느껴지지만 그것도 결국 시간이 흐르고 관리가 들어가게 되면
프로그래머에게도 보여주기식 보고 양식으로 변질되게 된다.
하지만 양식에 맞추기 위해 강요하는 건 아니고
작업의 내용 공유를 위해 진행 상황 보고가 들어간다고 보면 된다.
```

6. 주요 장비에 대한 부하를 고르게 맞추기 위해 관리자로 어떤 조치를 취하는가?

```
아마 시대상을 반영해서 컴퓨터 사용 시간 조절을 뜻하는 데
현대 시대는 개인이 개인 컴퓨터를 사용하므로 관리자가 특별히 조치를 취해야 하는 건 없다.
업무 효율을 위해 프로그래머에게 좋은 장비로 업그레이드 하는 조치는 년마다 해주는 건 좋을 것 같다.
```

##### 프로그래머에게

1. 당신은 프로인가? 무엇이 당신을 프로로 만드는가?

```
단순히 요구 명세를 만족하는 동작하는 소프트웨어가 아닌
잘 만들어지고 다듬어져서 프로가 아닌 사람도 가독성, 유지보수성을 느낄 수 있도록 하는 게
프로를 만드는 자세라고 볼 수 있다.
```

2. 15년 전에는 당신이 직접 해야 했지만 지금은 소프트웨어가 대신 해주는 일들을 나열해 보라. 혹시 15년 전의 소프트웨어가 어땠는지에 대해 모르는가? 프로라면 자기 직업의 역사를 조금이라도 알아야 한다고 생각하는가?

```
현 시점 15년 전이라면 2009년을 얘기해 보면 될 것 같다.
가장 큰 변화라고 하면 ChatGPT와 같은 AI 기술의 폭발적인 발전으로 텍스트, 이미지 생성형 AI가
프로그래머가 직접 코딩 작업을 하지 않아도 생성해 주는 방식으로 변하고 있다.
15년 전의 소프트웨어가 어땠는지 모르지는 않지만
자기 직업의 역사를 알면 매우 좋다고 생각한다.
기술 특히 도구들의 발전은 엄청나게 빠른 속도로 발전하고 있는 반면
인간 본연의 문제들은 과거나 지금이나 크게 다르지 않다고 보는 입장이다.
그런 측면에서 기술의 역사 보다는 컴퓨터를 다루는 사람의 생각과 다루는 개념의 역사를 안다면
도움이 많이 될 것으로 생각한다.
```

3. 당신은 여러 성격을 지닌 프로그래밍 작업에 골고루 노력하는가, 아니면 가장 좋아하는 작업만 하려 하는가? 당신이 잘 못하거나 싫어하는 작업에 대한 성과를 높이기 위해 어떤 노력을 하는가? 당신이 잘하는 작업에 대해서는 어떤 노력을 하는가?

```
골고루 하려고 노력하고 어느 정도는 습관이 된 것도 있다.
우선 코딩 외에 설계, 문서화, 테스트 코드 작성은 잘 하고 있는 편이다.
잘 못하는 쪽은 유지보수가 들어가면서 문서 업데이트가 잘 안되는 부분이 있어서
이것도 버전관리를 위해 github를 활용해서 못하는 부분을 바로잡기 위해 노력하고 있다.
잘하는 작업에 대해서도 다시 한번 개념이해를 하고
가까운 미래에 일어날 일 까지 대처해서 만들어 두는 노력을 하는 편이다.
```

4. 당신이 현재 참여하고 있는 프로젝트의 목표는 무엇인가? 중요한 순서대로 목표를 나열하라. 그리고 관리자에게도 그런 목록을 작성하도록 부탁하라(당신이 작성한 목록을 보여줘서는 안 된다), 두 목록을 비교하여 차이점을 설명하라.

```
직접 해 보면 좋겠지만 오늘까지만 해도 그 목표에 대한 점검과 공유 미팅을 통해 확인이 된 부분이 있으므로
나열해 본다고 하면 관리자가 만든 목록과 크게 다르지 않을 것이라고 판단한다.
만약 우선순위가 다른 목록이 있다면 지금의 목표외에 미래의 목표와 섞여서 그런 것일 가능성이 있다.
```

5. 컴퓨터가 고장나서 며칠 동안 디버깅 작업을 할 수 없을 때에는 무슨 일을 하겠는가?

```
이 질문도 시대적 배경을 이해해야 하는데
아마 전산실이 잠시 이전하거나 문제가 있어서 사용하지 못하는 것 예상하고 한 질문 같다.
현재 시대는 컴퓨터가 고장난다면 바로 창고에 있는 대체 노트북으로 몇 시간 이내 개발환경 세팅 후 디버깅 작업을 계속 이어나갈 수 있다.
```

6. 다음 중 당신이 가장 잘하는 일은 무엇인가?

- 미묘한 버그를 발견하는 일
- 발견된 버그의 발생 위치를 코드에서 찾는 일
- 간단하고 효과적인 수정 방법을 고르는 일

가장 잘하는 일 외의 다른 두 가지에 대한 약점을 극복하려고 당신은 어떤 노력을 하는가?

```
가장 잘 하는 걸 고르라면 간단하고 효과적인 수정 방법을 고르는 일일 것이다.
그러면 나머지 두 가지에 대한 부분인데
사실 이게 약점이라고 생각하질 않아서 큰 노력을 해보지도 않았던 것 같은데
다른 접근 방법으로 효과적인 디버깅이라고 생각하는 건
같은 기능이나 도메인의 기능 구현을 두고 잘 아는 사람과 대화해 보다가 디버깅의 힌트를 몇 번 얻은 적은 있다.
이런 일이 노력의 일부라고 볼 수 있다면
나는 다른 사람과 디버깅 하는 목적과 방법에 대해 얘기를 같이 해 보면서
내가 탐색해 보거나 접근하지 못한 방법에 대해 힌트를 얻는 다는 걸 얘기해 볼 수 있을 것 같다.
```

#### 참고문헌

- S.Rosen 편저 < Programming Systems and Languages > New York, McGraw-Hill, 1967년

로젠은 컴퓨터 소프트웨어 분야의 중요한 고전적 논문을 모아 주석을 달았다.
신입은 이 모음집을 통해 자기 직업이 현재 모습을 하게 된 이유를 알 수 있게 될 것이다.

- Jean E. Samment 지음 < Programming Languages: History and Fundamentals > Englewood Cliffs, N.J., Prentice-Hall, 1969

사멧은 크든 작든 모든 성과를 동일한 패턴에 담아 역사를 느끼게 해주려 했다. 두 가지 접근 방법으로
첫재, 모든 성과에 패턴을 부여하려는 시도로 프로그래밍 작업이 다양하고 복잡하다는 걸 보여준다.
둘재, 로젠처럼 가장 성공적이었던 성과만을 모아두면 어려움이 없었다는 인상을 주기 쉽기 때문에 사멧은 소프트웨어 개발 역사에 존재하는 수많은 시도와 실패를 매우 잘 포착해 냈다.

- Phillip W. Metzger 지음 < Programming Project Management Guide > IBM Federal Systems Division, 1970년 4월
- Charles P. Lecht 지음, < The Management of Computer Programming Projects > American Management Association, Inc., 1967년

두 책은 프로그래밍 프로젝트 관리에 대한 대표적인 교본들이다.
메츠거의 책은 프로그래밍 프로젝트 관리에 대한 IBM의 내부 강좌에서 사용된 교재였고, 그 주제를 다룬 최초의 교본 중 하나이다.
렛츠의 책은 같은 주제에 대해 American Management Association이 펴냈다.
두 책에는 관리자의 격려 연설과 같은 유용한 정보가 많다.

- R.J. Williams 지음 < Biochemical Individuality > New York, Wiley, 1956년.

내과의학적 관점에서 개인별 특성을 다룬 책으로, 모든 프로그래머가 다 똑같아 보이는 환상에 시달리는 사람들이 꼭 읽어야 할 책이다.

- L. E. Tyler 지음 < The Psychology of Human Differences > 3판, New York, Appleton-Century-Crofts, 1956년

위의 책과 동일한 주제를 심리학적인 관점에서 다뤘다.

#### 7장에 보태는 글: 프로그래밍 작업의 다양성

"프로그래밍은 획일적인 한 덩어리의 행위가 아니다(262쪽)."
오늘날 프로그래밍 작업의 다양성은 누가 봐도 명확하다.

프로그래머가 요청 받은 일은 무엇이든 할 수 있다는 실험 결과를 토대로
명확한 요구 명세를 개발하고 의사소통을 잘 하는 일에 시간을 투자하면 소득이 크리라 생각했고
이 주제에 관심을 가졌던 여러 조직이 많은 이득을 얻었다.
(물론 이것이 프로그래머는 시키면 무슨 일이든 다 할 수 있음을 의미하지는 않는다)