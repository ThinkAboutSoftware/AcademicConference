### 2장 좋은 프로그램이란 무엇인가?

```
논의주제)
좋은 프로그램의 기준에 대한 각자의 생각을 이 책의 기준으로 얘기해 보면 좋겠습니다.
저도 저자의 의견에 어느 정도 동의하는 편인데, 효율성의 문제는 사실 의도적으로 혹은 의도하지 않든 성능적인 이슈나 메모리 관리 이슈 정도가 드러나지 않는다면 후순위로 해도 괜찮다고 보는 입장입니다.

그리고 이 책을 보면서 작년에 읽었던 좋은 코드 나쁜 코드에서 얘기한 코드 품질 기준에 대해서 생각해 봤을 때도 비슷해서 비교해 볼 수 있을 것 같습니다.

작동해야 한다 (요구 명세) -> 작동이 멈추면 안 된다 (요구 명세) -> 변경된 요구사항에 적응해야 한다(요구명세? 적응성?) -> 중복 구현 금지 (효율성)
```

프로그래밍 능률을 측정할 방법이 필요한데 답이 간단하지 않은 이유는 프로그래밍이 복잡한 인간 행위이기 때문이다.
1장의 예제 프로그램에서는 실제 주어진 문제와 직접적인 관련이 있는 건 20% 정도이다. 나머지는 심리적인 변화를 주면 제거할 수 있는데, 저장 용량 체크 문제도 가상 머신을 도입하면 해결할 수 있긴 하다.
1장의 예제 프로그램은 실제 주어진 문제와 관련된 비율이라는 측면에서는 평균적이다. 반대로 생각해 보면 프로그래밍 작업을 향상시킬 수 있는 방법이 있다는 뜻이 된다. 그렇다고 핵심적이지 않은 코드 비율이 작다고 해서 좋은 프로그램인건 아니다. 프로그램을 평가할 때 코드 자체만으로 좋다 나쁘다를 판단할 수 없다.

1장의 예제 프로그램은 좋은 프로그램인가? 프로그램이 좋은지 나쁜지 평가하는데 세련되거나 촌스러운 것은 절대 기준이 되기 어렵다. 프로그램 평가는 실행될 기계와 컴파일러, 비용 환경 등을 고려하지 않을 수 없다.
개발은 개획한 기간 안에 끝났는가?
비용은 얼마나 들었는가?
명세를 만족 시키는가?
단지 코드만 보고서는 이런 질문의 답을 하기는 어렵다.

프로그램의 우수성을 평가할 절대적 기준이 없는 건 큰 문제이지만, 상대적인 기준도 불가능하다. 비교 대상이 될 다른 프로그램이 존재하는가 부터가 문제이다.

상대적인 우수성을 논할 수 있는 경우가 있기는 하다. 컴파일 속도와 실행 속도가 빠른 바이너리 코드를 만드는 컴파일러가 우수할 것이다. 하지만 이것도 속도만 평가하는 것이고 진단 기능, 처리할 수 있는 언어, 바이너리 코드의 신뢰성, 모니터링 기능 등을 추가로 고려해봐야 한다. 즉, 모든 면에서 한쪽이 우수한 경우를 찾기는 극히 어렵다.

따라서 프로그램 평가는 개발 관련된 상황에 비추어 그 프로그램을 평가해야 한다. 최고의 프로그램도 아니고 우수한 프로그램도 아닌 요구 명세에 부합하는 프로그램이면 된다.

#### 요구 명세

프로그램에서 요구하는 조건 가운데 맨 처음 꼽는 요소이자 가장 중요한 것은 정확성이다.
예상 입력에 대해 기대한 출력을 내야 프로그램이 작동한다고 얘기할 수 있다.
"작동하는 프로그램이 그렇지 않은 프로그램보다 무조건 낫다"

정확성에 비하면 효율성이 부차적이라는 주장에 대해 알맞은 일화가 있다.
프로그램의 목적은 주문 요청서를 기록한 천공카드로부터 고객이 선택한 옵션을 입력 받아 그에 맞는 자동차를 만드는 데 필요한한 부품 목록을 도출하는 것이다.

16명의 프로그래머가 5000개의 가지가 달린 의사결정 나무로 동시 작업을 하고 있었기 때무에 디버깅은 불가능했고 모든 경우의 수를 테스트 하는데 정확도가 너무 떨어졌다. 평범한 입력에 타이어 8개, 좌석 3개, 엔진 없음 이라는 결과가 나오고 있었으므로 프로그램은 실패로 생각했다.

한 프로그래머가 집에 돌아가는 길에 생각을 했다. 작업을 두 단계로 나눠서 옵션 조합에 대해 원하는 결과를 미리 표로 만들어 두고(1단계), 카드로부터 옵션 데이터를 받으면 그 표에서 찾아 내용을 출력하는 것이다(2단계)

그래서 다시 돌아와 프로그램을 수정했고 시연할 때 다른 프로그래머도 참석했다.
기존 프로그램 원작자는 "프로그램 실행시간이 얼마나 걸리나요?" 라고 했고
"입력에 따라 다르지만, 카드당 평균 10초" 라고 했다.
원작자는 "내 프로그램은 카드당 1초 밖에 안 걸리는데요." 라고 의기양양하게 말했다.
하지만 우리의 젊고 순수한 영웅 프로그래머는
"하지만 그 프로그램은 작동하지 않잖아요. 프로그램이 작동하지 않아도 괜찮다면 1000분의 1초에 카드 한 장을 처리할 수 있는 프로그램도 만들 수 있어요. 1000분의 1초면 카드 판독기가 카드를 읽는 속도보다도 빠른 겁니다"

영웅 프로그래머의 말에는 프로그램을 평가할 때 토대로 삼아야 할 근본적인 진실이 담겨 있다.
즉, 프로그램이 작동하지 않는 상황에서 효율성, 적응성, 개발 비용 등의 다른 척도는 전혀 의미가 없다.
세상에 완벽한 프로그램은 없으며 프로그램을 평가할 때는 결함이 어떤 종류인가를 반드시 고려해야 한다.
프로그램이 주어진 요구 명세를 얼마나 만족시키느냐 얼마나 잘 작동하느냐가 문제가 되는 것이다.

사용자 한 명을 위한 프로그램과 진정한 소프트웨어 사이에는 엄연한 차이가 있다.
그 둘을 평가하는 방법은 서로 달라야 하고, 개발 방법도 달라야 한다.

#### 일정

요구 명세를 만족시키는 문제 다음이 효율성은 아니다. 프로그래밍에서 계속 반복되는 문제는 일정을 맞추는 일이다. 납기가 지나 완성된 프로그램은 전혀 쓸모가 없을 수도 있다. 프로그램을 사용하지 못해서 추가되는 비용과 프로그램을 더 효율적으로 만들었을 때 아낄 수 있는 비용을 비교해 봐야 한다.

프로그램 납기 지연 때문에 발생하는 손실이 그렇게 크지 않더라도 일정이 지연되면 성가신 일들이 무척 많이 생긴다.
프로젝트 관리자는 6개월 프로젝트에 9개월 걸리는 것보다는 12개월 일정인 프로젝트에 12개월 걸리는 걸 좋아한다. 이건 이미 연구 결과가 나와 있는데, 사람들은 어떤 일에 드는 시간의 평균보다 편차를 더 중요하게 생각한다. 예로 1주일에 버스를 매일 1분씩 기다리는 데 하루만 20분을 기다리는 것 보다, 매일 10분씩 기다리는 쪽을 더 좋아한다는 것이다.

이 연구 결과가 프로그래밍에도 적용된다면, 특정 개발 방법론을 연구할 때 개발 기간이 변하는 데 얼마나 영향을 끼치는지 측정해야 한다.

#### 적응성 (Adaptability)

프로그램 평가에서 요구 명세와 일정 다음이 효율성 차례라고 생각할 수 있으나 적응성 문제를 먼저 다루는게 유익하다.
대다수의 프로그램은 일정 기간 동안 생명을 유지하고 그 생명 주기 동안 수정을 하게 된다.

프로그램을 수정할 때가 되면 왜 코드를 버리고 처음 부터 새로 작성해야 겠다고 결정하는 상황이 많은 것일까?
처음부터 나중에 수정될 것을 대비해서 작성된 프로그램은 만나기 어렵다.
프로그램이 수정될 걸 알면서도 그 대비는 왜 하지 않는 것일까?
어떤 프로그램은 일부러 수정하기 어렵게 만들기도 한다. 이것도 이유가 무엇을까?

이런 의문들에 대한 답은 심리학적인 연구를 통해 찾을 수 있다. 답을 얻는 것도 중요하지만 좋은 프로그램이란 무엇인가를 논의하는 데에 이런 문제 인식이 중요한 요소라는 걸 아는 것이 우선이다. 프로그램을 쉽게 수정할 수 있도록 도울 목적이 아니라면 문서는 왜 쓸까? 문서의 질과 프로그램 수정의 용이성이 프로그램 또는 프로그래머를 평가하는 데 중요한 잣대임은 모두 인정할 것이다. 그렇기에 이 문제에 대한 심리학적인 연구를 통해 의미있는 성과를 얻을 가능성 역시 인정할 수 있게 된다.

적응성은 거저 생기지 않는다. 적응성이 뛰어난 프로그램을 만들게 된다면 보통 그만한 대가를 지물해야 한다. 가끔은 그 만큼의 성과를 얻지 못할 수도 있다.

유전자 시스템에 대한 수학적 연구에서 R. A. Fisher는 피셔의 기본정리(Fisher's Fundamental Theorem)라는 법칙을 만들었다.
이 법칙은 한 유전자 시스템이 특정 환경에 많이 적응되어 있다면 다른 새로운 환경에 적응하기는 더 어렵다는 내용이다. 상상력을 발휘하면 컴퓨터 프로그램에도 적용해볼 수 있다.

효율적인 프로그램이라면 주어진 문제와 프로그램을 실행할 기계의 특성을 잘 활용해야 한다. 그러면 프로그램을 더 빠르고 작게 만들 수 있다. 하지만 기계도 새로워진다면 프로그램도 새로운 수정을 많이 해야 한다. 특정 기교를 부려서 효율성만 추구한다면 곧 일반적인 방식이나 다른 방식에 밀리게 될 것이다. 처음부터 새 환경에 적응하기 위한 프로그램을 만들었다면 새 환경에도 약간의 노력만 하면 적응할 수 있었을 것이다.

요점은 하나이다. 효율성을 추구하면 보통은 코드가 빡빡해져서 수정하기 어렵게 된다. 고수준 언어로 작업하다가 효율적으로 만든다고 기계어로 만드는 일이 있는데, 고수준 언어로 작성하는 이점 중 다른 기계로의 이식성을 포기하는 일이다.

효율성을 외치는 관리자들에게 수정 비용 얘기를 들으면 머리를 쥐어뜯을 사람들이다.
반대로 일반적이고 수정하기 쉬운 프로그램을 요구하는 관리자들도 나중에 프로그램이 느리거나 너무 크다고 불평한다.
우리는 이 문제를 어른스럽게 처리해야 한다. 두 가지 상반되는 목표를 동시에 달성하는 데는 심리학도 마법도 소용없다.
둘 중 하나만 선택하는 게 좋은 방법이다. 적어도 둘 다 아닌 쪽 보다는 낫다.
(예쁜데 성격까지 좋은 아내에 비유)

#### 효율성

효율성은 실행하는데 필요한 시간 외에 실행 전후에 드는 시간이 컴퓨터의 실행 시간에 영향을 미친다.
1분에 처리하는 천공카드 개수의 척도라면 어셈블리가 효율적인데 어셈블리로 작성된 천공카드의 정보는 FORTRAN보다 적기 때문이다.
분당 생산해 내는 기계어 명령(instruction)의 개수 기준이라면 바이너리 코드를 필요 이상으로 크게 만들어내는 컴파일러가 가장 효율적이라는 결론이 나올 수 있다.

요구 명세를 줄이는 방법으로 효율성을 추구할 수 있다. 프로그램을 만드는데 효율성이 최우선 관심사라면 요구 명세 일부를 삭제해서 사용자 편의성이 줄어들더라도 컴퓨터의 효율성을 높일 수 있는 항목을 찾으면 된다. 하지만 사람이 소비하는 시간도 비용인데 프로그램이 작성한 보고서에 수치의 총합을 채워 넣지 않는다면 컴퓨터의 시간은 절약될 수 있지만 그 대가로 사람이 종이와 펜, 시간을 추가로 소비해야 한다.

요구 명세를 줄이는 효과는 기대했던 것 보다 반대로 나타날 수도 있다. 오류 검사 기능이 없거나 약한 컴파일러를 사용해 20%의 시간을 절약할 수 있다고 해도 그 때 검출하지 못한 오류를 프로그래머가 직접 찾아서 테스트하는데 드는 시간을 40% 더 소비할 수도 있다.

단순 스케줄링이 아닌 다중 프로그램 또는 다중 프로세스 환경일 경우는 프로그램 실행 시점에 컴퓨터 상황이 어떤지에 따라 달라질 수 있고 그 상황은 매번 다를 것이다.

동적 부하 조절 기능이 있는 시스템은 다중 프로그램으로 인해 발생하는 성능의 불안정성이 조금 줄어들 수는 있다. 단순히 컴퓨터 상의 실행 시간을 줄이는게 능사가 아니라 프로그램이 시작부터 끝까지 실행되는 전체 일정을 고려해야 한다.

컴퓨터의 성능이 발전하면서 효율성의 문제는 애매해진다. 기계 가격은 내려가지만 인건비는 올라가고 있으므로 시스템 운영비 보다 개발비가 더 크다. 시간이 지날수록 효율성(efficiency) 보다는 효용성(effectiveness)이 더 중시될 것이다.

#### 요약

좋은 프로그램이란 무엇인가라는 질문은 간단하지 않고 적절하지 않을 수도 있다.
모든 프로그램에는 나름대로 제 가치가 있으며, 그 가치도 주변 환경과 연관지어 평가해야 한다.

1. 프로그램이 요구 명세에 부합하는가/ 또는 요구 명세에 얼마나 많이 부합하는가?

```
보통 요구사항에 맞게 구현하기 때문에 요구사항 명세에 부합하는지에 대한 질문은 당황스럽긴 하다.
```

2. 일정에 맞춰 개발하였는가? 그리고 특정 개발 방법론이 일정의 어떤 요소에 영향을 줄 수 있겠는가?

```
이 질문에 대해 역사적인 관점에서 확인해 볼 필요가 있다.
책의 초판은 1971년이므로 그 당시에 유행하던 컴포넌트 기반 개발 방법이라던지 4세대 언어 개발 방법론의 관점에서 봐야 할 것이다.
그렇다면 그런 개발 방법론을 적용한다고 해서 일정에 큰 변화가 있을 것이냐를 판단해 보면 되는 데 아마 그렇지 않을 것이라는 게 대답일 것 같다.
현재도 우수한 개발 방법론과 기법은 넘쳐 흐르고 있지만 일정에 맞춰 개발이 진행되는가는 사실 별개의 문제로 보는 것이 합당할 것 같다. 
```

3. 환경이 변한다면 그에 맞춰 프로그램을 수정할 수 있는가? 그렇게 수정하는 데는 얼마나 많은 비용이 들 것인가?

```
책에서 언급된 환경의 변화는 어셈블리 명령어가 변경되는 수준의 환경인데
현재는 개발환경에 맞춰서 프로그램을 개발하기 때문에 환경이 변하면 프로그램 수정은 거의 불가능하다고 보는게 맞을 것 같다.

대신 환경을 변화시켜주는 크로스 플랫폼이라면 조금 다른 얘기일 수 있는데
프로그램을 수정하는 것이 아니라 환경에 변화를 줘서 같은 프로그램을 다른 환경에서 실행할 수 있도록 도와주는 도구를 쓴다면
비용 측면에서 많이 수고로움을 덜 수 있다.
```

4. 프로그램이 얼마나 효율적인가? 효율적이라 함은 무엇을 의미하는가? 한 부분에서 효율성을 얻고자 다른 부분에서 비효율성을 감수하고 있지 않은가?

```
책에서 얘기하는 효율성에 맞춰 생각해 보면, 현재의 프로그램의 경우는 성능 적인 부분을 고려하지 않아도 컴파일러가 효율적이거나 프레임워크 라이브러리가 효율적이기 때문에 프로그래머가 일부러 비효율적인 코드를 작성하지 않는다면 효율성 문제를 많이 고려하지는 않는다.
효율적이라 함은 보통 성능적인 개선을 얘기할텐데 현재의 컴퓨터 성능과 컴파일러의 성능은 매우 좋기 때문에 일부러 비효율적인 코드를 작성하는게 아니라면 특별히 고려하지 않는게 맞다고 본다.
```

##### 질문

###### 관리자에게 

1. 어떤 기준으로 프로그래머를 포상하는가? 판단 기준 일부가 서로 상반되지 않는가? 프로그래머에게 어떤 프로그램을 원하는 지 얼마나 명확히 말해 주는가? 빠르고, 작고, 깔끔하고, 수정하기 쉽고, 에러도 없는 프로그램을 일주일 내에 만들어 내라고 하지는 않는가?

```
보통은 일정 내에 기능이 구현된 걸 테스트해 보고 문제가 없는 걸 확인하는 걸 기준으로 삼을 수 있을 것 같다.
나 같은 경우는 우선순위로 보자면 정확성, 일관성, 가독성 등을 고려해 볼 수 있다.
프로그래머는 정확성에 대해서는 실제 구현한 걸 얘기하니까 정확하지 않은 프로그램을 만들리는 거의 없다고 보면
사실 일관성과 가독성 두 문제에 대해 언급해 볼 수 있다.
일관성은 코드 작성 규칙과 동작이 일관되어야 하고 그와 더불어 가독성을 갖추고 있다면 좋다고 본다.
모든 걸 다 완벽하게 하라고 하는 건 프로그램을 작성해 본 적이 없거나 자신도 누군가에게 압박을 당하는 상황일 수도 있다고 본다.
```

2. 운영 중인 프로그램들의 적응성은 어떤가? 프로그램을 수정하는 데 드는 비용이 시스템 운영비의 주된 요소인가? 그렇다면 수정을 어렵게 만들 요인을 개발 과정에서 미리 발견할 수 있는가?

```
보통은 그렇다고 답할 수 있다. 프로그래머는 새로 개발하는 걸 좋아하지만 기존 걸 수정하면서 개발하는 걸 즐겨하지 않는다는 점에서 시스템 운영비의 주된 요소일 가능성이 높다. 
수정을 어렵게 만들 요인을 개발 과정에서 미리 발견할 수 있는 방법으로는 설계+코드 리뷰를 하는 방법이 있을 것이고, 또 테스트 자동화를 통한 검증 방법이 있을 것이다.
```

3. 회사가 일정 준수를 얼마나 중요하게 여기는가? 오차를 허용하지 않는 편인가? 아니면 일정을 맞추기 보다는 매번 일관된 결과를 보이는 것을 더 좋게 평가하는가? 프로그래머가 일정에 맞추겠다는 일념으로 프로그램을 완전히 망쳐버릴지도 모르는 도박 같은 작업을 시도하는 이유를 이해할 수 있는가?

```
지금 다니는 회사는 일정 준수를 중요하게 여기는 편에 속한다. 그리고 결과를 평가하는데 있어서 일정이 부족한 점은 어느 정도 감안해서 판단한다. 책을 읽고 있는 나도 프로그래머이므로 일정에 맞추기 위해 막 프로그램을 작성할 법도 하지만 그러면 나중에 더 큰 고통을 감수해야 하기 때문에 일정에 맞출 수 있는 수준 까지만 기능을 구현하고 나중이 없을 정도로 프로그램을 망치는 일을 벌이지 않는다.
```

##### 프로그래머에게

1. 프로젝트를 시작할 때 어떤 명확한 기준이 있는가? 그 기준들은 당신 스스로 중요하다고 생각한 것인가, 아니면 관리자가 정한 것인가? 프로젝트가 진행되면서 그 기준들이 바뀌는가? 또는 기준들을 마음속에 확고히 새기는 나만의 방법이 있는가?

```
인수 테스트 같은 걸 얘기하는 듯 한데, 그런 기준은 아직 없다. 중요하다고 생각하는 기준은 프로그래머 보다는 관리자가 정하고 관리자가 보지 못한건 프로그래머가 정해야 하는데 그런 기준을 정하기 위해서는 경험이 많아야 할 것으로 생각한다. 프로젝트가 진행되면서 큰 기준들은 바뀌지 않겠지만 자세히 정하지 못한 기준들은 바뀔 수 있다고 본다. 기준들을 마음속에 새기는 방법으로는 문서화를 잘 해두고 히스토리 관리를 어느 정도 하면 바뀌는 기준들 속에서 협의점이라는 걸 찾아낼 수 있다고 본다. 
```

2. 프로그램을 작성할 때 나중에 그것을 수정하게 될 사람에 대해 얼마나 걱정하는가? 수정해야 하는 프로그램의 원작자를 원망한 적이 얼마나 있는가?

```
매우 주관적으로 답해 보자면 수정하게 될 사람이 자기 자신이므로 자기 자신을 걱정하는 마음을 따져 보자면 많다고 보는 편이다.
수정해야 하는 프로그램의 원작자는 항상 원망한다. 심지어 과거의 자신도 원망하는 경우도 있다.
```

3. 효율성을 추구하다가 일을 망쳐본 적이 있는가? 일을 제대로 하기보다는 그저 데드라인을 지키는 것에만 신경 쓴 적이 있는가?

```
그런 일은 거의 없었다. 동작하지 않는 기능을 구현한다는 것 부터가 생각하기 어려운 사실이고, 데드라인만 지키고 효율성만 추구한다는 건 열심히 했지만 결과는 없다 식의 개념이므로 그렇게 일하지 않는다.
```

##### 참고 문헌

- Ronald A. Fisher < The Genetical Theory of Natural Selection > New York, Dover Publications, 1958

피셔의 기본 정리는 이 책의 2장을 참고한다.

- G. M. Weinberg < PL/1 Programming>의 A Manual of Style에서 New York, McGraw-Hill, 1970

4장에 좋은 프로그램을 선별하는 많은 기준 간의 절충에 대해 논의한다.

#### 2장에 보태는 글: 좋은 프로그램이란 무엇인가?

코드의 품질을 평가하는 방법을 결정하는 새로운 요소 가운데 가장 큰 것은 경제적인 요소다.
와인버그는 프로그래머로 일할 당시 작성했던 운영체제 코드 대부분을 무상으로 배포했기에, 이런 경제적 평가는 미심쩍게 여길 수 있다.
프로그램을 만드는 목적이 돈이라면 가장 큰 돈을 버는 프로그램을 만든 사람이 요구사항을 잘 구현했으므로 최고의 프로그래머이다.

천공카드 판독기 얘기는 너무 옛날 이야기가 되엇다. 하지만 입력 장치가 어떻게 발전했든 핵심은 여전히 유효하다.
품질은 특정 사람을 기준으로 판단하므로 그 시대의 프로그래머는 기능의 적합성 보다 속도가 더 중요한 가치였다면 그런 선택을 왜 하게 됐는지 설명할 수 있다.

성차별적인 표현은 시대가 변한 걸 언급한다. 70년대는 성차별이 아니었지만 90년대 부터는 성차별일 수 있으므로 의도적으로 책 내용에 배제했을 것이다.

많은 관리자는 모든 걸 다 원하고 있다. 능력 범위 안에서 최선의 제품을 만드려면 트레이드 오프가 필요한데 그걸 모르고 있다.