* Part 4. Programming Tools
    * Chapter 11. Programming Languages
        * Q. 가장 선호하는 프로그래밍 언어는 어떤 언어인지, 이유와 함께 알려주세요.
        * PROGRAMMING LANGUAGE AND NATURAL LANGUAGE
            * 프로그래밍 언어와 자연어의 차이에 대해서 설명
                * Note
                    * Hockett이 제시한 자연어의 design feature에 따라 설명
                * Communication Mode
                    * 프로그래밍 언어는 Text 형태로 이루어지며, 자연어의 말하기-듣기 채널(vocal-auditory)이 부족하다. 그로인해 코드를 시각 자료 없이 논의하기 어렵다.
                * Erasability
                    * 자연어의 경우는 "빠르게 사라지는"(rapid fading) 경향이 있지만, 프로그래밍의 경우에는 명시적으로 지워야한다.
                * Directional Communication
                    * 프로그래밍은 방향성이 있는 의사 소통 (한 명의 보내는 사람, 여러 명의 받는 사람)인 반면, 자연어는 종종 broadcast 형태 (모든 방향으로)로 이루어진다.
                * Interchangeability
                    * 자연어를 사용하는 사람은 일반적으로 말하는 내용을 모두 이해하고 만들 수 있습니다. 하지만 프로그래밍 언어에서는 이러한 상호 교환성이 보장되지 않는다.
                    * Q. 이 부분에 대해서 이해를 잘 못했는데. 같은 컴파일러를 쓰면 상호 교환성이 유지되는 것 아닐까요?
        * PROGRAMMING LANGUAGE DESIGN
            * 프로그래밍 언어 설계는 인간과 기계의 의사소통 격차를 메우는 역할을 하며, 효과적인 설계를 위해서는 프로그래머의 심리적 특성을 고려해 한다.
            * Key lessons
                * Adaptability is Key
                    * 프로그래머는 기계의 변덕에 맞추어 계속 적응해야한다. 반면, 기계는 덜 flexible 하기에, 프로그래밍 언어가 인간의 사고 방식과 실행 방식 사이의 간극을 메우는 역할을 해야한다.
                * Familiarity Breeds Attachment
                    * 특정 언어제 시간과 노력을 투자 많이하면, 그 언어에 대한 애착이 형성된다. 그로인해 새로 언어를 배우는게 어려워 질 수 있다.
                * Early Education Can Be Limiting
                    * 지나치게 단순한 프로그래밍 언어를 일찍부터 교육하면, 다양한 언어 설계 가능성에 대한 시야를 제한할 수 있다.
                * Understanding Why Programmers Act
                    * 더 나은 언어를 설계하려면, 프로그래머가 "왜" 특정 방식으로 코드를 작성하는지 이해해야한다.
                * It's a System, Not Just the Language
                    * 프로그래머의 효율성은 단순히 언어 스펙 뿐만아니라 다양한 자원에 영향받는다. 튜토리얼, 컴파일러 피드백, 커뮤니티 지원 등.
                * Programmer Psychology is Essential
                    * 컴퓨터와 사람은 다른 존재이기 때문에 인간의 사고과정을 이해하는게 프로그래밍 언어 설계에 도움이 된다.
    * Chapter 12. Some Principles For Programming Language Design
        * Q. Functional programming 언어를 현업에서 활용하시나요? 혹서 어떤 장점이 있어서 쓰셨나요? 반대로 사용을 안하시면, 왜 안하시는지 공유해 주실 수 있나요?
        * UNIFORMITY (일관성)
            * 동일한 작업을 동일한 방식으로 수행하도록 설계되어야한다..
            * 규칙의 예외는 언어 학습을 어렵게 만들고 오류 가능성을 증가시킨다.
                * javascript의 equality check이 생각났습니다.
                    * https://www.jstips.co/en/javascript/why-you-should-use-Object.is%28%29-in-equality-comparison/
            * 동일한 구문이나 키워드를 다른 용도로 사용하지 마십시오. 이는 혼란을 야기한다.
            * 문자 집합 제한이 일관성을 어떻게 감소시킬 수 있는지 인식해야 합니다
        * COMPACTNESS (간결성)
            * 일반적으로 짧고 간결한 코드는 길고 자세한 코드보다 이해하기 쉽다.
            * 약어, 함수, 데이터 구조와 같은 언어 기능을 사용하여 코드 간결성을 향상 시킬 수 있다.
            * 대부분의 사용자에게 도움이 되는 경우 일반적인 사용 사례에 대한 기본값을 고려하십시오.
        * LOCALITY AND LINEARITY (근접성과 순차성)
            * 프로그래밍의 가독성, 유지 관리성을 높이고 오류를 줄이기 위해서는 지역성(관련 코드를 함께 유지), 명확한 명명 규칙, 선형 구조, 신중한 변수 선언을 우선시하고 비 로컬 부작용을 인지해야 합니다.
                * 지역성을 활용해서 이해하기 쉬운 코드를 만들자
                * 효과적인 명명 규칙을 이용하자
                * 선형성을 통해 프로그램의 흐름을 개선하자
                * 가능한 변수 선언을 사용하는 코드 블록에 가깝게 하자.
                * 숨겨진 side effect를 조심하자.
                * 코드 언어 기능을 활용해서, 깔끔한 코드를 만들자.
        * TRADITION AND INNOVATION
            * 기존 언어와 비슷하게 만들어서 학습 곡선을 완만하게 만드는 동시에, 언어의 유연성과 새로운 기능추가의 트레이드 오프를 잘 고려해야 한다.
        * SPECIAL-PURPOSE, MULTIPURPOSE, AND TOY LANGUAGES
            * 특정 응용 분야를 위한 특수 목적 언어가 있다. 다른 더 큰 문제를 해결하는 사용자의 능력을 제한 할 수도 있다.
    * Chapter 13. Other Programming Tools
        * Q. 일반적으로 개발할 때, 어떤 IDE, 테스트 툴, 운영체제를 사용하시나요?
        * PROGRAM TESTING TOOLS
            * 일관성, 지역성 및 간결성을 통해 많은 프로그래밍 오류를 방지할 수 있다.
            * "excellent" 한 초기 결과를 고려하여 나머지 테스트를 우회하고 싶은 유혹을 피해야 한다. 이를 위한 테스트 케이스에 향상 작업은 소중하다. 테스트 시스템은 프로그래머가 수행할 테스트의 양을 지정하도록 요구함으로써 이러한 유혹을 견뎌낼 수 있도록 도울 수 있습니다.
            * 프로그래머가 특정 코드에 너무 stuck되 있으면 다른 코드 영역을 살펴보도록 돕기 위해 자동화된 장치가 있으면 유용하다.
        * OPERATING SYSTEMS
            * 디버깅 도구의 위치:
                * 디버깅 도구는 프로그래밍 언어의 일부가 되어야 하는가, 아니면 운영 체제에서 처리해야 하는가?
                * **언어 기반 도구 사용 주장**: 프로그래머에게 친숙하고 사용하기 쉬움.
                * **운영 체제 기반 도구 사용 주장**: 프로그래머에게 운영 체제를 노출시켜 실제 문제 및 오류 해결에 중요함.
                * **타협**: 운영 체제 현실을 직면하는 데 도움이 되는 언어 확장, 그러나 이러한 확장은 언어 내에서 일관성과 균일성을 위해 설계되어야 함.
            * 작업 제어 언어 취지이ㅠ
                * 위지 매개변수 vs 키워드 매개 변수
            * 성능 측정의 중요성
            * 처리 시간 관리
                * 불확실성은 해롭다: 예측 불가능한 처리 시간은 생산성과 계획을 방해
        * TIME-SHARING VERSUS BATCH
            * 성공은 단순히 타임 셰어링 대 배치 처리의 장점에 집중하는 것보다 개별 프로그래머의 행동과 문제 해결 스타일을 이해하는 데 더 달려 있습니다.
        * DOCUMENTATION
            * 문서화는 잘 해야만 가치가 있다. 효과적인 문서화는 프로그래머에게 유익하다는 명확한 목표를 가지고 만들어야 한다.
            * 모든 사람을 만족시키는 문서화는 없다. "적당히 좋은" 문서화를 목표로 하고, 범위와 대상 독자를 명확하게 정의해야 한다.
            * 문서화는 복잡한 것을 순식간에 이해시킬 수 없다. 문서화는 독자가 자신이 필요한 지식을 가지고 있는지, 더 깊이 알아보기 위해 어디를 찾아야 하는지를 판단하는 데 도움을 주어야 한다.
            * 코드 자체의 "살아있는 문서"를 과소평가하지 마라.