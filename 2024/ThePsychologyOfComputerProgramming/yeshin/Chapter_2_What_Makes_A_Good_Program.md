## 2장 좋은 프로그램이란 무엇인가?

- 프로그램을 평가할 때 코드 외적인 요소들이 존재하기 때문에 코드 자체만으로 좋다 나쁘다를 판단할 수 없다.
  
  - 프로그램 개발은 계획한 기간 안에 끝났는가?

  - 개발 비용은 얼마나 들었는가?

  - 주어진 명세를 만족시키는가?

- 항상 비교 대상이 될 다른 프로그램이 없는 것처럼 상대적인 척도로 프로그램을 평가하는 것 또한 불가하다.

- 즉, 개발에 관련된 모든 상황에 비추어 그 프로그램을 평가해야 한다.

> 우리가 원하는 것은 요구 명세에 부하하는 프로그램이다.

### 요구 명세

- 어떤 프로그램에 요구하는 조건 가운데 가장 중요한 것은 정확성이다.

- 예상되는 범위 내의 입력을 주면 정확한 출력을 내야 하는데 이를 프로그램이 **작동**한다고 말할 수 있다.

- 작동하는 프로그램이 그렇지 않은 프로그램보다 무조건 낫다.

- 프로그램이 작동하지 않는 상황에서 효율성이나 적응성, 개발 비용 등의 다른 척도는 전혀 의미가 없다.

- 세상에 완벽한 프로그램은 없으므로 프로그램이 주어진 요구 명세를 얼마나 만족시키느냐 즉, 얼마나 잘 작동하느냐가 문제다.

- 사용자 한 명을 위한 프로그램과 진정한 **소프트웨어** 사이에는 엄연한 차이가 있다.

  - 사용자가 여럿이면 요구 명세도 여럿이 되고 이는 그 프로그램의 **작동**에 대한 정의도 여러 개가 된다.

- 개발 방법론을 논의할 때, 대상이 사용자 한 명인지 여럿인지에 대한 프로그램의 차이를 염두하면서 그 둘을 평가하는 방법과 개발 방법이 달라야 한다.

### 일정

- 프로그래밍에서 계속 반복되는 문제는 일정을 맞추는 일이다.

- 납기가 지나 완성된 프로그램은 전혀 쓸모 없을 수 있다.

- 적어도 프로그램을 사용하지 못해서 추가되는 비용과 그 프로그램을 좀 더 효율적으로 만들었을 때 아낄 수 있는 비용을 비교해봐야 한다.

- 사람들은 어떤 일에 드는 시간의 평균보다 편차를 더 중요하게 생각한다.

- 특정 개발 방법론을 연구할 때 지금처럼 평균 시간만 재는 것이 아닌, 개발 기간이 변하는데 얼마나 영향을 끼치는지 측정해야 한다.

### 적응성

- 프로그래머가 작성한 프로그램들은 일정 기간 동안 생명을 유지하는데 이 생명 주기 동안 무조건 **수정** 과정을 겪는다.

- 처음부터 나중에 수정될 것을 대비하여 작성된 프로그램은 좀처럼 없기 때문에, 기존 코드를 버리고 처음부터 새로 작성해야겠다고 결정하는 케이스가 많다.

- 프로그램 수정은 피할 수 없다는 것을 알면서도 그에 대한 대비는 하지 않는 이유는 무엇일까?

    ```
    데드라인, 비용 이 두 가지가 가장 크지 않을까 싶다.
    
    프로그래머의 역량도 있을 수도 있고.
    ```

- 좋은 프로그램이란 무엇인가를 논의하는 데에 이런 문제 인식이 중요한 요소임을 아는 것이 우선이다.

- 적응성은 거저 생기지 않는다.

- 피셔의 기본 정리(Fisher's Fundamental Theorem) 법칙에 의하면, 한 유전자 시스템이 특정 환경에 많이 적응되어 있을수록 다른 새로운 환경에 적응하기는 더 어렵다.

- 프로그램을 효율적으로 동작하게 만들려면 주어진 문제와 프로그램을 실행할 기계의 특성을 잘 활용해야 한다.

- 효율성을 추구하면 보통은 코드가 **빡빡해져서** 수정하기 어렵게 된다.

- 효울성과 적응성은 상반되므로 상황에 따라 처리해야한다.

### 효율성

- 컴퓨터에서 실행시키는 데 필요한 시간만이 효율성의 전부가 아니다.

- 실행 전후에 드는 시간이 컴퓨터의 실행 시간에 영향을 미칠 수 있다.

- 컴파일러의 효율성에는 수많은 척도가 있으므로 효율성 문제로 인해 범할 수 있는 실수를 설명하는 데 좋은 예시가 된다.

- 언어의 사소한 차이로도 컴파일러의 효율성은 크게 달라질 수 있다.

- 컴파일러 개발자가 언어의 기능 중 10%만 포기하면 컴파일러의 속도를 2배로 빠르게 만들 수 있지만,

- 기계나 컴파일 기교에 따라 그 10%가 달라지므로 언어 설계자는 언어의 **좀 더 효율적인** 부분 집합을 제시할 수 없다.

- 다른 분야에서도 요구 명세를 일부 줄이는 방법으로 비슷한 효율성 향상을 꾀할 수 있다.

- 어떤 프로그램을 만드는 데 최우선인 관심사가 효율성이라면 요구 명세 중, 삭제하면 사용 편의성이 줄더라도 컴퓨터의 효율성은 높일 수 있는 항목을 찾으면 된다.

- 컴퓨터가 소비하는 시간뿐만 아니라 사람이 소비하는 시간도 비용이다.

- 요구 명세를 줄이는 효과는 기대했던 것과 반대로 나타날 수도 있다.

- 사용자가 프로그램에 원하는 것은 빠른 평균 실행 시간이 아니라 편차가 작은 실행 시간일 수도 있다.

- 그래야 자신의 작업을 계획할 수 있기 때문인데, 이것이 사실이라면 작업의 시작부터 끝까지의 전체 일정을 고려해야 한다.

- **컴퓨터 상의 실행 시간**만 줄인다고 능사는 아니다.

- 컴퓨팅에서 효율성의 문제는 점점 더 애매해지고 있고, 시간이 지날수록 **효율성**보다 **효용성**이 더 중시될 것이다.

### 요약

- 모든 프로그램은 나름대로 제 가치가 있다.

- 그 가치는 주변 환경과 연관지어 평가해야하기 때문에 좋은 프로그램이란 무엇인가에 대한 질문은 간단하지도 적절하지도 않을 수 있다.

- 다만 중요한 고려 사항은 몇 가지 존재한다.

    1. 프로그램이 요구 명세에 부합하는가? 또는 요구 명세에 얼마나 많이 부합하는가?

    2. 일정에 맞춰 개발하였는가? 그리고 특정 개발 방법론이 일정의 어떤 요소에 영향을 줄 수 있겠는가?

    3. 환경이 변한다면 그에 맞춰 프로그램을 수정할 수 있는가? 그렇게 수정하는 데는 얼마나 많은 비용이 들 것인가?

    4. 프로그램이 얼마나 효율적인가? 그리고 그 효율적이라 함은 무엇을 의미하는가? 한 부분에서 효율성을 얻고자 다른 부분에서 비효율성을 감수하고 있지는 않은가?

- 이 책에서만큼은 **좋은 프로그램** 혹은 **좋은 프로그래머**라는 개념을 모두가 동의하는 것 또는 동의할 수 있는 것 또는 동의해야만 하는 것처럼 쓰지 말아야 할 것이다.

### 질문

#### 관리자에게 

```
이 질문에 대한 답은 몇 년 후에 할 수 있을 것같다.
```

1. 어떤 기준으로 프로그래머를 포상하는가? 당신의 판단 기준 일부가 서로 상반되지 않는가? 효율적인 동시에 일반적이기까지 한 프로그램을 요구하는 경우처럼 말이다. 프로그래머에게 어떤 프로그램을 원하는 지 얼마나 명확히 말해 주는가? 빠르고, 작고, 깔끔하고, 수정하기 쉽고, 에러도 없는 프로그램을 일주일 내에 만들어 내라고 하지는 않는가?

2. 운영 중인 프로그램들의 적응성은 어떤가? 프로그램을 수정하는 데 드는 비용이 시스템 운영비의 주된 요소인가? 만약 그렇다면, 수정을 어렵게 만들 요인을 개발 과정에서 미리 발견할 수 있는가?

3. 당신의 직장은 일정 준수를 얼마나 중요하게 여기는가? 조금도 오차를 허용하지 않는 편인가? 아니면 어쩌다가 일정을 맞추기보다는 매번 일관된 결과를 보이는 것을 더 좋게 평가하는가? 프로그래머가 일정에 맞추겠다는 일념으로 프로그램을 완전히 망쳐버릴지도 모르는 도박 같은 작업을 시도하는 이유를 이해할 수 있는가?

#### 프로그래머에게

1. 프로젝트를 시작할 때 어떤 명확한 기준이 있는가? 그 기준들은 당신 스스로 중요하다고 생각한 것인가, 아니면 관리자가 정한 것인가? 프로젝트가 진행되면서 그 기준들이 바뀌는가? 또는 기준들을 마음속에 확고히 새기는 **나만의 방법**이 있는가?

    ```
    작업 대부분 긴급하지 않았기 때문에 마감 기한에 대한 중요성에 대해 잘 인지하지 못하고 있었다.

    시간이 좀 더 걸리더라도(일정을 지키지 못하더라도) 다른 사람들이 자세하게 보지 않아도 잘 동작하고 가독성있는 프로그램을 만드는 것이었다.

    하지만 스프린트를 진행하면서 정해진 마감 내에 마쳐야한다는 중요성 사실을 깨달았다.
    ```

2. 프로그램을 작성할 때 나중에 그것을 수정하게 될 사람에 대해 얼마나 걱정하는가? 당신이 수정해야 하는 프로그램의 원작자를 원망한 적이 얼마나 있는가?

    ```
    동료들의 꼼꼼한 코드 리뷰와 이슈에 관련된 정보는 jira나 notion, PR에 관련 히스토리를 남겨서 큰 걱정은 없다.

    나 또한 과거의 내가 짠 코드를 보면 갖다 버리고 싶을 정도로 별로라는 생각을 하기 때문에 원망하지는 않는다.

    만약 원작자의 의도가 이해가 가지 않으면 (원작자가 주변에 있다면) 직접 의도를 물어보면서 작업해왔다.
    ```

3. 효율성을 추구하다가 일을 망쳐본 적이 있는가? 일을 제대로 하기보다는 그저 데드라인을 지키는 것에만 신경 쓴 적이 있는가?

    ```
    익숙하지 않은 디버깅 툴을 사용하려다 이도 저도 아니게 돼서 하루를 날린 적이 있다.

    데드라인을 지키기 위해 QA를 부족하게 진행하거나 코드 리뷰에서 언급한 부분만 수정하는 등 숲이 아닌 나무만 본 적도 있다.
    ```

### 참고

- The Genetical Theory of Natural Selection

    - 피셔의 기본 정리에 대해서는 이 책의 2장을 참고하면 좋다.

- PL/1 Programming>의 A Manual of Style에서

    - 이 책 4장에 **좋은 프로그램**을 선별하는 많은 기준 간의 절충에 대해 논의한다.

### 2장에 보태는 글

- 코드의 품질을 평가하는 방법을 결정하는 새로운 요소 가운데 가장 큰 것은 경제적 요소다.
- 많이 팔리고 큰 수익을 내는 프로그램이 그렇지 못한 프로그램보다 나은 것이 명백하다.
- 솔직히 말해서 프로그램을 만드는 목적이 돈이라면 가장 큰 돈을 버는 프로그램을 만든 사람이 확실히 최고의 프로그래머다.
- 요구사항을 가장 잘 구현했으므로.
- 품질은 특정 사람을 기준으로 판단되는 것이다.
- 그 시대의 프로그래머에게는 기능의 적합성보다는 속도가 훨씬 더 중요한 가치였다.
- 많은 관리자가 적절한 트레이드오프(trade-off)가 필요함을 여전히 모른다.

<hr>

### 느낀점

- 1장도 그렇고 이번 장도 흥미롭게 읽었다. 재밌었다.

- 좋은 프로그램이란 무엇인가에 대해 많은 사람들이 의견을 주고 받고 생각하지면 결국 사바사, 케바케라는 걸 깨달았다.