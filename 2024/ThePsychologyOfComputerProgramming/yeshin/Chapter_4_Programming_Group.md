# 2부 사회 활동으로 보는 프로그래밍

> 목표는 수많은 의지가 모여 만드는 모진 노력으로만 성취할 수 있다.
> 프로그래머의 집단을 그룹과 팀, 프로젝트, 이렇게 세 가지로 구별할 것이다.
> 그룹은 같은 장소에서 일하는 프로그래머 집단이다.
> 한 그룹에 속한 프로그래머들은 같은 기계와 시스템을 공유하겠지만, 몇 개의 프로그램을 나눠 맡고 있을 것이다.(일부 프로그램은 서로 어떤 연관성이 있을 수도 있다.)
> 전형적인 프로그래밍 그룹은 대학 전산 센터나 엔지니어링 회사 등에서 볼 수 있다.
> 프로그래밍 팀은 한 프로그램을 개발하기 위해 함께 일하는 프로그래머 집단이다.
> 팀은 한 프로그래밍 그룹에 속할 수도 있고, 프로그래밍 프로젝트를 구성하는 여러 팀 중 하나일 수도 있다.
> 프로젝트는 프로그래머 그룹에 하나로 통합된 시스템(또는 적어도 긴밀하게 짜인 프로그램들)을 만들어 내는 지원 활동을 더한 것이다.
> 프로젝트에는 보통 전용 기계가 있고, 더불어 시스템 작업, 표준화, 문서화 등의 부차 기능을 담당하는 특별 팀들이 포함된다.
> 그리고 보통 프로젝트 관리자와 관료주의적인 정규 조직(흡사 군대 같은)도 추가된다.

### 2부에 보태는 글

- **프로그래밍 팀이란 더 나은 제품들을 만들기 위해 함께 일하는 프로그래머들의 모임**이다.
- 팀은 제품을 만들기 위해 구성원들이 함께 일한다는 점에서 그룹과 차별된다.
  - 이 때 제품이란 프로그래머가 각자 따로 일해서는 만들 수 없거나 또는 팀을 이룰 때만큼 효율적으로 만들 수 없는 수준의 것을 의미한다.
- 팀과 그룹의 차별성은 구성원들의 배우는 방식에 있다.
- 어떤 공통의 목표 덕분에 그룹의 구성원들도 함께 배우게 되는 일이 있다.
- 그 공통의 목표가 제품이라면 상호 배움으로 연결되지 않는다.
- 반면 팀에게는 항상 공통의 목표 즉, 구성원들이 서로 가르치고 배워 각자 더 나은 능력을 가질 수 있도록 한다는 목표가 있다. 제품과는 상관없이 말이다.

> 건전한 팀엑는 스스로 영속시키는 데 있다고 본다.
> 
> 그런 팀의 구성원 중 하나가 또 다른 팀을 만들어 원래 팀에서 배웠던 가치와 관습을 이어가는 것이다.

## 4장 프로그래밍 그룹

- 프로그래밍 그룹을 연구하는 것은 다른 형태의 프로그래밍 조직을 이해하는 데 중요하다.
- 프로그래머들을 공식적인 팀 또는 프로젝트로 조직화한다 해도, 그 내부에서는 비공식적인 관계들이 **비구조적인** 그룹에 있는 만큼이나 많이 생겨난다. 

### 공식 조직과 비공식 조직

- 사람 사이의 상호관계는 결코 좁지도 단선적이지도 않다.
- 그리고 조직도에 나와 있는 방향대로만 이뤄지지도 않는다.
- 공식적인 구조만이 어떤 조직 내의 유일한 구조라는 생각이 수많은 커다란 실수들을 빚어왔다.
- 물론 프로젝트에서 비공식 구조는 대부분 작업의 구조에 따라 영향을 받아 결정된다.
- 그 프로젝트가 얼마나 잘 조직화되었느냐에 따라 조직도에 가까운 모습이 될 수도 있다.
- 그러나 비공식 구조는 항상 기존 공식 구조의 기능을 정정하고 보완하는 방향으로 자라난다(그것이 순전히 프로그래머 개인이 노력한 결과일지라도).
- 상위의 결정권자가 꽤나 현명하다면, 가끔 그런 개혁적인 ㅣ공식 구조가 공식화되기도 한다(고스란히 옮겨지지는 않을지라도).
- 공식적인 세 시스템이 비공식적인 기존 시스템을 완전히 대체한 것은 아니다.
- 공식적인 것과 비공식적인 것 사이에 일어나는 충돌이 항상 이렇게 행복한 결말로 끝나는 것은 아니다.
- 비공식적은 조직은 항상 존재하며 그것을 깊이 이해하지 않은 상태에서 바꿔 버리면 위험하다.
- 그렇게 하면 원활하게 돌아가던 전체 시스템을 교란시키는 꼴이 된다.
- 또한 깊이 이해하지 못했으므로 그 비공식적인 조직을 비슷한 비용의 공식적인 조직으로 대체할 수도 없다.
- 그런 교란 가운데 많은 경우가 물리적인 배치를 변경하여 발생한다.

### 물리적 환경과 사회적 조직

- 물리적 환경이 프로그래밍 작업의 양과 질에 영향을 끼친다.
- 산업심리학에서와 달리 이때의 물리적 환경은 소음이나 빛, 온도등의 요소가 아닌 작업 공간의 배치를 말한다.
- 프로그래머들의 자리를 한군데로 모아 놓으면 분명 중요한 이점이 생긴다.
  - 사무실에 일반적으로 설치하는 파티션이 프로그래머의 생산성에 미치는 악영향은 누군가가 연구해 봐야 할 주제다.
  - 파티션은 방해가 되는 소음이나 움직임은 그대로 놔두고 효율적인 의사소통만 방해한다.
- 우리가 관심가져야 할 부분은 작업 공간의 배치가 사화적인 상호작용에 미치는 영향이다.
- 그 상호작용이 다시 작업 결과에 영향을 주기 때문이다.
- 개인에게 결과를 토오해주는 서비스가 생기자 프로그래머가 고립되어 점점 더 이와 같은 상호작용을 할 수 없게 되어 버렸다.
- 그리고 단말기 시스템으로 원격에서 작업을 할 수 있게 되었으니 고립이 더 심해질 것이다.

### 프로그램의 오류와 프로그래머의 자아

- 아래의 생각들은 프로그래밍을 향상시키는 데에 가장 무서운 장벽이다.
  - 프로그래밍은 아마 다른 어떤 직업보다도 더 개인의 행위다.
  - 프로그래밍은 다른 사람이 아닌, 프로그래머 자신의 능력에 좌우된다.
  - 하루 동안 다른 프로그래머와 얼마나 많이 교류하느냐는 것이 무슨 의미가 잇을까?
  - 이렇게 물어본다면, 아마도 대부분의 프로그래머는 고정된 장소에서 다른 사람의 방해를 받지 않고 혼자 일하는 편이 더 좋다고 답할 것이다.
- 실제로 사람들이 프로그래밍에 대해 갖고 있는 일반적인 인상이 그러하다면,
- 사람들은 다른 사람과 함께 일하는 것을 얼마나 선호하느냐에 따라 프로그래밍을 업으로 삼을지 말지를 결정하게 될 것이다.
- 사회심리학에 따르면 개인의 성격에는 여러가지 유형이 있다고 한다.
- 개인의 성격 유형은 세 가지 차원으로 측정할 수 있다.
  - 고분고분함: 다른 사람고 ㅏ함께 일하고 도움이 되기를 좋아하는 것.
  - 공격적: 부와 특권을 얻기를 바라는 것.
  - 고립적: 창의성을 발휘할 수 있도록 홀로 일하기를 바라는 것.
- 모든 사람에게는 이 세가지 성향이 모두 존재하지만 대부분의 사람들은 그 중 한 성향이 두드러지게 발현된다.
- 프로그래머는 대다수 고립적인 성향이 강하다.
- 이는 개인적인 선택 때문이기도 하지만 그런 성향을 원하는 고용 방침 때문이기도 하다.
- 물론 프로그래밍 업무에서 상당 부분이 홀로 그리고 창조적으로 해야 하는 것이므로 그런 프로그래머를 선택하는 편이 어느 정도는 좋다.
- 그러나 프로그래머의 **고립성**은 종종 너무 지나칠 때가 있다.
- 프로그래머는 사람들에게서 고립되는 대신에 자신의 프로그램에 애착을 둔다.
- 공식적으로 프로그램에 창작자 이름의 가호를 내리지 않더라도, 프로그래머들은 어떤 프로그램이 누구의 것인지 안다.
- 자신이 작성한 프로그램을 **자신의 것으로 여기는** 데 무슨 문제가 있는가?
- 화가, 작가, 건축가는 사람들에게서 존경을 받고 실력이 조금 떨어지는 사람들은 그 훌륭한 작품을 모방해 발전한다.
- 사람들이 프로그램을 읽는다면 위와 같이 발전하겠지만 사람들은 프로그램을 읽지 않는다.
- 따라서 어떤 프로그래머를 흠모한다고 해서 그 프로그래머의 작품을 모방하게 되지 않는다.
- 단지 매너리즘만 부추긴다.
- 이는 예술계에서 흔히 나타나는 현상과 같은데, 모두 어떤 화가처럼 보이는 방법은 알고 있지만, 그 화가처럼 그리는 방법을 아는 사람은 거의 없다.
- **누구의 것이냐를 중시**하는 프로그래밍에서 나타나는 실질적인 문제점에는 또 다른 원인이 있다.
- 그림이나 소설, 건물이 열등하다는 생각은 취향의 문제인 반면, 어떤 프로그램이 열등하다는 생각은 적어도 잠재적으로 객관적인 증명 도는 반증이 가능하다.
  - **좋은 프로그램**을 정의하기가 어렵다는 사실을 차치하고.
- 최소한 우리는 프로그램을 컴퓨터에서 실행해 나오는 결과를 볼 수 있다.
- 화가는 경우에 따라 비판을 수용하지 않을 수 있지만 프로그래머가 컴퓨터의 판단을 무시할 수 있을 까?
- 표면상ㅍ컴퓨터의 판단에는 의심할 여지가 없다.
- 그렇다면 자기 프로그램에 대한 프로그래머의 애착은 자화상에 심각한 손상을 남길 수 있다.
- 사회심리학자 페스팅거(Festinger)를 필두로 해서 인지부조화(congnitive dissonance) 심리 현상의 실체를 규명하기 위해 이뤄진 실험은 전형적으로 다음과 같았다.
  - 피실험자에게 자신이 강하게 부정하는 논제를 긍정하는 방향으로 논증하는 글을 쓰도록 한다.
  - 피험자들을 두 그룹으로 나누고 한 그룹에는 답례로 1달러를, 다른 그룹에는 20달러를 주기로 한다.
  - 실험 후에 피험자들의 의견을 다시 조사하면
  - **상식적으로는** 20달러(의견을 바꾸는 대가)를 받는 사람들이 자신의 의견을 바꿀 가능성이 더 높아보인다.
  - 그러나 인지부조화 이론에 따르면 1달러를 받은 사람들이 더 많이 자신의 의견을 바꿀 것이다.
- 인지부조화 이론의 배경에 있는 요지는 간단핟.
- 이 실험에서 피험자들은 평소에는 절대 하지 않을 행동을 해야 했다.
- 자신이 믿지 않는 것을 주장하는 행동을 **위선**이라고 한다.
- 위선은 사회적으로 좋게 평가되지 않는다. 따라서 **부조화** 상황이 발생한다.
- 이론에 따르면, 사람은 이런 부조화 상태에서 매우 불편하고 불안함을 느낀다.
- 따라서 어떤 식으로든 빨리 해소해야 하는데, 부조화를 해소하려면 그것을 이루는 요소 중 하나 이상을 포기해야 한다.
- 어떤 요소가 희생될지는 상황에 따라 다르겠지만, 일반적으로 볼 때 개인의 자화상만은 절대로 포기하지 않는다.
- 자화상은 기적적인 과정을 통해 살아남는다.
- 앞의 실험에서 20달러를 받은 사람들은 단지 돈을 벌려고 그랬을 뿐이라고 자신의 부조화 상황을 쉽게 해소한다.
- 돈을 받기 위해 자신의 의견에 반하는 글을 쓰는 일도 그다지 바람직하지 않지만, 자신의 믿음을 스스로 의심하게 되는 것보다 훨씬 낫다.
- 반면 1달러를 받은 사람들은 1달러가 그들에게 그리 의미 있는 돈이 아니기 때문에, 20달러를 받은 사람들과 같은 자기 위안은 소용이 없다.
- 그들은 부조화를 다른 방법으로 해소해야 한다.
- 그들 대다수에게 가장 쉬운 방법은 자신이 반대하는 의견에도 어느 정도 타당성이 있음을 인정하는 것이다.
- 그래서 그런 글을 쓰는 것은 위선이 아니라, 양쪽 의견을 모두 살핌으로써 공평하고 정직한 마음을 기르려는 훈련이었다고 주장한다.
- 자동차 구입과 같이 큰돈을 지출한 후의 심리를 예측할 수 있는데, 
  - 포드를 구입한 사람에게 자동차 광고 한 뭉치를 읽으라고 주면, 그 사람은 거의 포드 광고만 볼 것이다.
  - 이는 부조화에 빠질 가능성이 있을 경우 그 원인이 될 수 있는 정보를 일부러 피하는 예시다.
  - 방금 포드를 구매한 사람은 시보레가 더 좋은 차라는 내용을 보고 싶어하지 않는다.
  - 그러기 위한 가장 좋은 방법은 시보레의 광고를 피하고 포드 광고만 보는 것이다.
  - 포드 광고에는 포드를 구입한 자신이 가장 현명한 소비자였다고 확신할 수 있는 내용으로만 가득할 테니 말이다.
- 자신의 프로그램이 자아의 외연이라고 진심으로 믿는 프로그래머는 프로그램에 있는 모든 오류를 찾아내려 하지는 않을 것이다.
- 오히려 그 프로그램의 정확성을 증명하려 노력할 것이다.
- 모든 프로그래머는 이런 부조화에 매우 익숙하다.
  - 프로그램이 전혀 동작하지 않았다고 할 때, 그 사실을 숨길 수 없을 때 남 탓 위주의 변명은 하지만 본인을 탓하는 말은 절대 들을 수 없다.
- 좀 더 작은 오류(결과를 얻는 데 완전히 실패한 것이 아니지만 무시할 수도 없는)의 경우는 더 간단하게 부조화를 해결할 수 있다.
- 그 오류의 존재를 **못 보고** 지나가는 것이다.
- 좋은 프로그램을 만들기 위해서는(또는 요구 명세에 부응하는 기존적인 수준만 원한다 해도) 확실한 반증이 있음에도 **자신의** 프로그램은 정확하다고 믿으려는 **완전히 정상적인** 사람의 성향에 대해 뭔가 조치를 취해야 한다.

### 비자아적 프로그래밍

- 자아의 문제는 사회적 환경과 더불어 프로그래머들의 가치 체계를 재구성함으로 극복해야 한다.
- 재구성은 상아타 안에서 사회이론가가 꿈꾸는 미망이 아니다.
- 자아의 문제를 해결한 프로그래밍 그룹은 컴퓨터의 초창기 시대부터 존재했고 지금도 존재한다.
- 폰 노이만의 천재성은 인간으로서 자신이 지닌 한계를 인식하는 바로 그 능력에서 출발했다.
- 보통 사람도 훈련을 하면, 자신에게 인간으로서 한계(기계처럼 일할 수 없다는)가 있음을 인정하고 존중할 수 있다.
- 그렇게 되면, 동료와 협력하여 그 한계를 극복하고 프로그래밍을 성공적으로 수행할 수 있다.
- 다른 사람을 통한 코드 검토가 꼭 필요한 일임을 모두가 인정했지만 왠지 비난을 받는 기분이었는데, 거래를 하면 비난받는 느낌 없이 코드를 검토 받을 수 있었다.
- 제대로 훈련받은 프로그래머인 빌에게는 그런 **거래의 보호**가 필요하지 않았다.
- 그의 프로그래밍 가치 체계에서 비밀스럽고 독점적인 프로그래밍은 나쁜 축에 속했고 공개적이고 공유된 프로그래밍이 좋은 축이었다.
- 그가 작성한 코드(**그의 코드**가 아니다.)에서 남이 오류를 찾는 것은 그에 대한 개인적인 공격이 아니라 코드를 개선하기 위함이었다.
- 매럴린이 빌이 작성한 코드에서 버그를 찾아낼 때마다 빌은 많은 버그가 발견될수록 더 즐거워했다.
- 그래서 **오늘은 내가 코딩이 잘 안되는 날**이라며 자신이 작성한 짧은 코드에서 그렇게 많은 버그가 발견되었다는 얘기를 되풀이해 자세하게 떠들고 다녔다.
- 여기에서 메를린은 그 상황에서도 자만하지 않고 또 다른 버그가 있을지도 모르겠다고 생각했다.
- 빌의 코드를 검토한 지 얼마간의 시간이 지나자 그녀는 원작자인 빈만큼이나 그 코드에 익숙해져 버렸음을 깨닫고 또 다른 동료에게 코드 검토를 부탁했다.
- 그 코드를 실제로 컴퓨터에서 실행했을 때에는 매우 엄격한 테스트에도 불구하고 오류가 더 이상 발견되지 않았다는 사실이다.
- 이렇게 동료들과 협력해서 인간의 한계를 극복한 유일한 사례는 아닌데 이런 그룹이 그다지 눈에 띄지 않는 것은 왜일까?
- **비자아적 프로그래밍**(egoless programming)이 널리 실천되지 않는 건 왜일까?
- 성공적인 소프트웨어 회사는 대부분 이런 형태의 협업을 근간으로 한다.
  - 이것이 성공적이라는 지식 자체를, 가치 있고 마치 그들만의 지적소유권이 있는 정보라고 생각한다.
- 이런 방식으로 일하는 그룹의 구성원들은 스스로 매우 만족하며 안정감을 느끼는 경향이 있기 때문에 일자리를 잘 옮기지 않는다.
- 이 회사에서 저 회사로 전진하는 프로그래머들이 그런 그룹의 출신일 가능성은 거의 없다.
- 그런 집시 프로그래머 처지에서는 최고의 프로그래밍이란 오직 천재성을 통해서만 이룰 수 있다는 미신을 더욱 조장해야한다.
- 위 방법으로 작업한 결과와 개인 프로그래머가 고립된 상태에서 작업한 결과의 질적 차이를 연구한 적이 없었다.
- 프로그래머의 생산성에 영향을 미치는 요소에 대한 연구는 프로그래밍의 기계적인 측면에만 치중했을 뿐 사회적인 측면은 고려하지 않았다.
- 비자아적 프로그래밍의 이점은 오류에 찾는 데에만 있지 않고 그 효과는 좋은 프로그래밍의 네 가지 요소와 관련지어 살펴볼 수 있다.
- 요구 명세 충족이라는 문제에서는 그 가치가 분명하다.
- 디버깅 시간의 변동 폭이 줄어들 뿐만 아니라, 그 프로그램에 익숙한 사람이 여러 명 되기 때문에 작업의 진척도를 실질적으로 측정하기 더 쉬워진다.
- 더는 어떤 한 사람이 내린 판단에만 의존하지 않아도 된다.
- 프로그램의 적응성 역시 향상된다.
- 적어도 두 명이 그 프로그램을 이해하고 있음이 확실하기 때문이다.
- 효율성의 문제는 성급하게 확언할 수 없지만 비자아성 프로그래밍보다 효율성에서 뒤쳐질 이유가 없음은 확실하다.
- 다른 사람의 검토를 거치면 적어도 너무 뚜렷하게 비효율적인 부분은 미리 없어질 수 있다.
- 마지막 이점은 다른 사람이 작성한 프로그램을 읽는 사람에게 미치는 효과다.
- 프로그램 읽기에 내포된 가치를 제대로 평가햤다면 비자아적 프로그래밍 방식으로 작성된 프로그램을 읽는 사람은 더 나은 프로그래머가 될 수 밖에 없다.
- 비자아적 프로그래밍을 실천하는 그룹의 능력 수준은 특별한 교육 없이도 저절로 높아지는 듯 하다.