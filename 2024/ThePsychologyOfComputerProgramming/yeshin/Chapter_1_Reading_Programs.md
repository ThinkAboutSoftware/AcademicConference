# 1부 인간 행위로 보는 프로그래밍

- 컴퓨터 프로그래밍은 인간의 행위다.

## 1장 프로그램 읽기

- 프로그래밍은 작문의 일종이라 할 수 있다.
- 작문을 배우는 가장 직접적인 방법은 써 보는 것이지만, 읽어 보는 것도 방법이다.
- 프로그래밍이 어떤 과정으로 이루어지는가를 밝히고 싶다면, 프로그램을 읽어서 무엇을 배울 수 있는지를 아는 것이 출발점이다.

### 예제

- 프로그램의 각 부분의 발단으로 구성된 개념적인 프레임워크를 토대로 프로그램을 읽어야 한다.
- 코드를 한 줄 만날 때마다 "이 코드는 왜 여기에 있을끼?"를 생각하는 것이다.

### 기계의 한계

- 프로그램을 실행할 기계는 해당 문제를 해결할 이상적인 기계에 비해 여러모로 한계가 있다.
- 그렇기 때문에 코드 한 줄 한 줄의 동기를 밝혀야 한다.

- 숫자 데이터를 10,000개 읽어 들여 그 총합을 구하는 프로그램이 있다고 하자.
- 가용 메모리의 양이 40,000바이트가 되지 않으므로 기계에 10,000개의 동시에 저장할 수 없어 숫자를 1,000개씩 묶어 10번 읽는다.

- 어떤 부분이 기계의 한계를 극복하기 위한 것이라도, 프로그래머가 그것에 특별한 표식을 남겨 두는 일은 거의 없다.
- 그런 코드(다른 기계로 포팅하는 경우 등)는 프로그램을 읽기 어렵게 만들 뿐 아니라 그 프로그램의 단점이 된다.
- 프로그래머 자신도 일부 코드가 기계의 한계를 보완하려고 추가한 사실을 기억하지 못할 수 있고 그렇다면 당연히 특별한 표식을 남길 수 없다.
- **그러나 프로그래머들은 그런 상황을 한계로 인식하기보다는 무의식중에 엄연한 사실로 인정해버리는 경향이 있다.**
- 그럴수록 프로그래밍의 어려움은 더 커지며, 프로그래머를 골치 아프게 만드는 기계의 한계를 기계 설계자들이 인지할 가능성은 더 적어지게 된다.
- 기계의 한계가 두드러지는 또 다른 부분은 보조기억장치다.
- 애초에 주 기억장치를 싼 값에 필요한 만큼 구비할 수 있었다면 보조 기억장치는 전혀 필요하지 않았을 것이다.
- 드럼, 디스크, 테이프 등의 다양한 보조 기억장치에 따라 필요한 코드의 양이 훨씬 늘어나고 각각 다른 고유한 특성이나 방식, 용량을 갖기 때문에, 결국 그 수많은 모든 경우를 제대로 처리하는 일은 프로그래머 몫이 된다.

### 언어의 한계

- 인간에 좀 더 가까운 분야는 (기계어를 제외한)프로그래밍 언어다.
- 기계어보다 높은 수준의 언어를 사용할 때 생기는 문제점 중 하나는 하드웨어의 특정 기능을 사용할 수 없다.
  - FORTRAN은 파일 끝(end-of-file)을 인지하고 제어권을 프로그램의 다른 부분으로 넘기는 기능을 제공하지 않는다.
  - 프로그래머는 임의로 정한 특수 데이터를 파일 끝으로 인식하는 방법을 사용할 수 밖에 없다.
  - 이는 언어의 한계가 프로그램과 데이터 모두에 영향을 준다.

- 프로그램이 작성될 당시에 SUM은 산술(arithmetic) 함수가 아닌 수학(mathmerical) 함수였다.
- 즉, 함수 내부에서 데이터를 부동소수점수로 간주하고 필요하다면 입력값을 부동소수점수로 변환하는 것인데 정밀도에 손실이 생기는 상황들이 계속해서 발생함에 따라 SUM의 정의가 산술 함수로 바뀌게 되었다.
- FORTRAN의 경우, 몇 가지 정해진 제약때문에 코드가 필요 이상으로 커진다.
  - **이런 제약은 사라지기 전까지 제약으로 인식되지 못할 수도 있다.**

### 프로그래머의 한계

- 심리학과 좀 더 밀접한 주제는 사용하는 컴퓨터와 언어, 그리고 프로그래머 자신에 대한 지식이나 이해가 부족함으로 인해 얼마나 많은 코드를 쓸데없이 추가하느냐다.
- 프로그래머의 한계에는 언어에 대한 지식 부족(이른바 어휘력 부족), 특정 알고리즘에 대한 무식, 문제를 충분히 이해할 능력 부족등이 있다.

### 역사의 흔적

- 어떤 프로그램에서 앞서 다룬 범주 중 하나에 속하지만 실질적으로는 그 프로그램의 개발 역사 때문에 여전히 존재하는 문제점들을 발견하는 경우가 있다.
  - 미연방 사회 보장국의 두 프로그래머가 어떤 프로그램을 점검하던 중 이상한 코드를 발견했다.
  - 그들은 동기를 확실히 알지 못하는 코드를 마음대로 수정하는 것이 꺼려져서 조사를 시작했고 결국에는 밝혀냈다.
  - 프로그래머의 세대가 몇 번 바뀔 정도로 오래 전부터 사용하던 천공기에서 문제가 있었다.
  - 당시에는 전처리도 하지 않았기 때문에 그렇게 잘못된 표시가 처리 프로그램 실행에 문제를 일으켰던 것인데
  - 잘못 표시된 카드가 이미 얼마나 많이 입력기에 걸려있는지를 알 수 없었다.
  - 그 당시에는 미봉책으로 프로그램을 수정했다.
  - 상황이 해결되지 모두 그 사실을 잊어버렸고 수년 후 두 프로그래머가 발굴하기 전까지 그 사실은 묻혀 있었다.
- 코드에 남아 있는 역사의 흔적을 항상 간단히 알아볼 수 있는 것은 아니다.
- 특히, 프로그램의 규모가 클수록 과거의 선택이 더 큰 영향을 끼친다.

### 명세

- 명세된 작업 외의 다른 조건도 모두 고려하다 보면 그렇게 될 수 있다.
- 그렇다고 해서 각종 한계를 극복하기 위한 코드는 무시하고 실질적인 작업을 하는 핵심 코드만으로 그 프로그램의 명세를 밝힐 수 있다고 생각하는 것은 오산이다.
- 원작자도 잘 모르고 작성한 어떤 코드를 보고 그 의도를 파악하거나 컴퓨터에 대한 일말의 이해도 없이 작성된 명세만 보고 효율적인 코드를 만들어 내기는 어렵기 때문이다.
- 더 큰 원인은 주어진 문제를 해결하고자 프로그래밍을 시작하기 전까지는 그 문제 자체를 정확히 이해할 수 없다는 것이다.
- 명세는 프로그램, 프로그래머와 함께 진화한다.
- 프로그램을 작성한다는 것은 일종의 학습(프로그래머와 프로그램 사용자 모두에 대한)이다.
- 이 학습 과정은 특정 기계와 특정 프로그래밍 언어, 특정 작업 환경에서 일하는 특정 프로그래머 또는 팀 그리고 코드의 모양새뿐만 아니라 코드가 하는 일까지도 좌지우지하는 일련의 역사적인 사건들로 이뤄진 **문맥** 내에서 일어난다.
- 우리가 프로그램 작성 과정을 연구하는 가장 중요한 목적은 좀 더 효율적이고 치밀하고 저렴하고 이해하기 쉬운 프로그램을 만들기 위함이 아니다.
- 프로그램이 하는 일이 우리가 그 프로그램에게 원했던 바로 그것이길 바란다.

### 요약

- 어떤 프로그램이 현재의 모습을 갖게 된 데에는 다 이유가 있다.
  - 코드를 읽어 보면, 어떤 부분은 기계나 언어 또는 프로그래머의 한계 때문일 수도 있고
  - 당시 존재했던 외부 조건(사건)이나
  - (핵심 유무를 떠난) 주어진 명세 때문이거나
- 프로그래밍을 인간의 행위로 연구하다 보면 수많은, 때로는 예상치 못한 소득을 얻게 될 수 있다.

### 질문

#### 관리자에게

> 이 질문에 대한 답은 몇 년 후에 할 수 있을 것같다.

1. 당신이 일선 관리자라면, 당신이 담당 프로그래머가 작성한 프로그램을 읽을 능력이 있는가? 혹시 구세대 프로그래밍 언어까지만 가능하지는 않은가? 읽을 능력이 있다면 프로그램을 실제로 읽어 보는가? 읽어보지 않는다면 왜 그런가?

2. 당신이 고위 관리자라면, 당신의 일선 관리자들에게 프로그래머가 작성한 프로그램을 읽을 능력이 있는가? 확신하는가? 프로그래머들에게 직접 물어보고 질문에 다시 답해보자. 

3. 일선 관리자들이 프로그램을 읽는 능력이 있더라도 실제로 프로그램을 읽어 보는지 확인하라. 우리의 조사에 따르면 일선 관리자 열에 아홉은 이런저런 이유로 프로그램을 읽지 않는다. 당신은 그런 일선 관리자가 어떤 프로그래머가 얼마나 유능하고 일을 잘 하고 있는지를 판단할 수 있다고 생각하는가?

#### 프로그래머에게

1. 마지막으로 다른 사람이 작성한 프로그램을 읽어 본 적이 언제였는가? 왜 그 사이에는 그렇게 하지 않았는가? 마지막으로 다른 사람이 당신의 프로그램을 읽고 당신과 함께 토론한 것은 언제였는가? 그는 상사였는가?

> GitHub Issue 생성할 때 자동으로 label을 붙여주는 Actions를 실행하기 위해 주변 사람들의 스크립트를 보았다.
> 사내에서 코드리뷰를 진행하는데 명칭이나 코딩 스탠다드 위반(?), 코드 수 줄여보기 등 단순한 건들을 위주로 이야기했었다.
> 최적화 작업 중에는 트랜젝션 거는 케이스에 대해 리드와 팀원과 이야기를 나눠 본 적있다.

2. 프로그램 라이브러리나 동료에게서 프로그램을 하나 구하라. 그리고 코드 한 줄 한 줄이 그렇게 작성된 이유를 밝혀보라(본문에서 서명한 것처럼). 이 연습을 하면서 당신이 배운 것은 무엇인가?

> 이 부분은 1월 내에 진행해보고 답변을 달아볼 것이다.

3. 한 달 이상 전에 당신이 직접 작성했던 프로그램을 대상으로 2번과 같은 연습을 하라. 이 연습으로 당신은 무엇을 배웠는가?

> 이 부분은 1월 내에 진행해보고 답변을 달아볼 것이다.

### 참고문헌

- [Planning a Computer System : Project Stretch](https://amturing.acm.org/Buchholz_102636426.pdf)
    - 컴퓨터를 구성하는 부품에도 각각 이유가 있다.
    - 컴퓨터 하드웨어가 왜 지금과 같은 모습이 되었는지를 설명한다.
    - 프로그래밍에 있는 기계의 한계라는 문제에 대해 많은 통찰을 제공한다.
    - 스트레치(Stretch)는 기계 설계에서 보통 당연하게 여겨지는 여러 한계를 제거한 프로그래머의 기계를 목표로 했다.

- [PL/1 Language Log](https://www.ibm.com/docs/en/SSY2V3_5.1.0/com.ibm.ent.pl1.zos.doc/lrm.pdf)
  - PL/1이 현재 모습이 되기까지의 수많은 논쟁과 그 결과가 반영된 변화등을 정리한 총체적인 기록이다.
  - 한 프로그래밍 언어가 어떻게 어떻게 제 모습을 갖춰 가는지를 알아볼 수 있다.

- 사용자 그룹이나 컴퓨터 제조사가 보유한 프로그램 라이브러리
  - 우리 손에 있는 프로그램 라이브러리는 정보의 보물창고다.

- [PL/I programming: A Manual of Style](https://archive.org/details/pliprogrammingma0000gera/mode/2up)
  - 프로그램이 어떻게 현재와 같은 모습이 되었는지에 대해 생각해볼 수 있다.

- [Fourth Generation Computers: User Requirements and Transition ](https://books.google.co.kr/books/about/Fourth_Generation_Computers_User_Require.html?id=D7EEAQAAIAAJ&redir_esc=y)
  - 처음 첫 세대를 거치며 축적된 지혜를 바탕으로 제 4세대를 예측하면서 컴퓨터 사용자의 심리적 요구라는 문제에 부딪힌다.
  - 과거와 달리 설계자와 판매사원, 제조사가 고객보다 더 큰 영향력을 지니게 된 이유를 밝힌다.
  - 소프트웨어 차원의 시스템 설계에서 사용자가 좀 더 중시되어야 할 필요성에 대해 논한다.