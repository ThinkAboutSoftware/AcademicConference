# 1부 인간 행위로 보는 프로그래밍

> 컴퓨터 프로그래밍은 인간의 행위다.

## 1장 프로그램 읽기

- 프로그래밍은 **작문**의 일종이다.

- 작문을 배우는 가장 직접적인 방법은 써 보는 것이지만, **읽어 보는 것**도 방법이다.

- 프로그래밍이 어떤 과정으로 이루어지는 것은, **프로그램을 읽어서 무엇을 배울 수 있는지**를 아는 것이 시작이다.

### 예제

- 프로그램의 각 부분의 발단으로 구성된 *개념적인 프레임워크를 토대로* 프로그램을 읽어야 한다.

- 코드를 한 줄 읽을 때마다 "이 코드는 왜 여기에 있을끼?"를 **생각**하는 것이다.

### 기계의 한계

- 프로그램을 실행할 기계는 한계가 있으므로 코드 한 줄 한 줄의 동기를 밝혀야 한다.

  ```
  숫자 데이터를 10,000개 읽어 그 총합을 구하는 프로그램이 있다.

  가용 메모리의 양이 40,000바이트가 되지 않으므로 기계에 10,000개의 동시에 저장할 수 없다.

  결국 숫자 데이터를 1,000개씩 묶어 10번 읽는 과정으로 작성한다.
  ```

- 어떤 부분이 기계의 한계를 극복하기 위한 것이라도, 프로그래머가 그 부분에 특별한 표식을 남겨 두는 일은 거의 없다.

- 그런 코드(다른 기계로 포팅하는 경우 등)는 프로그램을 읽기 어렵게 만들 뿐 아니라 해당 프로그램의 단점이 된다.

- 프로그래머 자신도 기계의 한계를 보완하기 위해 코드를 추가했다는 사실을 기억하지 못한다면 당연히 그 특별한 표식을 남길 수 없다.

#### 프로그래머들은 그런 상황을 한계로 인식하기보다는 무의식중에 엄연한 사실로 인정해버리는 경향이 있다.

- 그럴수록 프로그래밍의 어려움은 더 커지고, 기계 설계자 입장에서 프로그래머를 골치 아프게 만드는 기계의 한계를 인지하기 어렵다.

- 보조기억장치도 기계의 한계가 두드러지는 도구다.

  - 만약 주 기억장치를 저렴한 가격에 필요한 만큼 구비할 수 있다면 보조 기억장치는 필요하지 않을 것이다. (현실 불가능)

  - 다양한 보조 기억장치(디스크, 테이프 등)에 따라 필요한 코드량이 늘어나고 각각의 고유한 특성을 가지므로, 결국 프로그래머가 수많은 모든 경우를 제대로 처리하게 된다.

### 언어의 한계

- 인간에 좀 더 가까운 분야는 (기계어를 제외한) 프로그래밍 언어다.

- 기계어보다 높은 수준의 언어를 사용하면 하드웨어의 특정 기능을 사용할 수 없다.

  1. FORTRAN
  
     - FORTRAN은 파일 끝(end-of-file)을 인지하고 제어권을 프로그램의 다른 부분으로 넘기는 기능을 제공하지 않아

     - 프로그래머는 임의로 정한 특수 데이터를 파일 끝으로 인식하는 방법을 고안해 사용하게 된다.

     - 몇 가지 제약으로 인해 코드는 필요 이상으로 커지면서 즉, **언어의 한계는 프로그램과 데이터 모두 영향**을 준다.

  2. SUM 함수

     - 프로그램이 작성될 당시에 SUM은 산술(arithmetic) 함수가 아닌 수학(mathmerical) 함수였다.

     - 함수 내부에서 데이터를 부동소수점수로 간주하고, 필요하다면 입력값을 부동소수점수로 변환하는데

     - 정밀도에 손실이 생기는 상황들이 계속해서 발생하면서 SUM의 정의는 산술 함수로 바뀌게 되었다.

- **이런 제약은 사라지기 전까지 제약으로 인식되지 못할 수도 있다.**

### 프로그래머의 한계

- 사용하는 컴퓨터와 언어, 프로그래머 자신에 대한 지식이나 이해 부족으로 인해 얼마나 많은 코드를 쓸데없이 추가하느냐다.

- 프로그래머의 한계에는 언어에 대한 지식 부족(이른바 어휘력 부족), 특정 알고리즘에 대한 무식, 문제를 충분히 이해할 능력 부족 등이 있다.

### 역사의 흔적

- 실질적으로는 그 프로그램의 개발 역사 때문에 여전히 존재하는 문제점들을 발견하는 경우가 있다.

  - 미연방 사회 보장국의 두 프로그래머가 어떤 프로그램을 점검하던 중 이상한 코드를 발견했다.

  - 처음에는 동기를 확실히 알지 못하는 코드를 마음대로 수정하는 것이 꺼려져서 조사를 시작했다.

  - 프로그래머의 세대가 몇 번 바뀔 정도로 오래 전부터 사용하던 천공기에서 문제가 있었는데,

  - 당시에는 전처리도 하지 않았기 때문에 잘못된 표시가 처리 프로그램 실행에 문제를 일으켰던 것이다.

  - 잘못 표시된 카드가 이미 얼마나 많이 입력기에 걸려있는지를 알 수 없었고, 미봉책으로 프로그램을 수정했다.

  - _상황이 해결되지 모두 그 사실을 잊어버렸고_ 수년 후 두 프로그래머가 발굴하기 전까지 그 사실은 묻혀 있었다.

- 코드에 남아 있는 역사의 흔적을 항상 간단히 알아볼 수 있는 것은 아니다.

> 프로그램의 규모가 클수록 과거의 선택이 더 큰 영향을 끼친다.

### 명세

- 명세된 작업 외의 다른 조건도 모두 고려하다 보면 그렇게 될 수 있지만

- 각종 한계를 극복하기 위한 코드는 무시하고 실질적인 작업을 하는 핵심 코드만으로 그 프로그램의 명세를 밝힐 수 있다고 생각하는 것은 오산이다.

- 원작자도 잘 모르고 작성한 어떤 코드를 보고 의도를 파악하거나 컴퓨터에 대한 일말의 이해도 없이 작성된 명세만 보고 효율적인 코드를 만들어 내기는 어렵기 때문이다.

- 더 큰 원인은 주어진 문제를 해결하고자 프로그래밍을 시작하기 전까지는 그 **문제 자체를 정확히 이해할 수 없다**는 것이다.

- 명세는 프로그램, 프로그래머와 함께 진화한다.

- 프로그램을 작성한다는 것은 일종의 학습(프로그래머와 프로그램 사용자 모두에 대한)이다.

- 이 학습 과정은 특정 기계와 특정 프로그래밍 언어, 특정 작업 환경에서 일하는 특정 프로그래머 또는 팀 그리고 코드의 모양새뿐만 아니라 코드가 하는 일까지도 좌지우지하는 일련의 역사적인 사건들로 이뤄진 **문맥** 내에서 일어난다.

- 프로그램 작성 과정을 연구하는 가장 중요한 목적은 좀 더 효율적이고 치밀하고 저렴하고 이해하기 쉬운 프로그램을 만들기 위함이 아닌, 프로그램이 하는 일이 **우리가 그 프로그램에게 원했던 바로 그것**이길 바란다.

### 요약

- 어떤 프로그램이 현재의 모습을 갖게 된 데에는 다 이유가 있다.

  - 코드를 읽어 보면, 어떤 부분은 기계나 언어 또는 프로그래머의 한계 때문일 수도 있고

  - 당시 존재했던 외부 조건(사건)이나

  - (핵심 유무를 떠난) 주어진 명세 때문이거나

- 프로그래밍을 인간의 행위로 연구하다 보면 수많은, 때로는 예상치 못한 소득을 얻게 될 수 있다.

### 질문

#### 관리자에게

>> 이 질문에 대한 답은 몇 년 후에 할 수 있을 것같다.

1. 당신이 일선 관리자라면, 당신이 담당 프로그래머가 작성한 프로그램을 읽을 능력이 있는가? 혹시 구세대 프로그래밍 언어까지만 가능하지는 않은가? 읽을 능력이 있다면 프로그램을 실제로 읽어 보는가? 읽어보지 않는다면 왜 그런가?

2. 당신이 고위 관리자라면, 당신의 일선 관리자들에게 프로그래머가 작성한 프로그램을 읽을 능력이 있는가? 확신하는가? 프로그래머들에게 직접 물어보고 질문에 다시 답해보자. 

3. 일선 관리자들이 프로그램을 읽는 능력이 있더라도 실제로 프로그램을 읽어 보는지 확인하라. 우리의 조사에 따르면 일선 관리자 열에 아홉은 이런저런 이유로 프로그램을 읽지 않는다. 당신은 그런 일선 관리자가 어떤 프로그래머가 얼마나 유능하고 일을 잘 하고 있는지를 판단할 수 있다고 생각하는가?

#### 프로그래머에게

1. 마지막으로 다른 사람이 작성한 프로그램을 읽어 본 적이 언제였는가? 왜 그 사이에는 그렇게 하지 않았는가? 마지막으로 다른 사람이 당신의 프로그램을 읽고 당신과 함께 토론한 것은 언제였는가? 그는 상사였는가?

>> GitHub Issue 생성할 때 자동으로 label을 붙여주는 Actions를 실행하기 위해 주변 사람들의 스크립트를 보았다.
>>
>> 사내에서 코드리뷰를 진행하는데 명칭이나 코딩 스탠다드 위반(?), 코드 수 줄여보기 등 단순한 건들을 위주로 이야기했었다.
>>
>> 최적화 작업 중에는 트랜젝션 거는 케이스에 대해 리드와 팀원과 이야기를 나눠 본 적있다.

2. 프로그램 라이브러리나 동료에게서 프로그램을 하나 구하라. 그리고 코드 한 줄 한 줄이 그렇게 작성된 이유를 밝혀보라(본문에서 서명한 것처럼). 이 연습을 하면서 당신이 배운 것은 무엇인가?

>> 이 부분은 1월 내에 진행해보고 답변을 달아볼 것이다.

3. 한 달 이상 전에 당신이 직접 작성했던 프로그램을 대상으로 2번과 같은 연습을 하라. 이 연습으로 당신은 무엇을 배웠는가?

>> 이 부분은 1월 내에 진행해보고 답변을 달아볼 것이다.

### 참고문헌

- [Planning a Computer System : Project Stretch](https://amturing.acm.org/Buchholz_102636426.pdf)

    - 컴퓨터를 구성하는 부품에도 각각 이유가 있다는 것을 중심으로 컴퓨터 하드웨어가 왜 지금과 같은 모습이 되었는지를 설명한다.

    - 프로그래밍에 있는 기계의 한계라는 문제에 대해 많은 통찰을 제공한다.

    - 스트레치(Stretch)는 기계 설계에서 보통 당연하게 여겨지는 여러 한계를 제거한 프로그래머의 기계를 목표로 했다.

- [PL/1 Language Log](https://www.ibm.com/docs/en/SSY2V3_5.1.0/com.ibm.ent.pl1.zos.doc/lrm.pdf)

  - PL/1이 현재 모습이 되기까지의 수많은 논쟁과 그 결과가 반영된 변화등을 정리한 총체적인 기록이다.

  - 한 프로그래밍 언어가 어떻게 어떻게 제 모습을 갖춰 가는지를 알아볼 수 있다.

- 사용자 그룹이나 컴퓨터 제조사가 보유한 프로그램 라이브러리

  - 우리 손에 있는 프로그램 라이브러리는 정보의 보물창고다.

- [PL/I programming: A Manual of Style](https://archive.org/details/pliprogrammingma0000gera/mode/2up)

  - 프로그램이 어떻게 현재와 같은 모습이 되었는지에 대해 생각해볼 수 있다.

- [Fourth Generation Computers: User Requirements and Transition ](https://books.google.co.kr/books/about/Fourth_Generation_Computers_User_Require.html?id=D7EEAQAAIAAJ&redir_esc=y)

  - 처음 첫 세대를 거치며 축적된 지혜를 바탕으로 제 4세대를 예측하면서 컴퓨터 사용자의 심리적 요구라는 문제에 부딪힌다.

  - 과거와 달리 설계자와 판매사원, 제조사가 고객보다 더 큰 영향력을 지니게 된 이유를 밝힌다.

  - 소프트웨어 차원의 시스템 설계에서 사용자가 좀 더 중시되어야 할 필요성에 대해 논한다.

<hr>

### 느낀점

- 프로그래밍도 결국 인간이 하는 작업이기때문에 심리학과 엮어 접근하는 방법이 신선했다.

- 화자의 말투가 직설적인건지 번역가의 말투가 직설적인 건지는 모르겠지만 전반적인 글이 굉장히 강하게 다가왔다.

- '코드를 봐달라..'라는 말이 사람에 따라 다르게 느껴질 수 있다. 나만 하더라도 코드 검토 요청이 온다면(보기야 하겠다만) 구체적으로 무엇을 봐달라는건지 상대방의 요청이 모호하게 느껴지기 때문이다.

- 나를 포함한 대부분의 경우는 보통 코드리뷰에서 다른 사람이 작성한 코드를 검토하게 되는데, 여기에서도 둘로 나눠진다.

  1. 명칭이나 가독성 위주의 코멘트

  2. (실행 가능하다면) 해당 코드를 직접 돌려봄으로써 버그나 개선 사항을 직접 찾아서 알려주는 코멘트

- 내 경험으로는 1번 위주로 했었다. 2번은 품이 많이 들기 때문에 보통 해당 프로젝트 오너들이 진행했었다. 그래서 힘들어했다.

- 코드리뷰를 제외한 오픈소스같은 코드 읽기는 문제 해결을 위한 과정을 제외하고는 거의 안해봤다.

- 거대한 두께의 책을 보면 읽기도 전에 질리는 것처럼, 오픈소스들도 비슷하게 느껴졌다.

- 해당 챕터를 읽고 나니 관심있는 라이브러리부터 조금씩 읽어봐야겠다는 생각이 들었다.
