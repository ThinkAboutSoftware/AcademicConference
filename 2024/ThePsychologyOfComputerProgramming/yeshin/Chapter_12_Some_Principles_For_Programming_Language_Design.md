## 12장 프로그래밍 언어 설계에 필요한 원칙

### 일관성

- '어떤 목록을 얼마나 잘 기억할 수 있는지'는 '그 목록에 담겨있는 정보의 내용'과 밀접한 관련이 있다.

- 그 기억 속에는 목록에 포함되어 있는 것만 아니라 정보의 내용도 포함되기 때문이다.

> 동일한 표현은 그 위치와 상관없이 동일하게 동작한다.

- 프로그래밍 언어가 이 원칙에서 멀어질수록 배우기가 어렵고 프로그래머가 오류를 범할 가능성도 커진다.

- 할 수 없는 일이 많을수록 은연 중에 또 다른 금기가 있을 것이라 예상한다.

> 어떤 프로그래머가 '이런 표현도 쓸 수 있을까?'라고 물을 때 답은 반드시 '쓸 수 있다.'여야 한다.

- 일관성의 원칙이란 문법적으로 동일한 구문은 문맥이 달라도 동일한 의미를 지녀야 한다.

- 문자 집합의 제한은 기계가 지닌 한계로 인해 일관성이 결여되는 일례에 불과하다.

- 불명확함에는 '물리적인 불명확성'과 '심리적인 불명확성'가 있다.

  - 물리적 불명확성을 제거한다고 해서 심리적 불명확성까지 사라지는 것은 아니다.

- 일관성을 해치는 대표적인 경우는 변수명으로 사용할 단어를 잘못 고르는 것이다.

- 디버깅 관점에서, 일관적이고 매우 드물게만 예외가 있는 상황은 방심하기 쉽기 때문에 위험하다.

### 간결성

- 프로그램이 얼마나 간결한지는 그 소스 내의 글자 수보다 큰 단위다.

- 의미덩이 만들기(chunking)란 여러 작은 단위를 조합하여 커다란 단위 하나로 묶는 과정을 반복하는 인간의 정보처리 능력이다.

  - 의식적인 노력없이 수행하는 자연스러운 인지 과정으로, 의미덩이를 만들기 위해서는 먼저 그 의미덩이를 경험을 통해 학습해야 한다.

  - 동일한 것을 여러 방법으로 표현하는 수단(약어 등)을 제공하여 그 이상의 의미덩이를 사용할 수 있다.

- 지프(Zipf)의 법칙: 자주 사용되는 단어일수록 길이가 짧다.

  - 예) is, the, he, it 등

- 가장 기본적으로 프로그래밍에서 활용할 수 있는 압축은 반복이다.

- 또 다른 압축 형태인 데이터 구조화는 반복이나 함수보다 훨씬 강력하다.

- 특수 목적 언어는 범용 언어에 비해 한층 높은 수준의 데이터 구조를 제공한다.

- 그 데이터 구조가 사용자의 필요에 부합한다면, 프로그램은 더욱 간결해지지만 반대의 경우 오히려 역효과가 발생한다.

  - 적절한 데이터 구조화를 통해 표현을 압축하는 방법으로 연산의 차원을 높이는 것이다.
    
    - 연산의 차원을 높이는 한 가지 방법은 낮은 차원의 연산 결과를 높은 차원으로 해석하는 것이다.

  - 이보다 더 발전적인 방법은 어떤 데이터 구조를 그보다 높은 차원의 구조에 투영하는 것이다.

- 이런 방식으로 연산의 차원을 높이는 것은 언어가 구현될 컴퓨터가 어떤 기능을 제공하느냐에 의해 제한을 받는다.

- 표현의 압축은 생략을 통해서도 이뤄진다.

  - 특정한 경우에 대한 표현을 완전히 생략하거나, 변수를 선언할 때 변수의 속성을 대부분 생략한다.

    ```
    DECLARE X;

    DECLARE X FLOAT DECIMAL(6) REAL AUTOMATIC INTERNAL;
    ```

- 쓸모 있는 중복 정보와 쓸모 없는 중복 정보를 명확히 구별해야 한다.

### 근접성과 순차성

- 잘 설계된 프로그래밍 언어는 관련된 정보를 쉽게 찾을 수 있는 곳에 담아둔다.

  - 공감각적(synesthetic) 기억력: 사물을 전체적인 하나의 심상으로 기억한다.

  - 순차적(sequential) 기억력: 차례로 떠오르면서 고리마다 바로 다음에 오는 고리를 상기시킨다.

- 프로그램에서 근접성의 개념은 공감각 기억에, 순차성의 개념은 순차적 기억에 대응한다.

  - 근접성: 프로그램에서 서로 관련 있는 부분이 모두 한 장소에 나타내는 성질로, 근접성을 높이는 방법으로 압축이 있다.

    - 디버깅할 떄는 반드시 비근접성으로 인해 어떤 문제가 나타날 수 있는지를 염두에 둬야 한다.

    - 잘못된 프로그래밍 습관이나 실수 때문에 근접성이 훼손되는 것을 프로그래밍 언어 차원에서 방지하는 것은 한계가 있다.

    - 언제나 모든 변수를 선언하는 습관을 들이면 이러한 문제는 극복할 수 있다.

  - PL/1의 ON-루틴: 프로그램의 순차성을 높인다.

- 고수준 언어들은 대부분 컴퓨터의 비순차성을 보완하는 여러 장치를 제공한다.

### 전통과 혁신

- 실수할 가능성은 최소로 줄이면서 쉽게 표현할 수 있으려면, 프로그래밍 언어가 자연스러워져야 한다.

- 자연어에서 프로그래밍 언어가 차용한 개념으로는 '의미 있는 빈 칸'과 '철자법'이 있다.

- 두 프로그래밍 언어에 차이가 있다면, '억제'라는 심리적 현상이 일어난다.

  - 순향 억제: 먼저 학습한 내용과 나중에 학습한 내용이 비슷하여 나중의 학습이 방해받는다.

  - 역향 억제: 먼저 학습한 언어가 영향을 받는다.

- 느슨한 언어는 프로그래머 개인의 선호에 대한 적응성이 뛰어나다고 할 수 있다.

- 특정 프로그램 또는 모든 종류의 프로그램을 위한 함수 또는 하위 루틴을 정의할 수 있는 기능은 언어의 적응성을 높인다.

- 조직의 업무 성격에 따라서 언어의 적응력을 어느 정도 활용하는 편이 좋다.

- 지금 쓰는 언어가 조직의 요구에서 너무 벗어나 있다면, 변경보다 그 요구에 좀 더 잘 맞는 다른 언어를 찾아보는 편이 나을 것이다.

### 특수 목적 언어, 범용 언어, 장난감 언어

- 언어의 기능을 제한한 이유는 목적한 분야의 문제들이 일정 정도 이상으로 커지지 않을 것이라는 가정이 담겨있다.

- 특수 목적의 프로그래밍 언어를 사용하는 사람이 프로그래밍 언어의 한계를 잘 인식하지 못하는 이유는 **언어가 사용하는 사람의 사고방식을 좌지우지**하기 때문이다.

  - 이는 프로그래머가 프로그램과 데이터를 조직화하는 방식 자체를 언어가 결정한다.

- 프로그래머 대부분 자신의 기술 수준이 올라갔을 때 자기 충족적인 만족감을 느끼지만, 특수 목적의 프로그래밍 언어를 사용할 때에는 그와 상관없이 만족감을 느끼게 된다.

- 어떤 프로그래밍 언어가 그것이 목적한 특수한 일을 잘 처리하면 할수록 그 사용자의 사고는 더욱 더 좁아진다.

- 프로그래머가 아닌 사람들을 주된 사용자로 설정한 특수 목적 언어는 사용자의 기존 지식과 되도록 유사한 모습을 띄도록 설계된다.

### 요약

- 소통의 일방성이 프로그래밍 언어와 관련된 문제들의 근본 원인일 수 있다.

- 프로그래밍 언어의 대화적 성격으로 눈을 돌려야 한다.

### 질문

#### 관리자에게

1. 회사에서 어떤 프로그래밍 언어를 사용하고 있나? 당신은 프로그램을 얼마나 자주 읽는가? 프로그래밍 언어를 관리 업무를 위한 보조 수단으로 보는가, 아니면 프로그래머들이 자기들끼리 속닥거리기 위한 비밀 수단으로 보는가?

2. 새로운 프로그래밍 언어를 회사에 도입하기로 결정할 때 어떤 심리적 요소들을 고려하는가? 어떤 종류의 실험을 해보는가?

#### 프로그래머에게

1. 자신이 가장 잘 아는 프로그래밍 언어에 대해 다음의 성격이 드러나는 사례를 제시하고 토의해 보라.

   - 일관성

   - 비일관성

   - 금기 사항

2. 당신이 알고 있는 언어 중에서 간결성이 가장 뛰어난 것은 무엇인가? 그 언어가 그렇게 간결한 원인은 무엇인가? 혹시 그 언어를 사용해서 해결할 수 있는 문제의 범위가 제한되어 있기 때문에 그런 것은 아닌가?

3. 당신이 가장 잘 아는 언어에서 비근접성을 낳을 수 있는 방법을 모두 나열해 보라. 그렇게 발생한 비근접성이 디버깅할 때 어떤 결과를 초래하는가? 비근접성으로 인해 발생한 버그의 예를 들고, 어떻게 결국 그 버그를 찾아낼 수 있었는지 말해 보라.

4. 다른 사람이 작성한 여러 프로그램을 길이가 비슷한 것끼리 분류하고, 또 각 분류내에서도 이해하기 쉬운 정도에 따라 순서를 매겨 보라. 각 프로그램에서 사용된 분기의 횟수를 세어 보고, 프로그램의 명확성과 분기의 횟수 사이에 어떤 연관이 있는지 확인하라. 또, 분기 하나에 포함된 코드의 평균 길이를 계산해서 이 역시 프로그램의 명확성과 어떤 연관이 있는지 보라.

5. 가장 최근에 배운 언어로 프로그래밍할 때 이전 프로그래밍 언어에서 쓰던 방식의 영향을 받은 예를 몇 가지 들어 보라. 또, 당신이 공부한 프로그래밍 언어들이 프로그래밍이 아닌 다른 분야의 사고 과정에 영향을 끼친 예도 몇 가지 들어 보라.

6. 특수 목적 언어를 안다면, 그 언어가 다음 항목의 이점을 어떻게 활용하는지 설명해 보라.

   - 대화 주제의 제한

   - 해당 분야에 적합한 데이터 구조

   - 해당 분야에 적합한 처리 함수

   - 해당 분야에 대한 기존 지식에 부합되는 용어

### 참고문헌

- Raymond J. Rubey 외, Guide to PL/1 Vol. 1: Comparative Evaluation

- F. P. Brooks 외,Guide to PL/1 Vol. 2: Experiences with PL/1

  - 새로운 프로그래밍 언어(PL/1)의 가치를 평가하는 두 가지 방식을 보여준다.

- Jean E. Sammet 지음, Programming Languages: History and Fundamentals

  - 특수 목적 언어가 어떻게 설계되는지 추측해볼 수 있는 책이다.

- N. Wirth 지음, PL 360, A Programming Language for the 360 Computers

  - 생성되는 기계어 코드에 대한 제어권은 완벽하게 유지하면서 블록 구조의 장점도 취한 어셈블리어에 대한 논문이다.

- G. M. Weinberg 지음, PL/1 Programming: A Manual of Style

  - 이 책의 2장은 PL/1을 배경으로 프로그래밍 언어의 원칙들을 상세하게 논했다.

- M. Klerer, J. May 지음, A User-Oriented Programming Language

  - 언어를 설계하는 관점에서, 모호성을 수용하고 자신들이 만든 언어에 이름을 붙이지 않은 시스템에 대해 알 수 있다.

- C. J. Shaw 지음, Decision Tables-An Annotated Bibliography

- Paul Dixon 지음, Decision Tables and Their Application

- G. M. Weinberg 지음, Experiments in Problem Solving (Doctoral Thesis)

  - 프로그래밍 언어가 어떤 종류의 구조를 갖춰야 가장 바람직할지 암시해 준다.

- Benjamin Lee Whorf 지음, Language, Thought, and Reality

  - 언어가 생각에 미치는 영향을 밝혀낸 책이다.

- G. K. Zipf 지음, Human Behavior and the Principle of Least Effort

  - 언어 변화의 원칙에 대한 연구 결과가 담겨 있다.

- C. E. Shannon 지음, Prediction and Entropy in Printed English

- N. G. Burton, J. C. R. Licklider 지음, Long-Range Constraints in the Statistical Structure of Printed English

  - 영어로 출판된 책에 얼마나 많은 중복된 정보가 들어있는지를 측정하려는 시도가 담긴 책이다.

- George A. Miller 지음, The Magical Number Sevem, Plus-or-minus Two: Some Limits on Our Capacity for Processing Information

  - 인간의 정신이 소유한 정보 처리 능력이 어떻게 제한되고 그런 제한을 극복하고자 인간의 정신은 어떤 전략(의미덩이 만들기 같은)을 사용하는지 설명한다.

- B. Smith 지음, Memory

- F. A. Yates 지음, The Art of Memory

- M. Minsky 지음, Semantic Information Processing

  - 프로그래밍 언어를 설계할 때 고려되어야 할 기억과 여러 정신 과정을 논한 책이다.

### 12장에 보태는 글

- 모든 프로그래머는 메타언어 전문가다.

### 논의사항

- 여러분들이 가장 최근에 접하거나 배운 새로운 프로그래밍 언어는 무엇인가요?

- 그 언어를 배워봐야겠다고 생각한 계기와 어떻게 학습해왔는지 여러분들의 학습 방법이 궁금합니다.
