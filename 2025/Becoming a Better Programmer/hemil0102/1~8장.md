### 논제
실제 회사에서 기능 구현 외 리팩토링, 구조, 테스트 코드, 에러처리등 작업을 별도로 시간을 뺴서 진행하는지? 
아니면 알아서 눈치껏 진행해야 하는 범주인지 궁금합니다.  

# 1장 코드에 신경 쓰기 
## 1. 코드에 신경 쓰는가? 자신이 만든 결과물에서 그 점이 어떻게 드러나는가? 
코드에 신경을 쓰는 부분은 변수명이나 함수명을 최대한 보면 바로 이해할 수 있도록 작성한다. 
메서드와 함수는 되도록 한가지 책임을 갖도록 분리를 하는 편이다. 
되도록 모듈화하여 코드가 너무 길어지지 않도록 관리한다. 
부족한 부분은 테스트 코드를 작성하지 않았다는 점과 아마 더 있을 것 같다. 

## 2. 프로그래머로서 더 나아지고 싶은가? 가장 노력해야 하는 부분은 어떤 부분인가? 
책에서 말한 것과 같이 태도를 올바르게 가져가는 것이 중요하다고 생각한다. 
제한적인 상황이 많이 펼쳐지는 회사에서 비록 빠르고 실행만 가능한 코드를 요구하는 환경이라 할지라도, 
코드에 장인 정신을 갖는게 중요하다. 

## 3. 코드에 신경쓰지 않는다면, 왜 이책을 읽고 있는가? 
신경 쓰고 있다. 

## 4. 이 장의 서두에 등장하는 좋은 프로그래머가 좋은 코드를 작성한다는 것은 셜록 홈즈가 아니라도 알 수 있는 뻔한 사실이다. 
## 나쁜 프로그래머의 경우는 그렇지 않다는 문장은 얼마나 정확한가? 좋은 프로그래머가 나쁜 코드를 만들 수도 있는가? 어떻게 그럴 수 있는가? 
좋은 프로그래머가 나쁜 코드를 만드는 경우는 누군가의 강요에 의해 그 틀을 맞춰야할 때가 아닌가 싶다. 
또는 이미 99% 이상 완성된 코드가 주어져 자신의 철학을 반영할 틈이 없는 과제를 할 경우, 
좋은 프로그래머라면 좋은 코드를 작성하기 위해 이런 환경을 피해가는게 맞다고 생각한다. 

# 2장 정돈된 코드 유지하기 
## 1. 회사의 코딩 표준에 맞추기 위하여 레이아웃을 바꿔야 하는가? 
## 아니면 원작자의 스타일을 그냥 두는 것이 나은가? 그렇다면 이유는 무엇인가? 

원작자의 의도를 제대로 파악하기 전에는 그냥 두는 것이 낫다고 본다. 
원작자의 의도가 파악된 이후에 변경을 하는 편이 맞다고 본다. 

## 2. 코드를 리포매팅해주는 도구는 중요한가? 도구는 당신이 사용하는 언어에 얼마나 의존적인가? 
요즘은 GPT로 리팩토링을 해보면 내가 볼 수 없는 부분까지 가이드해줄 때가 있다. 
스스로 고민 끝에 만들어진 코드도 가치가 있지만, 새로운 관점을 넓혀가는 점에서 GPT같은 툴도 유용하다. 
사람의 의도를 담는 선에서는 사용하는 것이 좋아보인다. 

## 3. 코드의 외관과 설계 중 어떤 것이 더 중요한가? 
설계가 더 중요하다. 설계가 제대로 되면 외관이나 외면적인 것은 자연스럽게 좋아질 수 밖에 없지 않냐는 생각이 든다. 

## 4. 현재 프로젝트에서 코드의 일관성은 어떠한가? 어떻게 개선할 수 있는가? 
솔직히 말하면 물려받은 프로젝트의 코드가 엄청 난잡하다. 줄맞춤도 안되어 있고 변수명도 무슨 말을 하는지 알 수가 없다. 
별도의 매뉴얼을 봐야만 이해가 되는 코드다. 
의도를 명확히 할 수 있도록 이름이나 코드의 흐름을 파악하여 개선한다.
중복되는 코드를 수정한다. 

## 5. 탭 vs 스페이스? 선택한 이유는? 이것은 중요한가? 
간격만 맞으면 뭘 쓰던 별로 개의치 않는 것 같다. 

## 6. 언어의 레이아웃과 명명 규칙을 따르는 것이 중요한가? 아니면 표준 라이브러리와 차별화하여 
'자신만의 스타일'을 사용하는 것이 유용한가? 
무엇을 사용하던 코드의 의도와 가독성이 잘 드러나면 되는 것 같다. 

## 7. 화려한 구문 강조 코드 편집기를 사용하면 색상이 코드의 구조를 나타내준다는 이유로, 
## 코드의 레이아웃에 대해 신경쓰지 않아도 될까? 
음 ... 신경 써야한다고 본다. 색상은 구분을 해주긴 하지만 머리 속에 사고의 흐름이나 구조는 색상을 따라가진 않는 것 같다. 

## 연습해보기 
## 자신의 코드 레이아웃에 대해 리뷰해보자. 관용어법을 사용하고 있으며, 일반적이고 명박하며 일관성 있는가? 
## 어떻게 발전 시킬 것인가? 코드 외관에 대해 동료들과 의견 충돌이 있지는 않는가? 
## 이러한 의견 차이를 어떻게 극복할 것인가? 

모델링과 인터페이스를 초반에 잘 설계하고 충분히 논의를 거칠 것 같다. 
테스트 코드를 적용해서 일관된 결과가 나오게 만들어 향후 수정이 필요할 경우 명백한 근거를 요구한다. 

# 3장 코드 적게 쓰기
## 1. 간결한 논리적 표현을 사용하는가? 간결한 표현이 너무 간결하여 이해하기 어렵지는 않은가? 
간결하면 때론 읽기 어려운데 그래도 간결한 것이 익숙해지려는 노력을 한다. 

## 2. C 언어 패밀리의 삼항 연산자, 예를 들면 '조건? 참: 거짓'과 같은 표현을 읽기 쉽게 만드는가? 
아니면 어렵게 만드는가? 그 이유는 무엇인가? 
처음에는 해당 구문이 익숙치 않았지만, 현재는 쉽고 자주 사용한다. 

## 3. 잘라내기&붙여넣기 코딩은 피해야한다. 공통함수로 코드 일부를 나눌 떄의 기준을 어느 정도로 하는 것이 적당한가? 
함수 하나가 역할과 책임이 명백하고 또 여러 곳에서 재사용 가능할 정도로 구분을 하는것이 맞다고 생각한다. 

## 4. 죽은 코드를 어떻게 발견하고 제거할 수 있는가? 
하루에 조금씩이라도 코드를 되돌아 보면서 리팩토링을 한다. 
그러다보면 어디가 죽어있는지는 쉽게 파악할 수 있다. 

## 5. 몇몇 코딩 표준은 모든 함수를 특별히 정형화된 주석으로 문서화하도록 주석으로 문서화하도록 한다. 
## 이것은 유용한가? 아니면 불필요한 여분 주석으로 짐이될까? 
주석은 잘 관리하면 좋다고 생각하지만 유지보수가 어려워서 때로는 의도와 다르게 나쁜 가이드로 작동한다. 
약간 문서도 유지보수가 힘든 것과 같은 이치라고 생각. 
되도록이면 주석을 사용하지 않는게 바람직하다고 생각한다. 

# 4장 코드 줄여 개선하기
## 1. 프로그램에서 작동하지 않는 '죽은 코드'를 어떻게 식별할 수 있는가? 
주요 핵심 컴포넌트를 검색으로 찾아봤을 때 찾아지지 않는 경우가 있다거나, 
코드의 구조가 이해가 되지 않다거나, 뭔가 촉이 발생할 때... 타고타고 들어가다보면 죽어 있는 경우가 있다. 

## 2. 현재 일시적으로 필요하지 않은(그러나 미래에는 필요할지도 모르는) 코드를 제거할 때, 
## 소스 트리에 주석 처리하여 눈에 띄게 남겨두는가? 아니면 완전히 삭제하는가( 이 때는 리비전 히스토리에 저장될 것이다 )
## 이유는 무엇인가? 
먼저 금방 금방 수정이 발생해서 쳐놓은 주석은 다시 원복 가능성이 있어 남겨 놓는 편이다. 
그런데 한 2~3일 지나도 건드리지 않는 주석들은 과감하게 삭제한다. 
경험상 2~3일 넘어도 주석인채로 남은 코드들은 나중에 참고하기 보다는 삭제할 확률이 높았고, 
이미 내 안에서 나온 코드들이기에 언제든지 원복이 가능하다. 
뭔가 잊어버릴까봐 불안감을 갖기보다는 설계를 똑바로하면서 그 설계에 가까워지는 코드를 짜다보면, 
차선을 굳이 여러 곳에 남겨둘 필요는 없어진다. 

## 3. 사용하지 않는 레거시 기능을 제거하는 것은 항상 적절한가? 코드 일부를 제거할 때 내재된 위험이 있는가? 
## 불 필요한 기능을 제거하는 적절한 시점을 어떻게 결정할 수 있는가?
사실 이 부분은 어려운 것 같다. 프로세스가 돌아가고 서비스가 진행 중인 코드를 잘못 건드려서 기능이 동작하지 않을까란 우려가 있다. 
다만, 어떤 인터페이스나 테스트 환경을 잘 갖춰서 검증을 통과한다면 적용해도 괜찮지 않을까란 생각이 든다. 
아직은 여기까지 진행해보질 않아서 정확한 시점은 잘 모르겠다. 

## 4. 현재 프로젝트의 코드베이스에서 불필요한 부분이 얼마나 되는가? 
## 당신의 팀은 유용하다고 여겨지거나 마음에 드는 기능을 제멋대로 추가하는 문화를 가지고 있는가? 
우리 팀은 마음대로 무언가를 추가하지 않고 충분한 소통 뒤에 추가한다.
안드로이드 개발자와 iOS가 되도록이면 같은 구조를 갖도록, 수정 사항이 발생하면 서로 커뮤니케이션을 할 수 있도록 한다. 
다만 유용한 기능을 멋대로 추가하기보다는 유용한 기능 예를 들어 extension 확장 기능이나 유틸성 기능은
크게 눈치보지 않고 추가하는 편이다. 

# 5장 코드베이스의 망령
## 1. 예전의 코드가 지금은 어떻게 보이는가? 그다지 나빠 보이지 않는다면, 최근에 새로운 뭔가를 배우지 않았음을 뜻하는 것인가? 
사실 나는 예전의 내가 작성한 코드를 보면 내가 작성했어도 난잡해 보이거나, 조금 코드가 복잡해 보인다. 
언제나 내 코드는 어딘가 모르게 고칠 구석이 있다는 생각을 한다. 
그런데 너무 고치려고 하는 것도 어쩌면 구조에 대한 자신감 부족이 아닐까란 생각이 들고, 
조금은 명확한 기준을 갖고 이정도면 그래도 괜찮지라고 생각하면서 코드를 고쳐나가고 싶다. 

## 2. 주요 언어로 얼마나 오랫동안 일했는가? 그사이 언어 표준이나 내장 라이브러리가 얼마나 많이 바뀌었는가? 
## 당신이 코드를 작성하는 스타일을 형성할 때 어떤 언어 기능에 영향을 받았는가? 
주요 언어로는 한 1년 정도 일한 것 같다. 
Swift는 최근에 6.0으로 언어가 업데이트되면서 동시성 관련 표현이 많이 바뀌었다. 
이런 사소한 표현 문법들은 코드를 작성하는 스타일에 크게 영향을 준다. 
예를 들어 예전에는 dispatchQueue나 CompletionHandler를 통해 콜백 형식으로 비동기를 처리했는데
언어의 업데이트로 Async, Await같은 구문으로 더 간단하게 표현이 가능하다. 

## 3. 무의식적으로 사용하는 일반적인 관례의 일부에 대해 생각해보자. 이들이 오류가 발생하지 않도록 하는데 무엇이 도움이 되는가? 
음... 조금은 여기저기 사용되는 상수값들은 한데 묶어서 이름을 지정해서 가독성을 올리고 값을 변화 시켜도 동시에 적용되도록 하는 편이다. 
메서드가 많아지거나 함수가 많아지면 뭔가 모듈화하여 빼낼 매니저가 생겼다는 느낌이 들어서 이럴 때는 코드를 분리시킨다. 
또한 뷰에는 데이터를 포함시키지 않고 조금은 레이아웃별로 역할에 충실해서 데이터를 흘려보내려는 노력을 한다. 

# 6장 경로 탐색하기
## 1. 새로운 코드베이스에 자주 들어가보았는가? 익숙하지 않은 코드로 작업하기 수월했는가? 
## 프로젝트 탐색에 사용하는 일반적 도구가 있는가? 이 무기고에 어떤 도구를 넣을 수 있겠는가? 
자주는 아니지만 안드로이드 과제를 접해본적이 있다. 작업까진 아니었지만 생소한 자바코드를 읽는 것이 힘들었다. 
완전 난해한 것은 아니었지만? 그래도 익숙치는 않았고 탐색에 사용하는 툴은 GPT를 사용하니 수월했다. 
요즘은 LLM을 통해 프로젝트를 분석하는게 많은 도움이 된다. 시간 절약도 되고 구조 파악을 더 잘할 수 있다. 

## 2. 아직 완전히 이해하지 못한 시스템에 새 코드를 추가할 때 사용할 수 있는 몇가지 전략을 
## 기술하라. 기존 코드를 (그리고 자신도) 보호하기 위해 사용하는 방어책으로는 어떤 것이 있는가? 
글쎄.... 왠만하면 구조를 다 파악하고 새로운 코드를 넣어야 버그도 없고 기능도 잘 동작하는 편이다. 
만약에 구조를 다 파악하지 못한채로 수정을 해야한다면... 사용한 패러다임에 따라 관점이 다를 것 같다. 
객체지향이라면 수정할 때의 상태를 먼저 파악하고 입력과 출력을 통해 어떻게 연결 시킬지를 따져볼 것 같다. 
함수형이라면 파이프라인에서 나오는 출력을 가공해서 다른 입력으로 넣어서 기대하는 함수 동작으로 동작하게 하면 되지 않을까? 
기존 코드를 보호하기 위한 방어책...이라면 기존 코드를 건들지 않고 원하는 결과를 도출하는 새로운 분기를 만들어보는 것? 

## 3. 새 직원이 코드를 더 쉽게 이해할 수 있도록 하려면 어떻게 해야하는가? 현재 프로젝트의 상황을
## 더 향상시키려면 지금 무엇을 해야하는가?
새 직원이 코드를 더 쉽게 이해하려면, 코드를 직접 설계해서 작성할 수 있는 경험이 많이 쌓이면 좋다고 생각한다.  
그러면 왜 이렇게 설계했는지? 왜 이렇게 의도했는지?를 매뉴얼이 없어도 코드를 분석하면서 파악할 수 있지 않을까? 
지금 현재 새직원인 나는 잘 정리된 문서가 있을 때 참고하여 이해가 더 잘되고... 
변수명이 잘 짜여졌을 때 이해가 잘된다. 그리고 구조를 나타내는 개념도가 있으면 좋다. 

## 4. 이후의 코드 작업 기간에 따라 기존 코드를 알아가는 노력이나 태도가 달라지겠는가? 
## 더 이상 유지보수할 필요가 없으며 이후 다른 사람들이 작업해야 하는 코드에 대해, 
## '빠르고 더럽게' 수정 작업을 수행하는가? 이는 적절한가? 
아직 더이상 유지보수가 필요 없는 프로젝트를 받아본 적이 없다. 
프로젝트를 받으면 좋은 부분도 있지만 개선이 필요한 부분도 눈에 들어온다. 
이런 부분들을 빠르고 더럽게 수정하기 보다는 근본적으로 구조를 파악해서 수정에 용이하게 바꿔 놓는 편이다. 

# 7장 똥통에서 뒹굴기
## 1. 어쨰서 코드는 자주 똥 덩어리가 되는 것일까? 
게을러서 일 수도 있고, 너무 잦은 변경으로 유지 보수를 마지막에 하려고 안하다가 결국엔 안하거나... 
사용하는 기술에 대한 이해가 부족해서 임시 방편으로 쓰레드를 갖다 써서 틀어막았거나... 
설계가 계속 변경되서 짜집기 하다보니 구조가 이상해지거나... 
처음부터 모든 확장성을 고려할 수 없기 떄문에 발생할 수도 있어 보인다. 
종국에는 날 잡아서 구조를 계속 바꿔서 유지보수할 수 있도록 코드를 수정해야 하면 좋다고 생각한다. 

## 2. 어떻게 하면 작업을 시작하는 단계부터 이런 일을 방지할 수 있을까? 가능하기는 한가? 
모든 것을 예측할 수는 없다. 조금은 실패나 설계가 변경될 수 있다는 유연함을 갖는 마음가짐이 있으면 좋지 않을까 싶다. 
완벽하기 위해서 공들여서 설계해도 변하지 않는 것은 없다. 다만 변한다는 가정을 미리 하고 구조가 추가 삭제 될 수 있다는 점을 감안하면 좋을 것 같다. 

## 3. 코드 레이아웃 변경과 코드 기능을 분리하는 것의 장점은 무엇인가? 
코드 레이아웃 변경은 꼭 장점만 있을지는 모르겠으나, 잘 짜여진 레이아웃은 약속된 규칙처럼 수정할 포인트를 잘 찾아갈 수 있게 해준다. 
코드 기능을 분리하는 것은 1000줄을 스크롤 하면서 코드를 보는 것 보다, 기능 단위로 파일을 살펴보면 되서 편한 것 같다. 

## 4. 보기 싫은 코드에 얼마나 자주 맞닥뜨렸는가? 정말 그 코드가 심각했던 경우가 잦았는가? 
## 아니면 그저 입맛에 안맞았던 것은 아닌가? 
냉정하게 생각해보면 입맛에 안맞은 경우가 훨씬 많은 것 같다. 그래서 오히려 내 입맛에 안맞아서 짜증이 나더라도, 원작자도 다 생각이 있어 코드를 썼고, 
비록 어설픈 부분이 있어도 나 자신도 완벽하게 코드를 짜지는 않으니까 이해하고 개선하려는 마음가짐을 갖으려고 노력한다. 
그러다 보면 꽤나 원작자의 코드의 의도도 잘 볼 수 있어서 짜증 내는 것보다 스트레스가 많이 줄어들고, 긍정적으로 코드 개선을 할 수 있는 것 같다. 
다만 아주 기본적인 것을 하지 않은 상태라면 조금은 심각하다고 생각하는 편이다. 

# 8장 오류 무시하지 않기
## 1. 코드가 로우 레벨에 의해 보고된 오류를 무시하지 않았음을 어떻게 확신할 수 있는가? 
## 코드 수준에서의 해결 방법과 프로세스 수준에서의 기법에 대해 생각해보라. 
아직 로우 레벨까지 신경쓰는 내공은 없는 것 같다. 다만 IDE에서 제공하는 프로파일 툴을 활용해서 불필요한 성능 저하를 막아볼 수 있지 않나...? 

## 2. 예외는 반환 코드처럼 쉽게 무시할 수 없다. 예외가 오류를 보고하기에 더 안전한 방법이라는 것이 이유가 될 수 있는가? 
엄밀히 말하면 예외와 오류는 다르다고 생각한다. 
예외는 정상 컨셉에 맞게 구현되지 않는 부분을 예외로 처리하는 것이고, 
오류라는 것은 정상인 부분을 잘못 만들거나 반응이 이상하게 나와서 오류라고 하는 것이다. 
따라서 예외는 엄밀히 말하면 정상 동작이 애초에 가능하게 하기 위해 만들어지는 것이고, 
오류는 모든 것이 잘 구현했어도 무언가가 잘못 구현되거나 반환되어 오류를 주는 것이다. 
따라서 더 안전한 방법이라기 보다는... 정상적인 기능 동작을 위해서 예외 처리를 하는 것이다. 
오류는 예외를 다 처리해도 발생할 수 있는 것이다. 
따라서 오류가 발생하면 오류를 잘 받아서 확인하는 방향이 맞지 않을까? 

## 3. 오류와 예외가 섞인 코드를 다룰 때 어떠한 접근 방법이 요구되는가? 
각각을 구분할 수 있는 코드를 부여하면 좋아보인다. 

## 4. 적절하지 못한 오류 처리로 실패하는 코드를 식별하는 데 어떤 테스트 기법이 도움되는가? 
테스트를 잘 안돌려봐서 모르지만, 랜덤한 값을 넣어보거나, 정상이 아닌 입력을 넣어보거나, 한계치의 값을 넣어보는게 도움이 되지 않을까? 








