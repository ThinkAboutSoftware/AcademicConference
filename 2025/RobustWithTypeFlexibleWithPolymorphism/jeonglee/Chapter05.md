## 오버로딩에 의한 다형성

### 오버로딩

함수 오버로딩은 한 함수가 여러 타입의 인자를 받아야 할 때 `이거나` 타입보다 훨씬 간단하고 직관적인 해결책을 제공하는 기능이다. 함수 오버로딩이란 같은 이름의 함수를 여러 개 정의하는 것이다. *overloading은 `너무 많음`이라는 뜻을 가지고 있기에 원래 한 이름의 함수를 하나만 정의해야 하지만, 편의상 같은 이름의 함수를 `너무 많이` 정의할 수 있도록 하는 기능이다.*

책에서 보여주는 함수 내부에서 타입 검사(사용자 if)를 할 필요 없이 오버로딩을 통해 단순하게 다형성을 추가할 수 있다. 직관적이기는 하지만 중복성은 피하기 힘들다. *실제로 이를 줄이기 위해 또 내부의 동작을 함수로 묶고 나누는 과정이 많아지면 결국 배보다 배꼽이 커지는 경우가 많다. 결국은 또 트레이드 오프*

```cs
write(c1, "hello");
write(c2, 42);
```

위와 같이 사용하는 오버로딩 함수에서 어떤 것을 호출할지는 언어 수준에서 자동으로 결정된다. 이렇게 함수가 오버로딩되어 있을 때 호출할 함수를 자동으로 고르는 것을 **함수 선택**이라 부른다.

- 함수 선택 규칙
  - 인자의 타입에 맞는 함수를 고른다.
  - 인자의 타입에 가장 특화된 함수를 고른다.
  - 함수를 고를 때는 인자의 정적 타입만 고려한다.

*어떻게 보면 오버로딩은 설계자, 제작자보다 사용자의 입장에서 조금 더 편리하게 사용할 수 있도록 하는 기능이라고 볼 수 있다.*

오버로딩은 다형성을 만들어 내는 세 번째 방법이다. (첫 번째는 서브타입, 두 번째는 제네릭) 그 이유는 `write`라는 이름은 (cell, string) => void 타입이면서 (cell, int) => void 타입인 것으로 이해할 수 있다. **write라는 하나의 대상이 여러 타입을 가지는 것이다.**

*하나의 대상이 여러 타입을 가진다는 것이 다형성의 가장 기본적인 근본이라고 생각이 된다. 오버로딩도 다형성이라고 알고는 있었지만 타입 검사 입장에서 보니 기본적인, 통일된 개념을 잘 이해할 수 있었다.*

그러므로 이 역시 다형성이다. 이렇게 같은 이름을 여러 번 정의함으로써 만들어지는 다형성을 오버로딩에 의한 다형성이라고 부른다.

오버로딩이란 `함수 오버로딩`, `메서드 오버로딩`, `연산자 오버로딩`을 모두 통틀어 일컫는 용어다.

#### 가장 특화된 함수

앞서 다훈 함수 선택 규칙의 두 번째 항목인 `인자의 타입에 가장 특화된 함수를 고른다` (더 구체화 된)은 개발자 입장에서 상당히 합리적인 규칙이다. 당연히 정의한 이유가 더 특화, 추가적인 기능이 있기 때문에 새로운 클래스를 담은 오버로딩 함수를 만들었기 때문이다.

동적 타입과 정적 타입은 실제로 다형성에서 가장 많이 다루는 개념이다. 코드상으로 보이지않는 동적 흐름을 자연스럽게 설계해야 유연한 코드가 된다.

**대부분의 언어가 함수 선택 시 정적 타입만을 고려하기 때문에 이 정적 선택을 잘 이해해야 한다.** *실제 내 의도와 다르게 동작하기 때문이다.* 가장 간단한 방법은 서브타입이 존재할 때 가급적 같은 이름으로 함수를 추가 정의하는 일을 피하는 것이다.

#### 메서드 오버로딩

메서드 오버로딩은 함수에서 메서드로 바뀌었을 뿐 개념은 같다.

### 메서드 오버라이딩

메서드 오버라이딩은 특화된 동작을 정의하는 가장 좋은 방법이다. **메서드 오버라이딩은 클래스를 상속해서 자식 클래스에 메서드를 새로 정의할 때 메서드의 이름과 매개변수 타입을 부모 클래스에 정의되어 있는 메서드와 똑같게 정의하는 것을 말한다.**

*가장 쉽게 다형성을 효과적으로 볼 수 있는 기초적인 방법*

`overriding`이라는 단어의 사전적인 뜻은 '자동으로 진행되는 동작을 사람이 개입하여 중단시킨 뒤 스스로 조작하는 것'이다. 이를 바탕으로 메서드 오버라이딩을 이해하자면 `vector`에 있던 length 메서드가 상속을 통해 자동으로 `SparseVector`에도 정의되는 것을 개발자가 개입하여 막은 뒤 기존 length 메서드와 다른 동작을 수행하는 새로운 length 메서드를 정의하는 것이다.

함수 오버로딩 즉, 메서드 오버로딩과 다른 점은 정적 타입이 `vector`라도 `sparseVector`의 메서드를 호출하여 실행한다는 점이다.

```cs
Vector v = new SparseVector();
v.length();
```

이 코드는 동적 타입으로 동작한다. **이처럼 메서드 오버라이딩을 사용하면 서브타입을 위해 더 특화된 동작을 정의하고, 정적 타입에 상관없이 언제나 그 특화된 동작이 사용되도록 만들 수 있다.** *앞서 개발자에게 더 인지적인 두 가지 동작 모두 충족*

*책에서는 타입 검사기의 측면에서 다루지만 C++을 조금 공부한다면 실제 메모리 구조 즉, 객체의 타입이 어떻게 담기고 운용되는지를 알면 이는 간단한 문제이다.*

- **메서드** 선택 규칙
  - 인자의 타입에 맞는 함수를 고른다.
  - 인자의 타입에 가장 특화된 함수를 고른다.
  - 메서드를 고를 때는 인자의 정적 타입만 고려한다.
  - 메서드를 고를 때는 수신자의 **동적 타입**도 고려한다.

#### 메서드 선택의 한계

앞서 다룬 수신자의 동적 타입을 고려한다하는 것만으로 모든 문제가 해결되지 않는다. **문제는 수신자의 동적 타입만 고려하고 인자의 동적 타입은 고려하지 않는 데서 온다.**

책에서 나오는 예제와 같이 단순한 경우에는 문제가 없지만 덧셈과 같이 타입이 다르게 나뉘는 경우(반환자와 매개변수의 차이)에서 수신자(반환자)는 정적타입이지만 메서드 오버라이딩이기에 동적 타입을 읽고, 매개변수는 그대로 정적 타입으로 해석하기 때문에 비효율적인 문제가 생길 수 있다.

이는 결국 처음에 말한 개발자의 기대와 다른 동작이 발생하는 것이다. 이를 해결하기 위해서 매개변수의 실제 타입을 뽑아낼 수 있는 `this`키워드를 사용하여 해결이 가능하긴 하다.

#### 메서드 오버라이딩 결과 타입

지금까지 다룬 매개변수에서만 오버로딩을 다뤘는데 결과타입도 마찬가지로 다형성이 가능하다. 반면 메서드 오버라이딩을 할 때는 결과 타입을 아무렇게나 해서는 안 된다. **자식 클래스에 정의한 메서드의 결과 타입이 부모 클래스에 원래 있는 메서드의 결과 타입의 서브타입이어야 한다.** *모든 타입은 자기 자신의 서브타입이니 이 조건은 두 메서드의 결과 타입이 같은 경우도 포함한다.*

*C#의 경우 오버라이딩할 때 결과 타입이 달라지는 것을 허용하지 않는다.*

또한, 동적 선택으로 인해 실행 전에 타입 검사기가 참고하는 메서드와 실제 실행 중에 호출되는 메서드가 다를 수 있다. **타입 검사기는 정적 타입밖에 모르니 수신자의 정적 타입을 바탕으로 참고할 메서드를 정하는 데 반해, 실행 중에는 수신자의 동적 타입이 호출되는 메서드를 결정하기 때문이다.**

이로 인한 문제를 막기 위해선 타입 검사기가 참고한 메서드와 다른 메서드가 호출되더라도 참고한 메서드의 결과 타입이 지켜지도록 해야 한다. 따라서 **자식 클래스가 있는 메서드의 결과 타입이 부모 클래스에 있는 메서드의 결과 타입의 서브타입이어야 한다는 조건이 꼭 필요하다.**

### 타입 클래스

이번에는 오버로딩에 의한 다형성을 매개변수에 의한 다형성과 함께 사용하는 방법을 알아볼 차례다. C#에는 존재하지 않는 기능이지만 다른 언에에선 유용하게 사용한다.

기존 정렬 .gt()메서드를 사용하여 정렬을 하는 부분에서 메서드로 두지 않고 함수를 오버로딩하여 구현하는 방법도 있다. 다만 T*(제네릭)은 아무 타입이나 될 수 있기에 타입 검사를 통과하지 못한다. 이에 상한 타입을 지정하여 이를 해결할 수 있었다.

결국 이 개념은 타입이 (T, T)인 gt함수가 있어야 한다는 조건이다. 즉, 특정 타입을 위한 함수가 존재한다는 사실을 표현하는 개념인 타입 클래스가 등장한다. *클래스라는 용어가 들어갔다고 클래스를 뜻하는 것은 아니다. 다만 타입이 만족해야 조건을 표현한다는 점에서 추상 클래스와 비슷한 역할을 한다.*

```
typeclass Comparable<T> {
  bool gt(T x, T y);
}
```

이 코드의 뜻은 "어떤 타입 T가 Comparable타입 클래스에 속하려면 매개변수 타입이 (T, T)이고 결과 타입이 Boolean인 함수 gt가 있어야 한다." 라는 뜻이다.

특정 타입을 어떤 타입 클래스에 속하게 만들고 싶다면 타입클래스 인스턴스를 정의해야 한다. 타입클래스 인스턴스를 정의할 때는 해당 타입과 타입클래스의 이름을 명시한 뒤 타입클래스가 요구하는 함수를 모두 정의하면 된다.

```
instance Comparable<int> {
  bool gt(int x, int y) {
    return x > y;
  }
}
```

마찬가지로 다른 타입도 생성하여 이 타입클래스에 속하는 인스턴스를 생성할 수 있다. 오버로딩 함수와 같이 사용가능하다. 그렇다면 오버로딩을 사용하면 되는거 아닌가? 라는 생각이 들지만 타입 클래스는 오버로딩이 가지지 못하는 장점을 가지고 있다.

우선 함수는 아무 때나 정의할 수 있지만 메서드는 클래스를 정의할 때만 정의할 수 있다. 대부분 개발자는 라이브러리에 있는 코드를 사용하는데 그 코드들은 수정할 수 없다. 따라서 클래스를 정의할 때만 메서드를 정의할 수 있다는 점이 치명적이다.

타입 클래스의 장점은 두 가지로 기존 클래스의 실질적 확장 없이도 영향을 주지 않고 확장 가능하다. 두 번째는 제네릭 타입을 다룰 때 나오는 한 번에 여러 타입을 특정 타입 클래스에 속하게 만들 수 있다. *이 장점들은 C#에서 처음엔 쉽게 대체 가능하다고 생각했지만 아니다. c#의 인터페이스로 이를 해결하려 해도 역시 기존 클래스에 영향을 주거나 서브타입을 만들어야 하고(or 어댑터 패턴), 반대로 확장 메서드의 경우도 기존 상속 구조에 영향을 주지 않는 편법이기 때문에 타입 클래스의 장점을 모두 가지지 못한다.*

또한, 추상 클래스(인터페이스)를 사용할 때 일부만 비교 가능한 선택지는 존재하지 않는다. Comparable을 상속함으로 모든 List<T>를 비교할 수 있도록 만들거나 Comparable을 상속하지 않음으로 모든 List<T>를 비교할 수 없도록 만들어야 한다.

타입 클래스는 Comparable에 속하는 각각의 T마다 List<T>를 Comparable에 속하게 만든느 타입클래스 인스턴스를 다음과 같이 한 번에 정의할 수 있다.

```
instance <T> Comparable<List<T>> requires Comparable<T> {
  Boolean gt(List<T> v1, List<T> v2) {
    gt(v1[i], v2[i]) ...
  }
}
```

이 코드는 '각각의 타입 T마다 List<T>가 Comparable에 속한다. 단 T가 Comparable에 속할 때만'이라는 뜻이다. 따라서 List<List<List<Int>>>와 같은 사용도 가능해진다.

### 카인드

카인드란, 제네릭이라는 어떤 타입도 가능하다라는 명목에서 ArrayList와 같은 타입의 값이 존재하지 않기에 이런 타입 분류를 설명하기 위해 도입된 개념이 카인드이다. *ArrayList가 Int를 받아 ArrayList<int>라는 타입을 만든다.*

- 카인드의 종류
  - `*` : 모든 타입을 받을 수 있는 카인드
    - int, string의 카인드
  - `* => *` : 타입을 받아 타입을 반환하는 카인드
    - ArrayList의 카인드
  - (*,*) => * : 두 개의 타입을 받아 타입을 반환하는 카인드
    - map

### 정리

카인드와 타입클래스는 C계열에 속하지않는 하스칼, 러스트등에 존재하는 개념들이라 어색했지만 차이점과 장점에 대해서 알게 되서 다른 언어에 대한 흥미도 생긴 것 같다. 오버로딩 또한 단순하게 사용만 하다보니 실제 타입 검사기의 규칙에 대해서 생각해보지 않았다. 그 이유는 명확하고 C#의 설계 이념도 알아볼 수 있어서 좋았다.

### 논의사항

타입 클래스의 장점에 대해서 접하다 보니 C#의 인터페이스나 추상 클래스의 경우 미리 설계해야 한다는 점 그리고 나아가 객체지향적으로 설계하여 지속적인 확장과 수정이 가능하도록 하는 것과 비교하여 타입 클래스는 좀 더 단순하게 사후에도 확장이 가능하다는 것이 매력적으로 느껴집니다.

물론 객체지향적으로 작성한 코드도 충분히 확장 가능하지만, 타입 클래스에 비해 더 많은 고민과 설계가 필요하기에 (실제 개발에서 자주 발생하기에) 반대로 타입 클래스의 단점에 대해서 논의해보면 좋을 것 같습니다.

제 생각에는 타입 클래스를 너무 남발하게 되면 다른 설계에서 말하는 오용하거나 불필요한 확장, 최적화가 되지 않을까? 생각도 들고 반대로 다양한 타입을 대처하기 위한 인스턴스 남발로 인한 중복성도 걱정됩니다 (수정시 모든 정의 수정해야함)
