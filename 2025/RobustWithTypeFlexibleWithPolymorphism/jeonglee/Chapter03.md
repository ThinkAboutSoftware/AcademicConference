## 매개변수에 의한 다형성

### 제네릭 함수

**매개변수에 의한 다형성은 타입 매개변수를 통해 다형성을 만드는 기능으로 제네릭스(genericss)라고도 부른다.** 매개변수에 의한 다형성 즉, 제네릭은 대부분 현대의 언어에서 지원하기에 매우 유용하게 사용되고 있다. 기본적인 STL, 컨터에너 등 언어 차원에서 지원하기에 이점을 체감하기엔 없는 상황을 가정하는 것이 더 효과적일 것 같다.

책에서도 마찬가지로 기계를 예로, 없는 상황과 실제 없을 경우 함수를 제작하는 과정의 복잡함을 보여준다. 일종의 중복성을 줄이는 궁극의 기술같은 느낌이다. 제네릭의 핵심은 사실 매개 변수를 통해 타입을 넘겨줌으로서 타입 검사기가 해당 타입을 인식하도록 하는 것이다.

하지만, 항상 트레이드 오프가 따라오는 것 처럼 만능이 아니다. 예제에 나오는 `return v1 * v2 * v3;`의 경우 정수값은 문제 없지만 무슨 타입이든 가능하기에 * 연산자를 정의하지 않은 사용자 정의 클래스는 말이 되지 않는다. 이런 문제를 방지하기 위해 애초에 정의하는 것을 허락하지 않는다.

```cs
T choose<T>(T v1, T v2) {return ... ? v1 : v2;}

string str = choose<string>("Korean", "Foreigner");
int num = choose<int>(1, 2);
```

- 다만 C#의 경우 where을 사용하여 제약을 통해 기본 연산자를 가진 제네릭을 만들 수 있다.

```cs
public static T Multiply<T>(T v1, T v2, T v3) where T : INumber<T>
{
    return v1 * v2 * v3;
}
```

#### 제네릭 메서드

제네릭 함수와 제네릭 메서드의 차이는 클래스 안에 정의된다는 점만 제외하면 동일하다.

#### 타입 인자 추론

위 매개변수에 의한 다형성은 코드 중복을 크게 줄여주는 대신 매번 타입 인자를 써 줘야 하는 점이 불편하다. 이러한 불편함을 해소하기 위해 매개변수에 의한 다형성을 제공하는 대부분의 언어는 타입 인자 추론을 함께 제공한다. **타입 인자 추론이란 타입 추론의 일종으로 제네릭 함수나 제네릭 메서드를 호출할 때 개발 자가 타입 인자를 생략할 수 있도록 하는 기능이다.**

타입 검사기 기준으로 앞서 다룬 타입 추론과 동일하게 동작한다. 마찬가지로 코드가 복잡해질 경우 타입 검사기가 타입 인자 추론에 실패할 수 있다.

#### 힌들리-밀너 타입 추론

대부분의 언어는 제네릭 함수를 **사용할 때** 타입 추론을 해서 타입 인자를 찾는다. 하지만 일부 언어에서는 더 나아가 제네릭 함수를 정의할 때 타입 추론을 한다. 이런 방식을 `힌들리-밀너 타입 추론`이라고 한다.

타입 매개변수를 쓰지 않아도 함수가 자동으로 제네릭 함수가 될 수 있다는 말로 매개변수 타입과 결과 타입까지도 추론한다. 즉, 일반적인 함수처럼 정의해도 저절로 제네릭 함수가 되는 것이다. 위에서 말한 곱하기 제네릭의 경우에는 타입 검사기가 제네릭으로 만들지 않는다.

이러한 과도한 추상화에 항상 따라오듯 힌들리-밀너 타입 추론은 양날의 검이다. 이러한 기능은 편리하지만 그 의도나 동작 방식을 이해하지 못한다면 수정하기 매우 어려워진다.

### 제네릭 타입

타입 매개변수를 추가할 수 있는 곳은 함수뿐이 아니라 타입에 타입 매개변수를 추가하면 제네릭 타입이 된다. 제네릭 타입은 필수적으로 사용하는 자료형에도 유용하게 사용된다.

List의 예제와 같이 제네릭 타입의 필요성은 단순한 함수에서도 볼 수 있다. 타입 검사기가 있는 한 동작하는 함수에서 무슨 타입인지 인지할 수 있어야 한다.

제네릭 함수는 제네릭 타입을 다룰 때 더욱 유용하다. 실제로 리스트를 다루는 함수들은 아무 리스트나 인자로 받기 때문인데, 리스트의 + 연산을 사용하는 경우 같은 타입은 문제없이 동작하기 때문에 타입 매개변수만 존재한다면 문제가 없다. *단, 대부분의 언어는 타입 인자 추론을 제공하기에 `List(1, 2, 3);`만 써도 대개 타입 검사를 통과한다.*

#### 제네릭 클래스

개발자가 직접 제네릭타입을 정의하고 싶은 경우도 있기에 제네릭 클래스를 사용하여 정의할 수 있다.

### 무엇이든 타입

무엇이든 타입은 `보편 양화 타입`이라고 불리기도 한다. 이 타입은 제네릭 타입을 받는 함수 자체를 매개변수로 전달할 때 유용하다. 책에서 나오는 예제의 경우 `simulate`의 매개변수 `rand`에는 무엇이든 타입이 들어가야 한다. `List<int> => int`나 `any`또한 문제가 생긴다. *제네릭 함수로 변경해도 마찬가지*

```
void simulate(forall T.(List<T> => T) rand) { ... }
```

rand의 타입인 `forall T.(List<T> => T)`는 `forall T.A` 형태로 부른다. T는 타입 매개변수를 의미하고 A는 타입을 의미한다. List<T> => T 형태는 T가 무엇이든 될 수 있다는 것이다.

무엇이든 타입을 제네릭 함수의 타입이라고 생각하면 된다. 제네릭 함수를 값으로 사용하면 그 타입이 무엇이든 타입이 되고, 무엇이든 타입의 값을 사용할 때는 제네릭 함수를 사용하듯이 하면 된다.

무엇이든 타입이 없는 언어라도 제네릭 메서드가 있다면 비슷한 코드를 작성할 수 있다.

### 무엇인가 타입

무엇인가 타입은 '존재 양화 타입'이라고 번역할 수 있다. 무엇인가 타입이 필요한 경우는 프로그램이 상당히 복잡할 때 제대로 드러난다.

책에서 보여주는 타임스탬프 예제의 문제를 해결하기 위해선 타임 스탬프 타입을 라이블ㄹ리 사용자에게 숨겨야 한다. Int임을 알려 주는 대신 타임 스탬프의 타입이 되는 '무엇인가'가 존재한다고만 알려주는 것이다. 따라서 사용자는 타임스탬프의 타입이 되는 '무엇인가'가 있다는 사실은 알지만, 그 타입이 특정한 타입이라는 기대를 가지고 코드를 짤 수는 없다.

이런 일을 가능하게 하는 것이 무엇인가 타입이다. 라이브러리의 입장에선 교체되는 타입에 대해서 자유롭지만, 사용자 입장에서 추가적인 구현은 타입 검사를 통과하지 못한다.

일반적으로 정적 타입 언어가 제공하는 기능들은 더 많은 프로그램이 문제없이 타입 검사를 통과할 수 있도록 돕는다. 반면 무엇인가 타입의 역할은 정반대다. 오히려 타입 검사를 통과할 수 있는 프로그램이 타입 검사를 통과하지 못하도록 방해한다. 필요없는 능력같아 보이지만 실상은 매우 중요하고 필요하다.

라이브러리 제작자 입장에서는 사용자의 행동을 제약할 필요가 있다. 사용자가 특정 조건을 만족한다고 가정해야 코드를 작성하기 쉽거나 앞으로 코드를 고치기 유리하기 때문이다.

### 논의 사항

제네릭 타입에 대해서 책을 통해 다시 한번 정리하면서 패턴을 구조화할 때 인터페이스 말고도 제네릭으로도 강제할 수 있겠다는 생각이 들었습니다.

C#의 경우 where키워드를 통해 제약을 걸 수 있기 때문에 state패턴을 예로 인터페이스나 추상 클래스로 서브타입을 강제하는 방법과 제네릭 클래스를 만들어 강제하는 방법이 있을 것 같습니다. 전통적인 방법은 전자이나 후자의 경우가 좀 더 제약적인 부분에서 강력하게 제한할 수 있지 않을까? 라는 생각과 후반에 나오는 무엇인가 타입과 같이 라이브러리를 제작한다면 제네릭으로 하는 편이 더 좋은 것인가? 라는 생각이 듭니다.

*논의사항보단 답이 쉽게 나오는 질문이 아니라 생각나는 내용이라 적었습니다..*