### 4.1 제네릭 클래스와 상속
제네릭 클래스가 있을 때 타입들 사이의 서브타입 관계는 어떻게 될까?

A가 B를 상속하면 A가 B의 서브타입이다. 이 원리가 제네릭 클래스에서도 그대로 적용된다. 따라서 각각의 타입 T마다 ArrayList\<T>와 LinkedList\<T>는 List\<T>의 서브타입이 된다.

예시로 ArrayList\<Int>와 LinkedList\<Int>는 List\<Int>의 서브 타입이다.

여기서 의문인 점은 왜 extends List 대신에 extends List\<T>를 상속할까? 이유는 한 클래스가 제네릭 클래스의 타입인자가 특정 타입일 때만 상속하는 경우가 있기 때문이다.

예시로 BitVector extends List\<Boolean>과 같은 경우로 1비트의 최소한의 크기만 사용하기 위해 만들어졌기 때문에 다른 타입인자가 대신하기 어렵다.

### 4.2 타입매개변수 제한
모든 타입을 가지고 있지 않지만 그렇다고 한 타입도 아닌 몇몇 타입을 가지고 있는 경우의 능력도 존재한다. 이를 사용할 때 어떤 문제를 일으킬 수 있을지 살펴보고 이를 타입매개 변수 제한을 통해 해결하는 과정을 살펴보자.

```cpp
class Person {
	Int age;
	...
}
class Student extends Person { ... }

T elder<T>(T p, T q) {
	return (p.age >= q.age) ? p : q;
}
//위의 경우 T에 String, Int가 들어갈 수 있으며 이럴 경우 타입검사에서 걸리기 때문에 오류가 발생한다.

//T가 아닌 Person 으로 축소시킨다면?
Person elder<Person>(Person p, Person q) {
	return (p.age >= q.age) ? p : q;
}
//문제는 인자로 Student 타입을 받을 수 있는데 반환값이 Person이여야만 한다는 점이다. (정보 손실이 발생)

//위의 두 가지 경우의 각각의 문제점에 대해서 한 번에 해결하는 방법은 아래와 같다.
T elder<T <: Person>(T p, T q) {
	return (p.age >= q.age) ? p : q;
}
//위의 코드처럼 T의 타입을 Person의 서브타입으로 제한하면 두 가지의 문제점을 해결 가능하다.
```
T <: Person 의 의미는 T의 상한선이 Person이라는 뜻으로 "T가 Person의 서브타입이다" 와 같다.

```cpp
T elder<T <: { Int age; }>(T p, T q) {
	return (p.age >= q.age) ? p : q;
}
//위의 경우 정수 필드 age만 가지면 { Int age; }의 서브타입이므로 타입인자로 사용가능하다.

T foo<T >: Person>(T t) { ... }
//위의 경우는 T가 Person의 슈퍼타입이라는 뜻으로 foo<Person> 혹은 foo<Any> 가 가능하다.

T foo<T <: Person >: Student>(T t) { ... }
//위의 경우는 T가 Person의 서브타입이면서 Student의 슈퍼타입인 경우 타입인자로 사용가능하다 라는 의미이다.
```

**재귀적 타입 매개변수 제한**
타입 매개변수가 자기 자신을 제한하는 데 사용될 수 있다. 이를 재귀적 타입 매개변수 제한이라 부른다. 이는 어떤 경우에 필요할까?

```cpp
Void sort<T <: Comparable<T>>(List<T> lst) {
	...
	if (lst.get(i).gt(lst.get(j))) { ... }
	...
}
```
sort의 타입 매개변수 T가 Comparable\<T>를 상한으로 갖는다. T의 상한에 T 자기 자신이 사용되었기 때문에 이 코드를 재귀적 타입 매개변수 제한의 예시로 볼 수 있다.

### 4.3 가변성
가변성은 제네릭 타입 사이의 서브타입 관계를 추가로 정의하는 기능이다. 상속은 List와 ArrayList처럼 서로 다른 제네릭 타입 사이의 서브타입 관계를 만든다. 반면 가변성은 하나의 제네릭 타입에서 타입 인자만 다르게 하여 얻은 타입들 사이의 서브 타입 관계를 만든다. 가변성은 왜 필요하며 어떤 서브 타입관계를 만들까?

B가 A의 서브타입일 때 List\<B>가 List\<A>의 서브타입이어도 될까? 결론은 그럴수도 있고 아닐 수도 있다. 만약 리스트가 있을 때 원소 읽기만 허용하면 그래도 되고, 원소 추가도 허용하면 그렇지 않다.

예시로 List1 이 있을 때 이는 들어있는 원소만 알려주는 리스트로 원소를 추가하거나 제거할 수 없는 리스트다. 이 경우에 List1\<Student>는 List1\<Person>의 서브타입이여도 괜찮다.

List2는 List1보다 더 많은 기능을 제공한다고 하자. 제공하는 기능으로 원소들을 알려주고 새 원소를 추가하는 것을 허용한다.
```cpp
abstract class List2<T> {
	T get(Int idx);
	Void add(T t);
}

List2<Student> students = ...;
List2<Person> people = students;

people.add(Person(...));

Student s = students.get(...);
s.gpa
//여기서 오류가 발생 이유는 Person에는 없고 Student에 gpa필드가 있는 경우 이를 읽을 수 없기 때문이다. 타입검사를 통과했지만 오류를 일으킴. 타입검사기의 타입안전성을 깨트리는 문제.
```
어떤 제네릭 타입은 타입 인자의 서브타입 관계를 보존하지만 어떤 제네릭 타입은 그렇지 않다. 결국 제네릭 타입과 타입 인자 사이의 관계를 분류할 수 있다. 이 분류를 가변성이라고 한다. 가변성이란 결국 제네릭 타입과 타입 인자 사이의 관계를 말한다. 여기서 앞에서 살펴 본 것처럼 서브타입 관계 보존 여부에 따라 두 가지 가변성이 발견된다.

첫 번째 가변성은 '공변'이라 하며 제네릭 타입이 타입 인자의 서브타입 관계를 보존하는 것이다. List1이 여기에 해당하며 B가 A의 서브타입일 때 List1\<B>가 List1\<A>의 서브타입이다.

두 번째 가변성은 '불변'이라 하며 제네릭 타입이 타입 인자의 서브타입 관계를 무시하는 것이다. List2가 여기에 해당한다. B가 A의 서브타입이더라도 List2\<B>와 List2\<A> 사이에는 아무런 관계가 없다. List2\<B>와 List2\<A>가 다른 타입인 것이다.

세 번째 가변성은 '반변'으로 제네릭 타입이 타입 인자와 반대로 변한다 라는 의미이며 제네릭 타입이 타입 인자의 서브타입 관계를 뒤집는다. 결과 타입을 C로 고정할 때 B가 A의 서브타입이면 B => C는 A => C의 슈퍼타입이다. 타입 인자가 A에서 서브타입인 B로 변할 때 A => C는 타입 인자와는 반대 방향으로 움직여 슈퍼타입인 B => C로 변한다고도 할 수 있다.

타입 검사기의 서브타입 판단 방법이 두 가지인 것처럼 가변성 판단 방법 역시 두 가지다. 하나는 개발자가 제네릭 타입을 정의할 때 가변성을 지정하도록 한 뒤 그에 따르는 것이고, 다른 하나는 사용할 때 가변성을 지정하도록 한 뒤 그에 따르는 것이다. 

**정의할 때 가변성 지정하기**
가변성은 제네릭 타입의 고유한 속성이다. 따라서 제네릭 타입을 정의할 때 가변성을 지정하는 게 가장 직관적이다. 개발자는 제네릭 타입의 각 타입 매개변수에 가변성을 표시함으로써 공변, 불변, 반변 중 하나를 고를 수 있다. 아무런 표시가 없다면 기본으로 불변이 선택된다.
```cpp
//특정 타입 매개변수가 공변인 경우 out 사용
abstract class ReadOnlyList<out T> {
	Int length();
	T get(Int idx);
}

//타입 매개변수를 반변으로 만들 경우 in 사용
abstract class Map<in T, S> {
	Int size();
	S get(T t);
	Void add(T t, S s);
}
```
