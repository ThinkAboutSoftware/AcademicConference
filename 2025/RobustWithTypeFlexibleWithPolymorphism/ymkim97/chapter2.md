# 타입으로 견고하게 다형성으로 유연하게

## 2장 - 서브타입에 의한 다형성

---

Java에 익숙하다보니 이번 챕터의 1절은 크게 어려움 없이 잘 읽었으나, 무의식적으로 당연하게 알앗던 것을 다시 한번 구체적으로 글로 보는 것이 신선한 느낌이 듭니다.
대신 Java에서 사용되는 이름에 의한 서브타입이 아닌, 구조에 의한 서브타입을 처음으로 알게되었고 정말 특이하고 신기하게 느껴졌습니다.

2절에서는 최소 타입의 설명 중 박스를 예시로 들었던 부분이 꽤 흥미있고 재밌었습니다.
계산이 끝난다면 그 상자가 열리고 값을 꺼내 볼 수 있지만, 계산을 끝마치지 못하면 상자가 열릴 일도 없다는 것이 처음에는 이해가 되지 않았지만, 예외 처리를 통해 어느정도 이해할 수 있었습니다.

3절은 아직 저에게 익숙하지 않은 일급 함수가 주로 사용되어 함수 타입 사이의 서브타입 관계를 바로 이해하기 어려웠습니다.

### 2.1 객체와 서브타입

객체라는 개념이 있는 정적 타입 언어라면 일반적으로 서브타입에 의한 다형성도 제공한다.
필드를 정의한다는 것은 필드의 타입과 이름을 쓴다는 것이다.
필드를 미리 정의해야 하는 이유는 타입 검사기가 필드 정의에서 타입을 찾아 필드의 값을 검사하기 때문이다.
클래스는 객체의 설계도로서 객체가 어떤 필드와 메서드를 가지는지 정의한다.
이는 클래스가 각각 자신만의 정의를 가지고 있고, 타입 관점에서 각 클래스가 새로운 타입을 정의한다고 볼 수 있다.
따라서 같은 클래스로 만들어진 객체끼리는 같은 타입이다.

```java
void sendEmail(Person person, String title, String content) {
	String email = person.email;
	...
}

for (int i = 0; i < students.length; i++) {
	Student st = students[i];
	if (!st.paid) sendEmail(st, ..., ...,); // 서브타입에 의한 다형성 덕분에 통과
}
```

- A는 B다 -> A는 B의 서브타입이다.
- B는 A의 슈퍼타입이다.
- A가 B의 서브타입일 때 A 타입의 부품을 B 타입의 부품으로도 간주할 수 있게 해주는 것이 서브타입에 의한 다형성이다 -> B 타입의 부품이 요구될때 A 타입의 부품이 와도 문제가 되지 않는다.

타입 검사기가 객체 타입의 서브타입 관계를 판단할 때 사용하는 규칙은 두가지.

- **이름에 의한 서브타입(nominal subtyping)**
  타입이 보여주는 클래스의 이름과 클래스 사이의 상속 관계만 고려한다.

- **구조에 의한 서브타입(structual subtyping)**
  클래스 사이의 상속 관계 대신 클래스의 구조, 즉 각 클래스에 어떤 필드와 메서드가 있는지 고려한다.

```javascript
class Person {
  email: string;
}
class Student {
  email: string;
  grade: number;
}

function sendEmail(person: Person): void {
  let email: string = person.email;
}
let st = new Student();
sendEmail(st);
```

**추상 메서드:** 메서드를 정의하지는 않되 ‘이 클래스를 상속하려면 특정 메서드를 반드시 정의해야 한다’는 사실을 표현하는 것이 추상 메서드의 용도다.

**메서드의 시그니처(Signature):** 이름, 매개변수 타입, 리턴 타입 -> 타입 검사를 할 때 메서드의 서명 같은 존재

**추상 클래스:** 추상 메서드를 가지는 대신 객체를 직접 만들 수 없는 클래스

### 2.2 집합론적 타입

최대 타입은 모든 값을 포함하는 타입이다.
어느 값이든 최대 타입에 속하며 이 정의에 따라 모든 타입은 최대 타입의 서브타입이라는 사실을 알 수 있다.
다시 말해 최대 타입은 모든 타입의 슈퍼타입이다.

최소 타입은 어떤 값도 속하지 않은 타입이고, 모든 타입의 서브타입이다?
즉, 함수가 계산을 끝마치지 못한다는 사실을 나타내며, 특히 예외를 다루는 데 유용한 타입이다.
최소 타입의 가장 중요한 특징은 모든 타입의 서브타입이라는 것이다. -> 그래서 메서드의 리턴 타입에 관계없이 어디서든 Error를 throw 할 수 있다.

이거나 타입(Union type)은 두 개의 타입으로부터 만들어진다.
A | B라 쓰며 직관적으로 ‘A 이거나 B’를 나타낸다.
이 타입을 사용할 때는 한 가지 주의할 점이 있고 이를 알기 위해서는 “위치에 민감한 타입 검사(flow-sensitive type checking)라는 개념을 이해해야 한다.
변수의 값을 읽는 부품의 타입을 검사할 때 해당 변수가 정의된 곳의 타입 표시만 보는 것이 아닌, 그 변수가 어디서 사용되는지도 고려하는 것이다.

이면서 타입(Intersection type)은 다중 상속을 다룰때 유용하다.
A & B라 쓰며 직관적으로 ‘A 이면서 B’를 나타낸다.

### 2.3 함수와 서브타입

**일급 함수(first-class function):** 함수를 변수에 저장하거나 다른 함수에 인자로 전달하거나 다른 함수에서 반환 될 수 있는 함수.

함수 타입은 그 자체만으로는 서브타입에 의한 다형성을 필요로 하지 않지만, 언어에 객체와 서브타입에 의한 다형성이 존재하면 함수 타입 사이의 서브타입 관계를 따질 필요가 생긴다.

함수 타입은 매개변수 타입의 서브타입 관계를 뒤집는다.

Person -> Boolean 이 Student -> Boolean의 서브타입인지 확인하기 위해서는 ‘적어도 사람은 인자로 받을 수 있는 함수는 학생을 인자로 받을 수 있는 함수다’가 사실인지 보면 된다.
이를 통해 Person -> Boolean은 Student -> Boolean의 서브타입이다.

A가 B의 서브타입일 때 B -> C가 A -> C의 서브타입이고 그 반대는 성립되지 않는다.

## [논의 내용]

- 얼핏 보기에는 Union type 또는 Intersection typ이 사용하기 편해 보이는데, 해당 type을 실제로 많이 적용하는지, 또한 사용하시는 분은 여러 번 사용하시는지 궁금합니다.
