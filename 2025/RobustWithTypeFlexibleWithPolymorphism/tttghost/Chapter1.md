## 1장 타입 검사 흝어보기
최대한 `이해하기 쉽게` 써보려고 했습니다. 

**'씨줄과 날줄'** 이라는 표현이 좋아 블로그의 한 글을 인용하며 시작하겠습니다.

> 타입 시스템이 왜 필요한가를 생각하면 씨줄과 날줄이라는 표현은 아주 적절하다.  
>타입 시스템의 본분은 개발자가 만드는 프로그램을 안전하게 만드는 것이다.  
>마치 직조하여 씨줄과 날줄을 꼼꼼하게 짜서 튼튼한 천을 만드는 것 처럼,  
>촘촘한 타입 시스템을 통해 안전한 프로그램을 만들 수 있다. 물론 서두에 쓴 것처럼  
>그냥 '사용'하는 것과 '활용'하는 것은 다르다.  
>그래서 타입 시스템이 어떻게 동작하는지, 무엇을 제공하는지 잘알고 사용하는 것이 중요하다.  

[출처 : https://kciter.so/posts/warp-and-weft/]

---
### 1.1 타입 검사의 정의와 필요성
타입이란 존재하는 능력에 따른 변수들을 말한다.  
"abc", true, 1 과 같이... 이 타입들은 고유의 능력을 가지고 있다.  
정수형 타입은 사칙연산이 가능하고 문자열 타입은 몇번째 인덱스의 문자가 무엇인지 알 수 있다.  
각 타입의 능력을 벗어나는 행위를 하면 오류를 발생시킨다.  

작성한 코드의 타입능력을 벗어나는 버그행위를 찾는 가장 확실한 방법은 프로그램을 실행하는 것이다.  
하지만 이 행위는 단점이 존재하는데 가변적인 초기상태 변화나 시간적 여유가 없는 상태에서   
충분한 테스트를 하지 못하고 배포를 했을 때 나오는 버그 등.. 이 있을 수 있다.

이러한 문제를 해결하기 위해 타입검사기 라는 것을 사용한다.   
C#의 경우 컴파일러가 소스 코드를 분석하여 타입 오류를 찾아낸다.  

### 1.2 정적 타입 언어
타입검사기 제작은 언어를 만든 사람들의 몫이다 -> 즉 제작할 필요 없이 잘 이해하면 된다는 뜻 이다.  
'정적' 이라는 단어는 '프로그램을 실행하기 전에' 라는 뜻 이다.   

**다시한번 강조 '프로그램을 실행하기 전에'**

이 행위는 컴파일러에서 컴파일을 하는 것이라고 할 수 있다. 정말 중요하다.  

이와 대비되는 것으로 동적 언어는 **사전에 컴파일** 되는 행위가 없고 **런타임 단계에서 타입이 결정**된다.  
이 때 발생할 수 있는 문제는 100시간 짜리 프로그램을 다 실행해 보지 못한 상태에서 배포가 되었는데  
80시간이 지났을 때 버그가 발생 한다면? 큰 문제일 것이다. 동적 타입은 이와같은 문제가 발생할 소지가 있다.  


### 1.3 타입 검사의 원리
타입검사의 원리를 자동차공장에서 자동차 검사 하는 것을 예로 들었는데 좋은 예 인것 같다.  
건담을 조립해 본 적이 있는데 건담 조립 시 서로 비슷비슷한 물체 같지만 서로 홈이 맞아 떨어지고 그렇게 완성된   모듈은 다른 모듈과 결합되고 하는 부분이 이 책의 설명과 비슷한 느낌으로 다가와 읽기 수월했다.  

책에 나와있는 내용 중 리터럴 내용은 PrintInt(5+7)+9가 있는데 먼저 5와 7이 가장 작은 리터럴 이고 이 두개의 타입은 int형이다.  
이 타입은 사칙연산이 가능하기에 5+7은 true, 그럼 결과값을 반환하고 여기에 그다음 부품인 9를 더한다.  
반환된 값도 int 형 이라고 가정하고 여기에 9를 더하는 것도 int형 타입이기에 true.

건담의 작은 부품들을 순차적 조립하는 것과 연관지어 생각하니 이해가 잘 되었다.  
**타입 검사기**를 건담 공장에서 부품 규격을 검사하는 도구라고 비교한다면  
**'홈이 맞지 않아 조립이 불가능한 상태'** 를 예시로 들어봄 직하다.  

### 1.4 타입 검사 결과의 활용
타입검사의 활용부분에서 코드편집기의 자동완성기능이 예시로 나왔는데 재미있는 예시 인 듯 하다.  
자동완성된 메서드이름에 들어가는 타입으로 내가 원하는 메서드를 구분해 찾을 수 있다는 점에 눈여겨 볼 만하다.  

### 1.5 타입 추론
타입 추론은 최근에 자주 사용하는 편이다.  
**2가지** 정도로 구분하여 예시를 들어본다.  
1. 긴 타입명을 간결하게 만드는 타입 추론
> C#을 주 언어로 사용하는데 타입명이 길어질 경우 (예 : Dictionary<int, List<string>>) 생성자 생성 시  
Dictionary<int, List<string>> temp = new Dictionary<int, List<string>>(); 와 같이 길어질 수 있다.  
이런 경우 생성하는 시점에서 타입을 알 수 있기 때문에 앞의 타입을 var로 변경하여  
var temp = new Dictionary<int, List<string>>(); 로 가독성이 좋아지고 간결해진다.  

2. 컴파일러가 결과 타입을 명확하게 알수있는 타입 추론
```c#
var sum = 1+2;
```
혹은

```c#
var sum = SumResult(1+2);
int SumResumt(int a, int b)
{
    return a+b;
}
```
와 같이 컴파일러가 타입을 명확히 추론할 때에도 사용할 수 있다.

### 1.6 더 세밀한 타입
타입 오류가 아닌데도 버그가 발생할 수도 있다. 이를테면 나눗셈을 할 때 0으로 나누는 것처럼.  
하지만 타입 오류가 아닌 것도 타입 검사가 해결해 줄 수 있다. 놀랍지 않은가?  

비밀은 타입이라는 것을 정의하고, 그 `능력` 속에 있다고 한다.  
앞에서 타입은 "프로그램에 존재하는 값들을 그 능력에 따라 분류한 것"이라고 했는데,  
여기서 "능력" 이란 타입이 수행할 수 있는 연산이나 동작을 의미한다.  
예를 들어, `int` 타입은 산술 연산이 가능하고, `string` 타입은 문자열 연결을 수행할 수 있다.  
이 능력은 타입의 개념 자체에 내재된 것이 아니라, 언어 설계자가 관심 있는 능력을 기준으로  
값을 분류하면서 만들어지는 것이다.

**타입의 정의는 언어마다 다를 수 있다.**

null 접근을 생각해 보자. null 접근이 오류인 언어도 있고, 아닌 언어도 있다.  
- C#에서는 null 접근 시 예외를 발생시킨다.
```csharp
  string str = null;
  Console.WriteLine(str.Length); // NullReferenceException 발생
```

- Kotlin에서는 null-safe 연산자를 제공해 이러한 문제를 방지한다.
```kotlin
var str: String? = null
println(str?.length) // null-safe 연산자 사용
```
null 접근이 오류가 아닌 언어는 타입을 좀 더 유연하게 사용할 수 있다는 뜻이다.  
하지만 이 경우 사용자에게 타입에 대한 더 많은 책임이 요구된다고 볼 수 있다.  

즉, 타입의 설계는 유연성과 책임 사이의 균형을 찾는 과정이라고 볼 수 있다.  

### 1.7 정적 타입 언어의 장단점
정적 타입은 여러가지 장점을 가지고 있다.  
하지만 무조건 정적 타입 언어가 좋은것은 아니다. 동적타입 언어가 좋을 때도 있다.  
예시로 타입추론을 하지 않으면 타입 표시 때문에 코드가 장황해 질 수 있다.  
C# 으로 주 개발을 하기에 타입추론 var가 명확하지 않다고 생각이 들어 var를 사용하지 않았었는데  
코드가 장황해지고 길어지는 경향이 생기기에 var를 활용하기 시작했다.  

프로그램의 크기가 작으면 버그도 적고 금방 고칠 수 있기에 간단하게 작성하는 동적 타입이 좋은 선택지가 될 수 있다.  
논리구조를 작성해야 할 시간에 타입표시를 붙이느라 시간을 허비하는 것 또한 정적타입의 단점이라고 볼 수 있을 것이다.  

### 1.8 다형성
정적 타입 언어의 큰 단점 -> 타입 검사기가 실제로 유효한 코드를 잘못된 코드로 판단하는 경우  
이 단점은 완벽하게 해결될 수 없다. 타입 검사기가 "거부"라고 오판하는 상황은 반드시 존재한다고 한다.  

이를 해결하는 방법으로 2가지가 존재하는데,  
- 타입 검사기의 틀 안에서 개발자를 돕는 '안전한' 기능  
- 타입 검사를 무력화하는 '위험한' 기능  

위 책에서는 안전한 기능인 다형성에 대해 이야기할 것이다.  
다형성은 타입 검사기의 틀 안에서 동작하며, 컴파일러가 타입 안전성을 보장할 수 있는 유연한 설계 방식을 제공한다.  

다형성은 크게,  
- **서브타입에 의한 다형성**: 부모 타입으로 자식 타입을 처리하는 방식  
- **매개변수에 의한 다형성**: 제네릭 등을 이용해 다양한 타입을 처리하는 방식  
- **오버로딩에 의한 다형성**: 동일한 이름의 메서드를 매개변수나 타입에 따라 다르게 처리하는 방식  
이 있다.

## 논의 내용
- 타입추론을 자주 사용하시나요? 타입추론에 대한 생각을 공유해 보아요.
- 제네릭을 자주 사용하시나요?
- 서브타입에 의한 다형성은 잘 이해가 되지 않습니다. 논의점으로 가지고 가고 싶은데 어려운 것 같아요.