# 3장 모델 주도 설계
좋은 모델은 좋은 코드로 연결지어 품질이 좋은 소프트웨어를 만들어야 한다.

모델을 코드로 어떻게 변화시켜야 하는가? 핵심은 쉽고 정확하게 코드로 변환할 수 있는 모델을 선택해야 한다. 

분석 모델이라는 설계 기법은 분석과 코드 설계를 서로 다른 사람이 작업하는 방법이다. 분석 모델은 비즈니스 도메인 분석의 결과물일 뿐이고, 소프트웨어 구현은 염두에 두지 않는다. 이런 모델은 도메인을 이해하기 위해서만 사용된다. 이 분석 모델이 개발자에게 넘어가면 발생하는 문제는 설계 작업 수행이 어렵고 모델과 코드의 매핑 관계가 부재하게 되며 이는 결국 폐기되는 결과를 초래한다. 또한 도메인에 충실한 모델이 객체의 영속성을 고려하지 못한 상황일 수도 있어 이런 경우 개발자가 스스로 판단을 내려야 하며 이는 도메인의 일부 지식이 모델에서 탈락되는 결과를 나타내기도 한다. 이는 다시 다른 개발자들이 모델을 보고 어림짐작해 이해하는 부분이 늘어나며 도메인과 소프트웨어의 간격이 점차 벌어지게 된다.

분석 모델과 코드 설계를 분리하는 것보다 좀 더 나은 방식은 도메인 모델링과 설계를 밀접하게 관련시키는 것이다. 모델이란 소프트웨어 그 자체와 설계 고려 사항에 초점을 맞추어 만들어져야 하며, 개발자들은 모델링 프로세스가 진행되는 동안 함께 참여해야 한다.

코드와 그 기반이 되는 모델을 밀접하게 연관시킴으로써, 코드에 의미가 생기고 모델은 실재적으로 중요한 가치를 지니게 된다.

코드의 변경이 곧 모델의 변경임을 인지해야하며 모델을 아주 잘 알고 있어야 한다.

구현과 모델을 밀접하게 연관시키려면 객체지향 프로그래밍처럼 모델링 패러다임을 지원하는 개발 툴이나 언어가 필요하다. 객체지향 프로그래밍 구현과 모델이 같은 패러다임에 기초하고 있어 모델을 구현하기에 적합하다. 복잡한 도메인은 절차적 언어로는 대응하는 모델을 만들어내는 데 한계가 있다.

**계층형 아키텍처**  
도메인과 관련된 코드가 다른 레이어와 섞여 있다면 다른 사람이 코드를 읽고 이해하기가 어렵다. 그래서 복잡한 프로그램을 '레이어'로 분할해야 한다. 각 레이어 내부에서 설계를 수행하여 응집도 높고 자기 하위 레이어에만 의존하도록 만들어야 한다.

하나의 레이어에 도메인과 관련된 모든 코드를 집중시켜서, 사용자 인터페이스, 애플리케이션, 인프라스트럭쳐 코드로부터 독립적으로 만들어야 한다. 도메인 객체들은 스스로 정보를 보여주고 저장하고 애플리케이션 작업을 관리하는 등의 부가적인 책임에서 자유롭게 두고 대신 도메인 모델 자체를 표현하는 것에만 집중할 수 있도록 한다. 이렇게 설계할 때 모델은 풍부해지고 명확해져서 핵심적 업무 지식을 충분히 포착하여 동작할 수 있게 된다.

**엔티티**  
엔티티는 소프트웨어가 여러 상태를 거치는 동안 동일한 값을 유지하는 식별자를 지니는 유형의 객체이다. 이름, 생년월일, 출생지, 부모의 이름, 현재 주소 등 여러 속성의 조합이 식별자가 될 수 있다. 식별자가 같은 두 객체는 같다고 간주한다. 엔티티는 도메인 모델에서 매우 중요한 객체들이고, 모델링 작업을 시작할 때부터 깊이 고민해야 할 부분이다.

**값 객체**  
엔티티는 추적될 수 있어야 한다. 하지만 이는 추적하는데 비용이 발생한다. 하나의 객체가 도메인의 어떠한 측면을 표현하는 데 사용되지만 식별자가 없다면 이것을 값 객체라고 한다. 식별자가 없는 값 객체는 쉽게 생성되고 폐기 될 수 있다.

**서비스**  
도메인의 행위 가운데 어떤 행동이나 일부 동사는 어느 객체에도 속하지 않는다. 그럼에도 객체지향 언어에서는 객체를 행위로 포괄하는 용도로 사용해야만 한다. 기능을 그 자체만 떼어놓고 선언할 수 없다. 행위는 한 객체에 포함되어 있어야 한다.

만약 이런 유형의 행위가 여러 개의 서로 다른 클래스의 객체에 걸쳐 동작한다면 어디에 두어도 잘못된 것이다. 이런 유형의 행위가 도메인에서 식별되었을 때 가장 좋은 해결방법은 이러한 행위를 서비스로 정의하는 것이다. 서비스 객체는 내부적인 상태는 가지지 않으면서 단순히 도메인에 기능을 제공하는 목적을 지닌다.

서비스는 하나의 개념을 캡슐화하여 도메인에서 명확하게 구분되어 만들어지기 때문에, 명시적으로 선언하는 것이 훨씬 좋다.

**모듈**  
모델은 모듈로 나누어 구조화할 필요가 있다. 규모가 크고 복잡한 애플리케이션의 경우 모델은 점점 더 커지는 경향이 있기 때문이다. 모듈화는 관련된 개념과 작업을 조직화하여 복잡도를 감소시키는 개념이다.

응집도를 최대화 하기 위해 밀접한 관계를 지닌 클래스들을 하나의 모듈로 정의하는 방법이 권장된다. 응집도에도 종류가 있는데 통신 응집도와 기능 응집도가 있다.

통신 응집도는 모듈의 일부가 같은 데이터를 다룰 때 얻을 수 있다. 기능 응집도는 모듈의 모든 부분이 잘 정의된 임무를 함께 수행하고 있을 때 얻어지며, 이것은 최고의 응집도라 할 수 있다.

시스템을 잘 설명할 수 있고 응집도 높은 개념의 집합으로 구성되도록 모듈을 선정해야 한다. 이렇게 모듈간의 결합도를 낮출 수 있다.

모듈의 역할이 결정되고 나면 모듈 내부에는 변경이 많이 일어나는 반면에 모듈이 제공하는 내용 자체는 변경되지 않는 경향을 보인다.

**집합**  
도메인 객체의 생명주기 관리라는 과제를 잘 다루기 위해서 3가지 패턴이 있다. 집합은 객체의 소유권과 경계를 정의하는데 사용되며 팩토리와 리파지토리는 객체의 생성과 저장을 도와주기 위한 설계 패턴이다. 

집합은 데이터를 변경할 때 하나의 단위로 간주되는 관련된 객체들의 집합이다. 집합은 하나의 객체의 외부와 내부를 가르는 경계를 정해 구분한다. 각 집합은 하나의 root를 지닌다. root는 엔티티이고 외부에서 접근할 수 있는 창구다. root는 집합된 다른 객체들에 대한 참조를 담고 있으며, 다른 객체들은 서로 관계를 맺고 있다. 객체의 외부에서는 root를 통해서만 참조할 수 있다. 이것이 집합이 데이터 무결성을 보장하고 불변식을 강제할 수 있다. 이는 다른 객체가 집합에 속한 객체를 변경할 수 없다는 뜻이다.

**팩토리**  
엔티티와 집합은 root 엔티티의 생성자를 통해 생성하기에는 너무 크고 복잡하다. 이런 복잡한 객체 생성 절차를 캡슐화 할 수 있는 새로운 개념이 도입된 것이 팩토리다. 팩토리는 객체 생성에 필요한 지식을 캡슐화하는 데 사용되며 집합을 생성하는 데 특히 유용하다. 집합의 root가 생성될 때 집합에 포함된 모든 객체는 root에 따라서 생성되고 모든 불변식이 강제된다.

생성 절차를, 쪼갤 수 없는 원자적인 상태로 만들어 root가 생성될 때 모든 객체가 불변식에 맞게 생성되어야 한다. 그렇지 않으면 불변식이 보장되지 않는다.

복잡한 객체와 집합 객체를 생성하는 책무를 별도의 객체에 맡겨야 한다.

모든 복잡한 조합을 캡슐화하고 클라이언트가 인스턴스화된 객체들의 구체적인 클래스를 참조할 필요가 없는 인터페이스를 제공해야 한다. 전체 집합을 한 단위로 생성하고 불변식을 보장할 수 있어야 한다.

팩토리 메서드는 다른 객체를 생성하는 데 필요한 지식을 포함하지만, 외부에 드러내지 않는 객체 메서드다. 이 메서드는 집합에 속한 객체를 생성하고자 할 때 매우 유용하다. 객체 생성과 불변식을 보장하는 메서드를 집합 root에 추가해서 객체의 참조나 복사본을 되돌려준다.

팩토리를 생성할 때는, 객체의 캡슐화를 깨뜨리기 때문에 매우 주의해서 작업해야 한다.

엔티티 팩토리와 값 객체 팩토리는 다른데 값은 변하지 않는 객체이고 모든 속성 값이 생성 시점에 정의되어야 한다. 객체가 생성되었을 때 유효하고 변경되지 않을 값을 가지고 있어야 하며 식별자가 없다. 반대로 엔티티는 변경될 수 있으며 식별자가 존재한다.

팩토리 대신 생성자를 사용하는 경우
+ 생성 작업이 복잡하지 않음
+ 객체의 생성이 다른 객체의 생성과 연관되어 있지 않으며 모든 속성이 생성자를 통해 전달되어야 한다.
+ 클라이언트가 구현에 관심이 있어서, 사용할 전략 패턴을 선택하려고 한다.
+ 클래스가 바로 해당 타입이다. 관련된 계층 구조가 없어서 concrete 구현 목록에서 선택할 필요가 없다.

**리파지토리**  
객체의 참조를 얻는 로직을 캡슐화하기 위해 리파지토리가 필요하다. 이를 사용해 도메인 객체가 도메인의 다른 객체의 참조를 얻고자 인프라스트럭처를 참조할 필요가 없어진다. 리파지토리를 통해서만 다른 객체를 참조할 수 있게 되며, 모델은 명확해지고 원래의 목적에 집중할 수 있다.

도메인 모델이 객체의 저장이나 참조와 연관을 없애고 하부의 영속성을 보장하는 인프라스트럭처에 접근할 필요가 없도록 하는 것이 리파지토리의 전반적인 효과다.

클라이언트는 모델에만 집중하도록 하고 객체의 저장이나 접근과 관련된 내용은 레파지토리에 위임한다.

리파지토리는 객체를 생성하기 때문에 팩토리처럼 보이기도 하지만 리파지토리는 아무것도 없는 상태에서 객체를 생성하는 것이 아니라, 존재했던 객체를 복원하는 것이다. 팩토리는 새로운 객체를 생성해야 하지만 리파지토리는 이미 생성되어 있던 객체를 검색해야 한다.