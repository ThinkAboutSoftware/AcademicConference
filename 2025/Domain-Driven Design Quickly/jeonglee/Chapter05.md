## 5장 모델 무결성 보존

이번 장은 대규모 프로젝트를 다루는데, DDD가 기초가 되어 설계된다.

대규모 설계에서는 여러 팀이 참여하여 하나의 모델을 각각 모듈로 나누어 담당하게 되는데, 이 때 모든 사람이 공통의 모델을 바라보지 않기 때문에 작은 변화가 큰 폭풍을 일으킨다.

좋은 모델에서 출발하여 불일치가 많은 쪽으로 변질되기는 쉽다. 모델이 갖추어야 할 첫 번째 요건은 **변하지 않는 용어와 모순 없는 일관성**이다. 하지만 기업 규모 프로젝트를 통일된 모델로 만드는 것은 이상적일 수 있다. 이때에는 많은 팀의 노력이 필요하다.

*대규모 프로젝트에서 DDD가 이상적인 이유와 실제로 생기는 문제점에 대해서 공감될 수 있도록 잘 설명해준다. 또한, 모델의 무결성을 실제로 실현하기 위한 모델의 분할과 같은 방법에 대해서 다룬다.*

### 분할된 컨텍스트

모델은 각각 컨텍스트가 하나씩 있다. 하나의 모델을 다룰 때 컨텍스트는 암묵적이며, 우리는 그 컨텍스트를 정의할 필요가 없다. 하지만 대규모 프로젝트의 경우 각 팀이 담당할 모듈에 대해서는 컨텍스트를 정의할 필요가 있다.

대규모 모델 하나를 작은 것으로 분할하는 데에는 어떠한 규칙도 존재하지 않는다. **상호 관련되어 있고 자연스러운 개념을 형성하는 요소를 하나의 모델에 넣도록 하라.**

> 하나의 모델은 하나의 팀에 할당하기에 적합할 만큼 작아야 한다.

모델의 범위를 정의하는 작업의 기본 개념은, 모델의 범위를 정하고 컨텍스트 간의 경계를 설정한 다음 모델이 통합된 상태를 최대한 유지하도록 하는 것이다.

분할된 컨텍스트는 모듈이 아니다. **분할된 컨텍스트는 발전하는 모델에 담길 논리적 프레임을 제공한다.** 모듈들은 모델의 구성 요소들을 조직화하기 위해 사용된다. 따라서 분할된 컨텍스트란 모듈을 포함하는 개념이다.

**처음에는 모듈이 분할되며 통일된 모델을 바라보기 어렵다고 생각할 수 있지만 모델을 작은 모듈롤 분할하여 모든 사람은 자신들만의 조각을 가지고 자유롭게 작업할 수 있다.** 또한 자신이 맡은 모델이자 객체의 한계 또는 책임과 역할을 알고 있기 때문에 그 경계를 넘지 않는다.

*적어보니 OOP와 이어지는 개념이다 동일하다.*

책에서 나온 예제와 같이 모델을 모듈로 나누게 되면 확장성이 매우 높아지고 이는 또다른 숨겨진 도메인이 나온다고 볼 수 있다.

### 지속적인 통합

컨텍스트가 정의되고 나면 이것을 건강하는 상태로 유지시켜야 한다. 일종의 균형잡기이다. 여러 사람들이 동일한 컨텍스트 안에서 일한다면 모델이 단편화될 가능성이 높다. 그렇다고 하나의 시스템을 너무 작은 규모의 여러 컨텍스트로 분할하는 것은 결과적으로 통합과 응집성의 가치가 보장되는 적절한 수준을 지나쳐 버리는 일일 수 있으므로 주의해야 한다.

**모델은 초기부터 충분하게 정의될 수 없다.** 모델은 생성되고 나면 개발 프로세스 동안 도메인에 대한 새로운 이해를 바탕으로 끊임없이 피드백을 받는다. 이것은 새로운 개념이 모델에 추가되거나 새로운 구성 요소가 코드에 추가될 수 있음을 의미한다. *이것이 지속적인 통합이 왜 필요한지에 대한 답이다.*

따라서 코드가 올바르게 구현되도록 보장할 수 있는 프로세스가 존재한다. CI/CD 제목과 같이 모델에 존재하는 개념 통합에 기반하고 있으므로, 테스트를 통해 검증될 수 있도록 이 모델을 구현할 방법을 찾아야 한다.

### 컨텍스트 맵

기업 규모 프로젝트의 경우 다수의 모델을 가지기 때문에 각 모델은 고유의 분할된 컨텍스트를 가진다. **컨텍스트 맵은 서로 다른 분할된 컨텍스트들과 그들의 관계에 대한 개요를 표현한 문서다.** 컨텍스트 맵의 목적은 모든 사람이 이를 공유하고 이해하는 것에 있다.

각 모델의 기능은 전체 시스템의 일부이기 때문에 반드시 통합되어야 한다. 결국 개별 조각은 함께 조립되어서 전체 시스템이 적절하게 동작하는 것이다. 각 컨텍스트가 명확하게 정의되지 않았다면 서로 중복되었을 확률이 높다.

각각의 분할된 컨텍스트는 유비쿼터스 언어의 일부인 고유한 이름이 있어야 한다. 이것은 시스템 전체에 대해 논의할 때 팀끼리 의사소통을 매우 원할하게 한다. **모든 사람은 각 컨텍스트의 범위와 컨텍스트와 코드의 매핑 상태를 알고 있어야 한다.**

### 공유 커널

기능적 통합이 한계에 다다랐을 때, 지속적으로 통합하려는 오버헤드가 너무 크게 느껴질 수 있다. 지속적 통합을 수행할 기술이나 정치적 조직이 없거나 하나의 팀이 너무 커서 통제하기 힘들 때는 정말 그렇다. **따라서 별도로 분할된 컨텍스트를 기반으로 팀을 여럿으로 나눠 조직을 꾸리는 것이다.**

*초기에 컨텍스트를 나누어 조직을 꾸릴 때 실제로 프로젝트에 할당된 팀장급 팀원들이 모여서 상의를 할까?*

모델에서 공유되는 지점이 없다면 팀이 독립적으로 창작하게 되면서 중복적인 일이 생기거나 유비쿼터스 언어의 장점잉 사라질 것이다. **따라서 모델에는 공유지점이 명확하게 나타나야 한다.** 여기에는 모델 부분뿐만 아니라, 그 부분과 관련된 코드, 데이터베이스 설계를 포함한다.

기능 시스템을 자주 통합해야 하지만, 팀 내의 지속적인 통합의 빈도보다는 덜하도록 한다. 이렇게 통합하는 도중에 양쪽 팀의 테스트가 수행되어야 한다.

### 고객 공급자

두 서브시스템 한쪽이 다른 한쪽에 완전히 의존하는 식의 특별한 관게를 맺는 경우도 있다. 두 서브 시스텥의 컨텍스트는 별도로 존재하고, 한쪽의 처리 결과는 다른 쪽에 반영된다. *약간 합성의 관계와 같이 생각하면 될까?*

데이터베이스를 직접적으로 사용이 아닌 그것을 관리하는 중간 관리자가 존재하여 의존성으르 줄일 수 있다는 개념으로 이해했다.

### 순응

고객은 공급자에 대해 매우 의존적인 반면 공급자는 그렇지 않다. 만약 전체를 진행하는 관리 주체가 존재한다면 공급자가 필요한 주의를 기울이고 고객의 요구사항을 듣게 만들 수 있다.

의존적인 관계를 순응이라는 언어 즉 도메인 모델링엥 맞게 설명한 것 같다.

### 변질 방지 레이어

대부분의 개발에서는 다양한 레거시 애플리케이션 모델을 사용한다. 하지만 해당 애플리케이션이나 라이브러리의 구조는 현재 작업중인 DDD와 접근 방법부터 다르기 때문에 변질 방지 레이어가 필요하다.

이 레이어는 우리 모델과 유사한 개념을 가지고 유사한 동작을 수행한다. 그러나 외부 모델에게 클라이언트 언어가 아닌 외부 언어로 말한다. 즉, 두 개의 서로 다른 도메인과 언어 간에 양방향 번역자의 역할을 한다.

이것의 가장 큰 장점은 클라이언트 모델이 외부로부터 영향을 받는 오염 없이 순수하고 일관된 상태로 남는다는 점이다.

변질 방지 레이어를 구현하는 가장 좋은 방법은 **이 레이어를 클라이언트 모델 관점에서의 서비스의 하나로 보는 것이다.** 실제 구현은 퍼샤드 패턴으로 구현될 것이며 어뎁터를 필요로 할 것이다.

### 분할 방식

분할 방법에는 정답은 없다 그 상황에 따라 절충만 있을 뿐 최선의 선택을 해야한다. 끊임없이 코드를 병합하며 그때마다 아무것도 망가뜨리지 않았음을 확인하는 테스트를 수행해야 한다.

분할 방식을 진행하기 앞서 통합된 시스템으로 되돌아가지 않을 것임을 확실히 할 필요가 있다. 독립적으로 개발된 모델들은 통합하기가 매우 어렵다.

### 오픈 호스트 서비스

**두 서브시스템을 통합하려고 할 때 우리는 일반적으로 그들 사이에 번역을 위한 레이어를 만든다.** 이 계층은 클라이언트 서브시스템과 우리가 통합하고자 하는 외부 서브시스템 사이에 완충지대의 역할을 한다.

자신의 시스템에 접근할 수 있는 프로토콜을 서비스의 집합으로 정의하라. 내 시스템과 통합될 필요가 있는 사람이라면 누구든지 사용할 수 있도록 프로토콜을 공개하라.

### 증류

증류란, 혼합체를 구성하고 있는 물질을 분리해 내는 절차다. 이 과정에서 발생하는 몇가지 부산물이 흥미로운 경우가 종종 있다. 도메인의 규모가 큰 경우 여러차례 리팩터링을 거치더라도 여전히 거대한 경우가 있다. 이 시점이 증류가 필요한 시점이다.

도메인의 정수를 표현하는 핵심 도메인을 정의해야 한다. **도메인을 증류 처리할 때 생기는 부산물은 도메인의 다른 파트를 구성하는 일반 서브도메인이다.**

*도메인을 보고 핵심적인 정수를 파악하는 일이 개발자로서 어려운 일이라는 생각이 든다.*

**핵심 도메인은 단번에 만들어지지 않는다. 핵심이 한층 명확하게 통합되기 위해서는 정제와 지속적인 리팩터링이 필요하다.** 우리는 핵심을 설계의 중심부로 규정하고 그 경계를 명확히 할 필요가 있다.
