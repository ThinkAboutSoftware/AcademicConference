## 3장: 모델 주도 설계

앞서 다룬 내용은 도메인 전문가와 대화를 통해 도메인에 대한 깊은 이해를 바탕으로 모댈링을 하는 과정을 말했다면 다음으로 중요한 모델을 코드로 구현하는 과정을 설명한다.

모델링된 모델을 두고 개발자는 자신의 생각을 덧붙여서 고유한 설계를 만들어낸다. 개발이 계속되면서 더 많은 클래스가 추가되며 코드와 모델사이의 간격이 넓어진다. 설계자와 개발자를 분리시키거나 모델과 코드를 분리하는 등의 개발방식은 켤코 좋은 소프트웨어를 생산하지 못한다.

*아마 프로그래밍이 매력적인 이유도 같은 도메인이라도 전부 다른 설계를 만들어내기 때문이라 생각된다.*

**코드를 작성하는 사람은 모델을 아주 잘 알고 있어야 하고, 모델의 무결성에 대해 책임감을 느껴야 한다. 그리고 코드의 변경은 곧 모델의 변경을 의미한다는 것을 깨달아야 한다.**

결국 이 말은 모델에 기여하는 기술자들은 모두 역할에 상관없이 코드에 기여하는 작업을 해야하고 코드를 변경하는 책임이 있는 모든 사람들은 코드를 통해 모델을 표현하는 방법을 배워야 한다. 모든 개발자도 모델을 주제로 한 일정 수준의 논의에 참석하고 도메인 전문가와 만나야 한다. *여기서 중요한 것이 유비쿼터스 언어의 필요성이다.*

이런 과정이 불필요하다고 느껴지고 모델과 설계의 핵심 부분이 잘 맞아 떨어지지 않는다면 모델은 가치가 없으며 오히려 비용적인 측면이 강화될 것이다.

**소프트웨어 시스템의 각 부분은 도메인 모델이 글자 그대로 반영 되도록 설계해야 한다. 코드는 결국 모델을 표현한 것이고, 코드의 변경이 곧 모델의 변경으로 이어질 것이다.**

객체지향프로그래밍(OOP)는 모델을 구현하기 적합한 패러다임으로 모델을 투사하여 표현하기에 유용하다. 복잡한 도메인은 절차적 언어로 대응하는 모델을 만들어내는 데 한계가 있다.

### 모델 주도 설계를 위한 블록

모델 주도 설계에서 사용되는 가장 중요한 패턴들을 소개한다. 여기 등장하는 패턴들의 목적은 도메인 주도 설계 관점에서 객체 모델링 및 소프트웨어 설계의 핵심 요소들을 보여주는 데 있다.

#### 계층형 아키텍처

실제로 애플리케이션을 만들 때, 상당 부분은 도메인과 직접적인 연관이 없는 부분이 많다. 그 목적을 동작하게 하기 위한 제반 시스템이 주를 이루거나 도메인은 다른 부분에 비해 적은 비중을 차지한다. *네트워크 코드, 데이터베이스, 사용자 인터페이스 등등..*

객체지향 프로그램에서 UI, 데이터베이스, 도메인과 직접 관련되어 있지 않은 여타 지원 성격의 코드들은 흔히 직접 비즈니스 객체 내부에 작성된다. 이런 경우는 대부분 일을 가장 빠르게 처리할 수 있기 때문이다.

그러나 이처럼 도메인과 관련된 코드가 다른 레이어와 섞여 있다면, 다른 사람이 코드를 읽고 이해하기가 매우 어렵다. 결국 프로그램이 복잡해지고 테스트도 어려워 진다.

따라서 복잡한 프로그램을 '레이어'로 분할해야 한다. **각 레이어 내부에서 설계를 수행하여 응집도 높고 자기 하위 레이어에만 의존하도록 만들어야 한다**. 또한 상위의 레이어에 대한 결합도를 낮추려면 표준적인 아키텍처 패턴을 따라야 한다.

하나의 레이어에 도메인과 관련된 모든 코드를 집중시켜서, 사용자 인터페이스, 애플리케이션, 인프라스트럭처 코드로부터 독립적으로 만들어야 한다.

- 사용자 인터페이스
  - 사용자에게 정보를 보여주고 사용자의 명령을 해석하는 책임을 진다.
- 애플리케이션 레이어
  - 애플리케이션 활동을 조율하는 얇은 레이어다. 업무 로직을 포함하지 않는다. 비즈니스 객체의 상태를 보관하지 않지만, 애플리케이션 작업의 처리 상태는 보관한다.
- 도메인 레이어
  - 도메인의 정보를 포함한다. 업무 소프트웨어의 심장에 해당한다. 비즈니스 객체의 상태를 포함한다. 비즈니스 객체와 이 객체의 상태 정보 중 가능한 부분의 영속성에 대한 책임은 인프라스트럭처 레이어로 위임된다.
- 인프라스트럭처 레이어
  - 다른 레이어 모두를 지원하는 라이브러리로 동작한다. 레이어 간의 통신을 제공하고 비즈니스 객체의 영속성을 구현하고 사용자 인터페이스 레이어의 라이브러리를 포함한다.

애플리케이션을 분할된 레이어를 나누고 레이어 간의 상호작용 규칙을 수립하는 일은 매우 중요하다. *게임도 마찬가지로 레이어가 존재한다. 다만 명칭은 다르지만 목적성은 동일하다고 생각된다.*

레이어를 분할했다는 것은 도메인 레이어는 핵심 도메인 이슈에만 집중해야 한다. *조금 더 확장해서 이렇게 레이어를 분할하여 상위 레이어가 하위 레이어에 일반적인 의존을 가지는 것은 꼭 레이어에 국한된 것이 아니라 더 작은 부분에서도 이 법칙이 적용되어야 한다. 예를 들어 UI레이어 코드 내에서도 여러 계층을 만들고 그 계층끼리 앞서 말한 구조를 유지해야 응집도가 높고 결합도가 낮은 구조가 재귀적으로 만들어진다.*

#### 엔티티

소프트웨어가 여러 상태를 거치는 동안에도 동일한 값을 유지하는 식별자를 지니는 유형의 객체가 있다. **이러한 객체들에게 중요한 것은 속성이 아니라, 시스템 전 생명주기 동안, 또는 그 이상으로 확장될 수 있는 연속성과 식별성의 흐름이다. 이러한 객체를 엔티티라고 부른다.**

사람의 주민등록번호, 게임 유저의 고유 코드 ID, 사람의 경우 여러 속성들의 조합, 계좌번호 등 이러한 고유한 식별자로 객체를 구분 및 관리한다. 객체가 일반 속성이 아닌 식별자에 의해 구별된다면, 모델의 해당 객체 정의에는 주로 이 식별자가 반영되어야 한다.

엔티티는 도메인 모델에서 매우 중요한 객체들이고, 모델링 작업을 시작할 때부터 깊이 고민해야 할 부분이기도 하다. 더불어 어떤 객체를 엔티티로 봐야 할지 말아야 할지 여부를 결정하는 작업 또한 매우 중요하다.

#### 값 객체

엔티티는 도메인 모델링에 필수적이다. 엔티티는 추적이 될 수 있어야 한다. 추적 가능하다는 것은 그만큼의 비용을 지불해야 한다는 것을 말한다. 즉, 모든 객체를 엔티티로 만들면 성능상의 문제가 발생할 수 있다.

**값 객체는 영속성이 필요 없는, 하나의 객체가 도메인의 어떠한 측면을 표현하는 데 사용되지만 식별자가 없는 경우이며, 이것을 값 객체라고 부른다.**

쉽게 값 객체를 떠올리듯이 엔티티의 정의에 부합하는 객체만을 엔티티로 두고 나머지를 값 객체로 만들어라. 이렇게 하면 설계가 좀 더 단순화되고, 다른 긍정적인 결과도 생긴다.

값 객체는 알아서 소멸될 것이다 (GC에 의해), 다만 값 객체는 수정할 수 없게 만들어야 한다. 생성자를 통해 값 객체를 생성하고 나면 생명주기 동안 상태가 변경되지 않는다. (필요하다면 복사하여 수정) 값 객체가 불변을 보장해야 한다는 것은 객체지향의 기본적인 원리이자 황금률이다.

#### 서비스

도메인을 분석하여 모델을 구성하는 주요 객체를 정의할 때 도메인의 특정 부분들은 객체로 쉽게 매핑될 수 없다는 사실을 발견하게 된다. 예를 들어 한 계좌에서 다른 계좌로 돈을 보내는 기능의 경우 어떤 계좌에 이 기능이 존재해야 하는지에 대한 문제이다.

어느 한쪽도 아니고 이는 서비스에 해당한다. **서비스 객체는 내부적인 상태를 가지지 않으면서, 단순히 도메인에 기능을 제공하는 목적을 지닌다.** 서비스가 제공하는 기능은 매우 중요하고, 서비스는 엔티티와 값 객체에 기여하는 관련된 기능을 묶을 수 있다.

서비스는 하나의 개념들 캡슐화하여 도메인에서 명확하게 구분되어 만들어지기 때문에, 명시적으로 선언하는 편이 좋다. 엔티티나 값 객체에 이런 기능을 넣는다면 해당 객체의 의미를 불분명하게 만들어 혼란스러워질 것이다.

*서비스는 오퍼레이션을 제공하는 인터페이스와 비슷하게 동작한다.*

- 서비스 특징
  - 서비스에 의해 수행되는 오퍼레이션은 일반적으로 엔티티 또는 값 객체에 속할 수 없는 도메인의 개념을 나타낸다.
  - 수행되는 오퍼레이션은 도메인의 다른 객체를 참조한다.
  - 오퍼레이션은 상태를 저장하지 않는다.

애플리케이션이나 도메인 서비스들은 양쪽 모두 그 객체들과 직접 관계된 기능을 제공하는 도메인 엔티티와 값 위에 만들어진다. 따라서 서비스가 속하는 레이어를 결정하기는 어렵다.

*서비스라는 명칭을 익숙하지 않게 느낀 것 같다. 실제로 객체의 책임이 예매해지는 경우가 종종 있는데 그럴 때 마다 다른 객체를 만들어 위임하는 등 여러 방법들을 사용했지만 설계 단계에서 그걸 서비스라는 명칭으로 정의할 수 있다는 점이 마음에 든다.*

하지만 오퍼레이션이 개념적으로 애플리케이션 레이어에 속하는 일을 한다면 해당 서비스는 그 레이어에 존재하는 게 맞다. 같은 맥락으로 도메인 레이어도 마찬가지다. 즉, 서비스도 레이어에 맞게 존재해야 한다.

#### 모듈

규모가 크고 복잡한 애플리케이션의 경우 그 모델은 점점 더 커지는 경향이 있다. 어떤 지점에 다다르면 모델 전체를 가지고 이야기하는 것이 힘들어지고 작은 부분들 간의 관계나 상호작용을 이해하기도 어려워진다.

이러한 이유로 인해, 모델은 모듈로 나누어 구조화할 필요가 있다. **모듈화란, 관련된 개념과 작업을 조직화하여 복잡도를 감소시키는 기법이다.**

**대규모 모델일지라도 모델에 속해 있는 모듈과 이들 간의 관계를 중심으로 본다면 그 개요를 파악하기 쉬워진다. 모듈들 간의 상호작용이 이해되었다면 그때부터 모듈 하나하나의 내부를 파악하기 시작하면 된다.**

*이 방법으로 소스코드를 읽어야 한다.*

모듈을 사용하는 또 다른 이유는 코드의 품질 때문이다. 코드가 높은 응짐도와 낮은 결합도를 추구해야 한다는 사실은 이미 널리 알려진 사실이다. 응집도는 클래스와 메서드 레벨에서 시작하지만 모듈 레벨에서도 적용될 수 있다.

응집도를 가능한 최대화하기 위해 밀접한 관계를 지닌 클래스들을 하나의 모듈로 정의하는 방법이 권장된다. 응집도에는 여러 종류가 있지만 가장 널리 알려진 종류는 **통신 응집도**와 **기능 응집도**이다.

통신 응집도는 모듈의 일부가 **같은 데이터**를 다룰 때 얻을 수 있다. 이 코드들은 관계가 견고하기 때문에 그룹핑하는 것이 당연하다. *데이터 응집도가 더 맞는 말 아닌가?* 기능 음집도는 모듈의 모든 부분이 잘 정의된 임무를 함께 수행하고 있을 때 얻어지며 최고의 응집도라고 할 수 있다.

모듈은 다른 모듈들이 접근할 수 있는 잘 정의된 인터페이스를 가져야 한다. 내부 객체에 접근을 허용하기 보다 인터페이스를 통해 접근하는 것이 결합도가 감소하기에 더 좋다. 또한 모듈 하나가 다수의 모듈과 연결되어 있는 것 보다 잘 정의된 입무를 수행하는 모듈끼리 연결 고리가 별로 없을 때 시스템의 기능을 이해하기 수월하다.

모델은 상위 수준의 도메인 개념에 잘 부합하게 분할되도록 정련하고, 관련 코드도 서로 결합되지 않도록 해야 한다. *'정련하다' 순수하게 만들다. 부합물을 없애다.*

모듈은 설계 단계에서 구체화되어야 한다. 유비쿼터스 언어에 맞게 이름도 필요하며 지속적인 통합과 학장이 필요하다.

#### 집합

집합은 내가 앞 모듈파트에서 정리한 부분의 좀 더 작은 부분이라고 생각한다. 일종의 생명주기를 다루는 것으로 응집도를 높이기 위해 그룹핑을 하지만 관계이자 주기에서 결합도를 낮추기 위해 집합을 사용한다.

**집합은 객체의 소유권과 경계를 정의하는 데 사용되는 패턴이다.** 모델 하나에는 굉장히 많은 도메인 객체를 담을 수 있다. 이 때 수많은 객체들이 서로 연결된다. 예를 들어 고객과 계좌에서 일대일 관계는 두 객체간의 참조가 있음을 말할 수 있다. *고객과 고객, 계좌 정보 등*

모델에서 도전과제는 완성도를 갖춘 모델보다 모델을 더 단순화하고 이해하기 쉽게 만들 수 있느냐에 달려있다. 그래서 대부분 모델에서 관계를 제거하거나 단순화하는데 시간을 보낸다.

일대다 관계는 관계될 수많은 객체를 수반하기 때문에 복잡하지만 한 객체가 다른 객체의 집합관계를 가지는 것으로 단순화할 수 있다. 다대다 관계는 대부분 양방향이다. 이 관계는 복잡도를 가파르게 상승시켜 객체들의 생명주기 관리를 어렵게 만든다. 따라서 관계에 참여하는 숫자의 수를 최소화하는 것이 좋다.

*이해, 관계, 복잡성, 응집도, 결합도 모든 측면에서 단순한 것이 좋다.*

- 관계의 수를 줄이는 방법
  - 모델의 핵심 사항이 아닌 관계가 있다면 제거한다.
  - 다수성의 숫자는 제약사항을 추가하여 감소시킨다.
  - 많은 경우 양방향 관계는 단방향 관계로 대체될 수 있다.
    - 일종의 상속관계에서 포함관계로의 전환, 상위가 하위에 의존한다.

또한 불변식을 따르도록 강제해야 한다. **불변식은 데이터가 변경될 때 마다 검증하는 규칙이다.** 그러나 수많은 객체가 수정된 데이터 객체를 참조하고 있을 때, 이 규칙을 실현하기는 매우 어렵다. 따라서 집합을 사용해야 한다.

**집합은 결국 데이터를 변경할 때 하나의 단위로 간주되는 관련된 객체들의 집합이다**. 집합은 하나의 객체의 외부와 내부를 가르는 경계를 정헤 구분한다. *클래스간의 모듈 느낌으로 해석했다.*

각 집합은 하나의 root를 지닌다. **root는 엔티티**이고 외부에서 접근할 수 있는 창구이다. root는 집합된 다른 객체들에 대한 참조를 담고 있으며, 다른 객체들은 서로 관계를 맺고 있다. 그러나 객체의 외부에서는 root 객체를 통해서만 참조할 수 있다.

집합이 무결성과 불변식을 보장하는 이유는 다른 객체들은 root에 대한 참조만 지니기 때문이다. 즉, 다른 객체들은 집합에 속한 다른 객체들을 변경할 수 없다는 말이다. *root 자체를 변경하거나 root에게 요청한다.*

이것이 중요한 이유는 앞서 말한 생명주기에 관련이 있다. 현재 참조가 집합에 의해서 관리된다는 것은 결국 집합 외부의 객체가 집합 내부의 객체의 행동이나 값이 필요할 때 root를 거쳐야 한다는 것이고 이것은 제어 가능한 오퍼레이션 영역의 일이다. 따라서 root의 제거가 곧 집합 전체의 삭제이기 때문에 결합도가 매우 낮다.

실제로도 참조 복사가 아닌 새로 생성하여 복사하여 객체의 불변성도 보장한다. 해당 데이터를 활용하는 것은 그 객체의 일이다. root 엔티티는 전역 식별자를 지니며 불변식을 검증할 책임을 진다. 내부 엔티티는 지역 식별자를 지닌다.

#### 팩토리

복잡한 집합을 자신의 생성자를 이용해 만들어 내려는 시도는 실제 도메인의 처리 방식과는 정반대 방식이다. 실제 도메인에서는 사물이 외부의 다른 사물에 의해 생성된다.

만약 Customer 객체가 다른 객체를 생성하고자 한다면 몇 개의 매개변수를 가지고 생성을 할 것이다. 그러나 객체를 생성하기란 힘든 일이다. **객체를 생성하는 동안에는 객체의 내부 구조, 그 객체가 포함하고 있는 다른 객체가 서로 맺을 관계, 이와 관련되어 적용해야 할 규칙에 대한 충분한 지식이 필요하다.**

그러나 이러한 지식을 포함하면 도메인 객체의 캡슐화와 집합의 캡슐화에 위배된다. 따라서 복잡한 객체의 생성의 절차를 캡슐화할 수 있는 새로운 개념이 도입될 필요가 있다. 이것이 팩토리다. 팩토리는 객체 생성에  필요한 지식을 캡슐화하는 데 사용되며 집합을 생성하는 데 특히 유용하다.

중요한 것은 생성 절차를 쪼갤 수 없는 원자적인 상태로 만들어야 한다. 만약 그렇지 못한다면 절반만 생성되거나 일부 객체가 정의되지 않은 상태일 수 있다. *이후에 정의가 되어야 한다면 NULL객체를  사용해야 할 수 있다. 게임에서 캐릭터를 생성할 때 아직 스킬을 배우지 않은 상태라면 아무것도 없는 스킬을 넣는 방식*

팩토리를 구현하는 몇 가지 설계 패턴이 있다. **팩토리 메서드**와 **추상적인 팩토리**라는 두 패턴이다. 이 패턴들을 설계 관점이 아닌 도메인 모델링 관점에서 사용해 볼 것이다.

**팩토리 메서드는 다른 객체를 생성하는 데 필요한 자식을 포함하지만, 외부에 드러내지 않는 객체 메서드다.** 이 메서드는 집합에 속한 객체를 생성하고자 할 때 매우 유용하다. 객체 생성과 불변식을 보장하는 메서드를 집합 root에 추가해서 객체의 참조나 복사본을 되돌려 주는 것이다.

만약 객체의 생성이 좀 더 복잡하거나 여러 객체를 생성하는 경우에는 객체의 생성을 별도로 전담하는 팩토리 객체가 수행하고 생성 자체는 외부에 드러나지 않아야 한다.

팩토리를 생성할 때는, 객체의 캡슐화를 깨뜨리기 때문에 매우 주의해서 작업해야 한다. **생성 작업과 관련된 규칙이나 불변식에 영향을 미치는 어떠한 변경이 객체에 일어날 때 마다, 새로운 조건을 지원할 수 있도록 팩토리를 수정해야 한다.**

팩토리들은 생성한 객체들과 밀접한 관련이 있다. 이것은 설계 관점에서 약점이지만 동시에 강점이기도 하다. 집합은 밀접하게 관련된 연속된 객체를 포함한다. root의 생성은 집합에 속해 있는 다른 객체들의 생성과 연관되어 있고, 집합 내부 객체들을 연관시키는 일정 수준의 로직을 추가해야 한다.

그 로직은 원래 어떤 객체에도 속하지 않는다. **왜냐하면 다른 객체의 생성에 관여하는 내용이기 때문이다.** 이러한 집합 전반의 생성 작업은 다루는 업무는 특별한 factory 클래스가 맡는 것이 적절하다.

또한, 엔티티 팩토리와 값 객체 팩토리는 다르다. 값은 변하지 않는 객체이고 모든 속성 값이 생성 시점에 정의되어야 한다. 반대로 엔티티는 변경될 수 있기에 이를 고려해야 한다.

- 팩토리 대신 생성자를 사용하는 경우
  - 생성 작업이 복잡하지 않다.
  - 객체의 생성이 다른 객체의 생성과 연관되어 있지 않으며 모든 속성이 생성자를 통해 전달되어야 한다.
  - 클라이언트가 구현에 관심이 있어서, 사용할 전략 패턴을 선택하려고 한다.
  - 클래스가 바로 해당 타입이다. 관련된 계층 구조가 없어서 구현 목록에서 선택할 필요가 없다.

팩토리는 아무것도 없는 상태에서 완전히 새로운 객체를 생성할 필요가 있다.

#### 리파지토리

모델 중심의 설계에서 객체에는 생성과 함께 삶을 시작하여 삭제되거나 저장소에 보관되는 순간 생을 마친다. 생성자, 팩토리가 객체의 사용을 위해 생성을 한다면 **리파지토리는 객체의 참조를 얻는 로직을 캡슐화하기 위해 사용한다.**

만약 코드에서 리파지토리를 사용하지 않는다면 다른 객체의 참조를 얻기 위해 (이미 생성된 객체) 데이터베이스를 쿼리하거나 인프라스트럭처를 참조하는 등 원래의 도메인 모델링, 설계의 측면에서 벗어난다. 이는 곧 복잡성을 의미한다.

리파지토리는 몇몇 객체의 참조를 저장할 수도 있다. 객체가 생성되었을 때 리파지토리에 저장되고, 나중에 사용할 목적으로 조회된다. *일종의 클라이언트와 데이터베이스의 중간 다리 역할이다.*

리파지토리는 전략을 포함하기도 한다. 특정 영역에 접근하거나 다른 곳에 접근할 때 특별한 전략을 만든다. 전역 접근이 필요한 여러 유형의 객체의 경우 해당 타입 객체가 메모리에 집합적으로 존재하는 것처럼 보이게 하는 객체를 생성하라. 그리고 널리 알려진 인터페이스를 통해 여기에 접근이 가능하게 한다.

실제로 리파지토리에서 사용하는 쿼리나 기술적인 내용을 숨겨서 직접 접근할 필요가 있는 root에 대해서만 리파지토리를 제공한다. 클라이언트는 모델에만 집중하고 객체의 저장이나 접근과 관련된 내용은 리파지토리에 위임한다.

리파지토리는 인프라스트럭처의 구현과 매우 유사해지지만, 리파지토리 인터페이스는 순수하게 도메인 모델이다. *게임에서 로그인할 때 클라이언트에 해당 유저 정보를 반환해주는*

팩토리는 객체의 생성에 관여하는 반면에, 리파지토리는 이미 존재하는 객체들을 관리한다. 리파지토리는 자체적으로 객체를 캐싱하기도 하지만 영송적인 스토리지에서 읽어와야 할 경우가 더 많다. 팩토리는 위에서 본 것 처럼 순수 도메인에 가깝지만 리파지토리는 데이터베이스나 인프라스트럭처와 이어지는 연결이 포함될 수 있다.

### 정리

이런 방법론이나 패러다임에 대한 책을 읽다보면 좋은 것은 알겠으나 실제로 적용 가능한가? 에 대해서는 결국 성숙한 팀으로 귀결되는 것 같다. 10명과 일을 한다면 9명 중 1명만 이에 대해서 부정적이거나 관심이 없다면 생산성이 크게 떨어질 것 같다는 생각이다.

모두를 설득시키는 비용 또한 매우 쎄고 팀 마다 다르고 회사마다 다를 것이다. 이상적인 내용이지만 그 만큼 팀의 수준이 높을 경우 퍼포먼스가 뛰어날 것 같다.

3장은 기본적인 틀은 객체지향 설계이지만 그 중심이 모델이 되어야 하는 이유와 더 좋은 점에 대해서 설명해준 것 같다. 특히 용어에 대해서 설명도 직관적이고 그 동안 생겼던 의문들이 조금 해결이 되기도 했다.

또한 `모델 주도 설계를 위한 블록`이 내용 하나만으로 하나의 시스템을 덩어리로 나눠 그려볼 수 있겠다는 생각도 들면서 객체간의 느슨한 참조를 위한 방법론 같다는 생각입니다. 물론 책에서 말하듯 도메인에 관한 내용이기에 실제 개발에서는 더 많은 부분의 코드들이 존재할 것 같습니다.

### 논의사항

정론에 가까운 내용이라 논의사항을 뽑기가 어렵습니다.. 3장을 읽으시면서 다들 느낀점이 제각각일 것 같다는 생각이 드는데 가장 좋았던 부분에 대해서 이야기 해보면 좋을 것 같습니다.

저는 서비스, 리파지토리 부분이 가장 좋았습니다. 부족했던 부분도 해결되고 다음에 설계나 작업할 때 도움이 될 것 같습니다.
