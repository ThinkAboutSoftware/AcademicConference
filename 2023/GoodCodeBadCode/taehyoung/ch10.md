# Ch10. 단위 테스트의 원칙

## 중요 문장 & 내 생각

1. 궁극적으로 중요한 것은 코드를 잘 테스트하고 이 작업을 유지보수할 수 있는 방법으로 수행하는 점이다.
    
    > 내 생각
      - 회사에서 코드 작성할 때, 나는 어떤 목적과 의도를 가지고 코드를 작성하는지? 를 곰곰이 생각해보면, 위의 말대로 내가 작성한 코드를 어떤 방법으로든 잘 테스트하고, 이후에도 유지보수 할 수 있게 관리하는 것이라 볼 수 있을 것 같다
    > 
2. 테스트 코드는 테스트 하려는 코드에 의존한다(따라서 테스트를 위해 그 코드를 호출한다)
    
    > 내 생각
      - 어떤 백엔드 API를 만들었다고 할 때, 그 백엔드 API 를 가장 먼저 사용해보는 클라이언트는 테스트 코드 이다 단순하게 테스트를 내가 작성한 비즈니스로직을 검증 하는 용도로만 생각하기 보다, 내 API를 쓰는 클라이언트의 관점으로 생각해보면 좋을 것 같다 이 관점에서 봤을 때, 테스트코드의 장점은 내가 클라이언트가 되서 내가 원하는대로 내가 작성한 로직을 호출해보고 그 결과를 확인해볼 수 있다는 점이다 즉, 굳이 내 백엔드 API를 FE와 연동하지 않고도 사실상 비즈니스 로직 부분은 모두 나 스스로 테스트 해볼 수 있다 내 테스트 코드를 가상의 FE 개발자라고 생각하고 작성해보면 FE와 소통할 때도 좀 더 다양한 케이스로 가이드를 주면서 API를 제공해줄 수 있을 것 같다
      - 의존성이 존재 하다보니, 당연하게도 API 수정이 있을 때 수정에 영향을 받을 수 밖에 없다 테스트가 많으면 많을 수록 고쳐야하는 포인트가 많기 때문에 그만큼 시간과 노력이 들어가게 된다 이런 이유로, 테스트 코드를 작성할 때는 이해하기 쉽고, 각각 행위에 대해서 분리해서 작성하는게 필요하다 테스트코드가 이해하기 어렵고, 한 메소드 내에 테스트 항목이 많으면 많을 수록 수정에 의한 테스트 코드 수정은 고통 스러울 수 밖에 없을 것이다
    > 
3. 좋은 단위 테스트가 가져야할 5가지 주요 기능
    1. 훼손의 정확한 감지
        
        > 내 생각
          - 만약 내가 테스트 코드를 잘 작성 하였다면, 테스트코드에 해당하는 구현 코드를 수정 했을 때, 반드시 의도한 대로 테스트가 실패해야한다, 그렇지 않다면 이 `훼손의 정확한 감지` 를 어긴 것으로 볼 수 있다 
          - 테스트가 모든 케이스를 커버하지 못할 때, 위의 문제가 발생 할 수 있다. 대개의 경우에 구현 코드를 먼저 작성하고 테스트 코드를 나중에 작성할 때, 빠트리는 경우가 많다. 이를 커버하기 위해서 TDD를 활용할 수 있다 TDD는 테스트를 먼저 정의 하고, 테스트를 통과하는 최소한의 코드를 작성하고 리팩토링하는 싸이클을 반복하기 때문에 구현 코드의 케이스를 빠뜨릴 가능성은 없어진다. TDD의 실무 활용도와 투자대비 가성비가 어떻냐와 상관없이, 내가 의도적으로 테스트하고 싶은 테스트 케이스를 빠짐 없이 구현 코드로 구현하고 싶다면, 필연적으로 TDD 방법론을 쓰는게 맞다고 본다
        > 
    2. 세부 구현 사항에 독립적
        
        > 내 생각
          - 처음에 이 부분은 어떤 말인지 잘 이해가 되지 않았었는데, 리팩토링 한 이후에 테스트가 터지는 경우가 없어야 하는 것을 말한다는 것을 이해 할 수 있었다
          - 리팩토링은 결과의 변경 없이 코드의 구조를 변경하는 것이기 때문에, 코드의 구조를 변경하는 과정에서는 기존에 작성하는 테스트들은 모두 잘 동작해야만 한다 만약 리팩토링 과정에서 테스트가 터지는 경우가 생기면, 이는 리팩토링 과정에서 실수가 있었음을 말해주는 신호이다 
          - 리팩토링을 하는 과정에서는 기존에 작성된 테스트 또한 수정하는 경우가 없어야 한다 리팩토링은 결과의 변경 없어야 하기 때문이다 대개 이런 실수는 비즈니스 로직을 작성 혹은 수정 하면서, 리팩토링도 동시에 수행하려고 할 때 발생한다 이와 관련해서는 [Two hats](https://devlead.io/DevTips/TwoHats) 를 읽어보도록 하자
        > 
    3. 잘 설명되는 실패
        
        > 내 생각
          - `훼손의 정확한 감지` 와 연결되는 내용으로 볼 수 있을 것 같다
          - 테스트가 실패하는데 왜 실패하는지 모를 때가 가끔 있다 많은 케이스가 있지만 개인적으로는 테스트 하나에서 너무 많은 것을 테스트 하려고 할 때, 테스트가 실패했을 때, 어느부분에서 실패했는지 바로 인지하고 디버깅하기 힘들었던 경험이 있다
          - 이 `잘 설명되는 실패` 를 잘 수행하기 위해선 개인적으론, 테스트의 케이스 마다 테스트 메소드를 적절히 나누는게 해결책이 될 수 있지 않을까 라고 생각해본다 각 테스트 메소드 마다 케이스를 격리시켜서 실패했을 때, 무엇이 문제인지 명확하게 파악할 수 있기 때문이다
        > 
    4. 이해될 수 있는 테스트 코드
        
        > 내 생각
          - `잘 설명되는 실패` 의 연장선에 해당하는 내용이라고 생각한다 결국에 테스트 코드를 읽기 쉽게 작성하기 위해선 테스트 케이스 별로 적절히 분리하는게 필요한데, 이를 이해될 수 있는 테스트 코드로 볼 수 있을 것 같다
          - 개인적으로는 테스트 메소드 내에 한글 주석으로 테스트 하려는 바를 좀 자세히 써볼까한다 이유는 테스트 메소드 이름 만으로는 내가 드러내고 싶은 의도를 표현하기에 부족하다고 느꼈기 때문이다.
        > 
    5. 쉽고 빠르게 실행
        
        > 내 생각
          - 위의 4가지 보다는 가장 우선순위가 떨어진다고 생각한다 그러나 지나치게 느리게 실행되는 경우가 있다면 이는 개선이 필요할 수 있다 대개의 경우에 외부 의존성에 대한 mocking 처리가 제대로 되지 않아서, 실제 외부 서비스를 네트워크 호출 한다던지, given 조건을 만드는 과정에서 쿼리가 비효율적으로 발생하는 경우에도 발생할 수 있다
          - 최근에는 pytest-xdist 라이브러리를 활용해서 테스트 코드를 병렬적으로 수행할 수 있도록 하면서 빠르게 실행하려는 노력을 진행 하고 있다
          - 관련된 테스트를 클래스 단위 혹은 파일, 패키지 단위로 묶는 것도 쉽고 빠르게 실행하는 것에 도움을 줄 수 있을 것 같다
        > 
4. 퍼블릭 API 만을 이용한 테스트 라는 원칙을 기억하기 바란다. 이 원칙을 따르면 테스트와 구현 세부 정보를 결합하지 않고, 호출하는 쪽에서 실제로 신경 쓰는 사항만 테스트하는 데 집중할 수 있다
    
    > 내 생각
      - 이 의견에 완전히 동의하고 나의 경우도 퍼블릭 API 를 기준으로 테스트 코드를 작성한다 다만, 퍼블릭 API 내부의 구현이 복잡하거나, 너무 크거나, 의존성이 많을 때는 테스트를 작성하기 힘들게 되기 때문에 퍼블릭 API 테스트 코드 작성 이전에 구현 설계를 제대로 해서 클래스 혹은 함수 별로 책임을 확실히 나누어 주는게 중요 할 것 같다
    > 
5. 퍼블릭 API 만을 이용해 테스트하라와 실행 세부 사항을 테스트 하지 마라는 둘다 훌륭한 조언이지만 테스트를 어떻게 할지 안내하는 원칙일 뿐, 주관적이고 상황에 따라 달라질 수 있다는 점을 알아야 한다. 궁극적으로 중요한 것은 코드의 모든 중요한동작을 제대로 테스트하는 것이고, 퍼블릭 API 라고 생각하는 것만으로는 이것을 할 수 없는 경우가 있다 그러나 테스트를 구현 세부사항에 최대한 독립적으로 수행하도록 주의를 기울여야 하므로 다른 대안이 없는 경우에만 퍼블릭 API를 벗어나 테스트해야 한다
    
    > 내 생각
      - 퍼블릭 API 외에도 테스트가 필요할 수 있다는 주장에 대해서는 어느정도 동의하는 편이다. 그럼에도 불구하고, 퍼블릭 API 만을 테스트하는 것 역시도 동의하고 나는 퍼블릭 API 기준으로만 테스트를 작성한다 여기서 내가 말하는 퍼블릭 API는 웹 FE, BE 영역에서 제공하는 API가 아닌, 모든 영역에서의 퍼블릭 API 이다 즉, 어떤 클라이언트든 사용할 수 있는 함수 혹은 클래스의 메소드, 백엔드 API 모두 퍼블릭 API로 볼 수 있다 
      - 내가 퍼블릭 API 만 테스트를 작성하는 이유는 퍼블릭이 아니면, 구현 상세에 해당되고, 변화율의 관점에서 볼 때 훨씬 더 수정될 가능성이 높기 때문이다 테스트는 구현 코드에 의존성을 가지기 때문에 이런 이유로 수정이 되면 될 수록 테스트코드의 수정도 여기에 영향을 받게 된다 또한 퍼블릭 API의 케이스 안에 구현 상세의 케이스도 모두 포함되기 때문에 중복으로 테스트한다는 느낌도 있다
    > 

1. 테스트 더블을 사용하는 이유
    1. 테스트 단순화
        
        > 내 생각
          - 나는 `테스트 단순화` 용도로 테스트 코드를 작성할 때 있다 책에 설명이 나온대로 내가 작성하려는 테스트의 목적에 굳이 체크할 필요 없는 하위 의존성 등을 고려해야할 때, 이를 단순화 시키기 위해서 사용한다
          - 이 방법의 경우는 오남용 했을 때는 정말 좋지 않은 결과를 낼 수 있는데, 테스트가 코드가 뭔가 쉽게 작성되는 것 같은 느낌으로 인해서 마구 남발하게 되면 정작 테스트가 되어야하는 부분이 커버 안될 가능성이 크다 이런 오남용 가능성이 있기 때문에 테스트더블을 그리 좋아하지 않는 사람에게 자주 언급되는 것 같은데, 개인적으로는 테스트 목적에 따라서 충분히 쓸 수 있는 기능이라고 생각한다
        > 
    2. 테스트로부터 외부 세계 보호
        
        > 내 생각
          - 테스트 더블을 사용하는 가장 큰 이유로 볼 수 있다 외부 의존성이 있는 구현 코드를 테스트 할 때, 외부 의존성에 따른 부수효과를 일으키지 않고 테스트할 수 있는 방법은 테스트 더블을 사용하는 방법 밖에 없다
          - 테스트 더블을 사용하지 않거나 잘못 사용했을 때는 치명적 일 수 있는데, 의도치 않게 고객에게 피해가 갈 수 있기 때문이다 예를들면, 알림톡을 보내는 클래스 메소드를 제대로 mocking 하지 않았을 때, 테스트용 전화번호가 실제로 사용하는 번호라면, 실제 고객에게 알림톡이 전달 될 수 있다
        > 
    3. 외부로부터 테스트 보호
        
        > 내 생각
          - `테스트로부터 외부 세계 보호` 에 이어지는 내용으로 볼 수 있다 여기서는 외부 의존성이 줄 수 있는 응답이 내가 원하는 응답이 아닐 수 있기 때문에, 줄 수 있는 응답의 케이스를 정리해서 그 응답이 올 수 있도록 조정하는 것이다 이 또한 내가 테스트 케이스 작성할 때 많이 사용하는 방법이고, 반드시 필요한 기능이라고 생각한다
        > 
2. 테스트 대상 코드가 의존성을 통해 제공되는 함수를 호출하는지 검증하기 위해 목을 사용할 수 있다. 따라서 목은 테스트 대상 코드에서 부수 효과를 일으키는 의존성을 시뮬레이션 하는데 가장 유용하다.
    
    > 내 생각
      - 파이썬에서는 mock 라이브러리에서 mocking 으로 통일 되어 있는데, 대개의 경우 테스트 더블은 mock, stub, fake 로 나뉘게 된다 그중에서도 mock은 대상 코드에서 부수효과를 일으키는 의존성을 시뮬레이션 하는 용도로 쓴다. 파이썬에서는 이 용도가 따로 구분 되어있지 않고 다양한 assert 함수를 통해서 확인해 볼 수 있다 예를들면, 어떤 외부 의존성이 딱 1번만 호출되었는지 확인해보기 위해서 `assert_called_once_with(...)` 같은 함수를 활용해서 체크 해볼 수 있다
    > 
3. 스텁은 함수가 호출되면 미리 정해 놓은 값을 반환함으로써 함수를 시뮬레이션 한다 … 중략 … 스텁은 테스트 대상 코드가 의존하는 코드로부터 어떤 값을 받아야 하는 경우 그 의존성을 시뮬레이션하는데 유용하다
    
    > 내 생각
      - 파이썬 기준으로는 return_value를 지정하거나 side_effect 를 발생 시키는 것과 매핑 시켜서 스텁을 생각 해볼 수 있을 것 같다
    > 
4.  페이크는 실제 의존성의 공개 API를 정확하게 시뮬레이션하지만 구현은 일반적으로 단순한데, 외부 시스템과 통신하는 대신 페이크 내의 멤버 변수에 상태를 저장한다.
    
    > 내 생각
      - 책 내용만 봐서는 fake에 대해서 이해하지 못하였다 파이썬 매핑된 정보를 찾아보려고 했는데 찾지 못하였다 아마도 이미 파이썬 상에서 다른 이름으로 이미 해결이 된 일반적인 방법이 있을 것 같은 느낌이다
    > 

## 질문

1. 모키스트 vs 고전주의 접근 법 중에 어느것에 동의하고 동의하지 않는지 이야기 나눠보면 좋을 것 같습니다