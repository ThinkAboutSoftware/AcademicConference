# Ch3. 다른 개발자와 코드 계약

## 중요문장
1. 코드를 작성할 때 다음 세 가지를 고려하는 것이 유용하다.
  * 자신에게 명백하다고 해서 다른 사람에게도 명백한 것은 아니다.
  * 다른 개발자는 무의식중에 여러분의 코드를 망가뜨릴 수 있다.
  * 시간이 지남에 따라 자신의 코드를 기억하지 못한다.
2. 코드를 이해하기 쉽고 코드 자체로 설명이 되게 하는 것이 좋은 방법이다.
3. 배경지식이 거의 없거나 전혀 없는 사람에게도 자신의 코드가 이해하기 쉬어야 하고, 잘 작동하던 코드에 버그가 발생하는 것이 어려워야 한다. 
4. 자신의 코드를 다른 개발자가 어떻게 사용해야 하는지에 대해 가장 잘 전달할 수 있는 방법 중 하나는 이름을 잘 짓는 것이다.
5. 유형 시스템을 사용하는 언어로 코드를 작성하는 것은 다른 개발자가 코드를 오용하거나 오작동할 수 없도록 하기위한 좋은 방법 중 하나다.
6. 코드 계약의 분명한 항목을 통해 코드에 관해 명확하게 설명하는 것이 가능하다면, 그렇게 하는 것이 더 바람직할 때가 많다.
7. 세부조항에 의존하기 보다는 잘못된 일을 하는 것을 처음부터 불가능하게 만드는 것이 좋다.


## 내 생각
1. 개인적으로는 코드에 내가 작성한 의도를 오해하지 않도록 하는 것이 중요하다고 생각한다. 만약 다른 사람에게 오해를 낳는 다면, 또 다른 사람에게도 오해를 불러 일으킬 수 있기 때문에 내 생각에는 내의도를 드러냈다고 생각하더라도, 리뷰어 에게 의견을 물어서 추가적인 오해가 없도록 고치는 것이 맞을 것 같다.
2. 중요문장 중, 배경지식이 거의 없거나 전혀 없는 사람에게도 자신의 코드가 이해하기 쉬워야 한다는 말이 나오는데, 내 짧은 경험에 비춰보자면, 코드를 이해하기 쉽게 작성해도 비즈니스 도메인 문제가 자체가 어려워서 이해하기 어려워지는 경우가 많았다. 다만, 비즈니스 도메인 문제도 어려운데.. 코드까지 읽기 어려우면 난감하기 떄문에 적어도 코드 자체는 읽기 쉽게 작성할 필요가 있다.
3. 최근 리뷰 중에 이름을 대량으로 수정하는 일이 있었는데, 코드의 수정량이 워낙 많아서 시간을 매우 많이 소비 하였다. DDD의 관점에서 보았을 때, 유비쿼터스 언어를 제대로 정의 하지도 않고, 이를 제대로 리뷰 받지도 않았기 떄문에 문제가 발생한 것으로 볼 수 있을 것 같다. 오해를 불러일으킬 수있는 이름은 반드시 변경해야하고, 유비쿼터스 언어를 잘 정의해서 미리 따로 리뷰를 받는 시도를 해보자
4. 파이썬 3.5 부터는 파이썬에서 타입힌트를 지원한다. 런타임에서는 아무 동작을 하지 않지만, 타입힌트를 mypy와 함께 이용했을 때, 컴파일에서 타입체킹 해주는 것 처럼 활용할 수 있다. 이전에 2.7 버젼대에서 개발 했을 때는, 타입힌트의 유용성을 잘 몰랐었는데,런타임 전에 실수가 될 만한 것을 미리 파악할 수 있다는 점에서 매우 큰 장점이 있다 근데 사실 이 장점은 컴파일 언어를 쓰면 이미 컴파일 과정에서 다해결되는 문제이기도 하긴하다. 그럼에도 불구하고, 파이썬의 동적타이핑의 단점을 어느정도 상쇄 시켜준다는 측면에서, 파이썬의 장점을 유지하며, 코드 작성가능한 것이 매우 만족스럽다
5. 위에서 말한 타입힌트는 코드계약을 명확히 하는데에도 도움이 된다. 이전에는 코드에서 타입을 표시할 방법이 없었기 때문에 일종의 헝가리안 표기법 같은 것을 활용하기도 했었다. 개인적으로는 파이썬의 간결한 코드를 깎아먹는다고 생각해서 선호하진 않았던 방법이긴하다 그러나 타입힌트가 생기면서, 코드계약을 명확하게 코드 만으로 표현하는게 가능해졌고, swagger 문서 자동화 까지 이어져서 생산성 측면에서도 큰 기여를 해줬다
   
예시)   
   ```python
   # without type hint, but with comment
   def scale(scalar, vector):
    """
    - input
      * scalar: float
      * vector: [float, ...]

    - output
      * [float, ...]
    """
    return [scalar * num for num in vector]

   ```


   ```python
   # with type hint
   Vector = list[float]
   

   def scale(scalar: float, vector: Vector) -> Vector:
    return [scalar * num for num in vector]

   ```
6. 코드를 작성할 때, 다른 개발자가 굳이 구현 상세를 보지 않고도 내 코드의 의도를 잘 파악할 수 있도록 적절한 관심사의 분리와 추상화 계층 설계가 필요하다. 구현 상세를 보지 않고도 큰 그림을 바로 알 수 있어야 제대로 된 설계이지 않을까 싶다
7. 책에서는 일관되게 코드 자체에서 계약을 나타낼 수 있어야 하고, 세부사항에 의존했을 때 단점이 많음을 말하고 있다. 나도 기본적으로는 이말에 동의 하지만 그럼에도 불구하고 코드레벨 보다 한단계 높은 추상화 레벨에서의 사전 혹은 사후 문서화는 원활한 유지보수를 위해서 반드시 필요하다고 생각한다. 
   * 이유는 아무리 코드 품질을 최상으로 유지하여서 좋은 구조를 잘 설계했다고 하더라도 많은 경우에 비즈니스 도메인 문제 자체가 복잡해서 이해를 못하는 경우가 많기 때문이다. 
   * 이럴 경우에 아무리 코드를 잘 작성했어도, 빠르게 파악하는 것에는 한계가 있다. 
   * 책에서 말한 것 처럼 세부사항(문서)들도 유지보수의 대상이기 때문에 추상화 단계를 코드레벨로 낮게 유지한다면 코드 변경에 따라 문서도 수정이 필요하기 때문에 이는 너무 비효율적일 수 있다. 
   * but, 그보다 높은 추상화 단계, 예를 들면, 도메인 레벨에서의 인수조건, 통합테스트 조건, 시퀀스 다이어그램, 클래스 다이어그램 등은 큰 그림을 파악하는데 도움이 될 수 있을 것 같다

## 질문
1. 책 내용 중, 세부사항에 의존하지 말라는 주장에 동의하는지? 동의한다면, 세부사항에 의존하지 않기 위해서 하고 있는 노력은 무엇인 있는지 공유해보면 좋을 것 같습니다.
   * [내 답변]
     * 내부 비즈니스로직은 구현하지 않은 계약 정보만 나타내는 API를 만들어서 선 공유
   * [답변 상세]
     * 책에서 말하는 세부사항에 의존하지 말라는 주장은 매우 공감한다. 
     * 나의 경우는 클라이언트 개발자와 소통하는 경우가 많다 그러다보니 API 협의를 할 때, 주로 위키 페이지 하나를 만들어서 공유하는 형태로 했었다. 
     * 이것의 가장 큰 문제는 후에, swagger가 생겼을 때, 문서가 이원화 된다는 점이다. 둘중 하나는 세부사항이 된다. 
     * 파이썬의 pydantic과 타입힌트로 인해서, swagger를 쓰면, 코드 계약 변경에 유동적으로 swagger 변경도 가능하기 때문에 요즘에는 위키문서를 따로 만들지 않고, 내부 비즈니스로직은 구현하지 않은 계약 정보만 나타내는 API를 만들어서 선 공유하는 형태로 세부사항에 의존하지 않고, 대응하고 있다