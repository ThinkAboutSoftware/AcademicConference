# Ch11. 단위 테스트의 실제

## 중요문장 & 내 생각

1. 코드를 테스트하는 것은 할 일 목록을 만들어 작업하는 것과 약간 비슷하다.
    
    > 내 생각
      - 테스트를 테스트 자체로 보지 말고 할일의 목록의 관점에서 바라보면, 좀 더 익숙하게 생각해 볼 수 있다 나의 경우는 인수 테스트를 설계할 때, 자주 활용하는데 일종의 체크 리스트로 작성해서 그대로 참조하여서 테스트 코드를 작성하고, 후에 미리 설계한 인수 테스트 목록을 다른 QE, PO 분께 테스트를 부탁 드리는 형태이다
    > 
2. 요점은 테스트 대상 코드의 각 줄, if문, 논리 표현식, 값 등은 그것이 존재하는 이유가 있어야 한다는 것이다. 불필요한 코드라면 그것은 제거되어야 한다.
    
    > 내 생각
      - 매우 동의하는 내용이다 코드 자체 한줄 한줄 작성할 때 마다 작성자의 의도가 잘 드러나도록 작성하는 것이 필요하고 누군가가 코드에 대해서 설명했을 때 내가 어떤 의도로 작성했는지를 하나하나 언급해줄 수 있어야 한다
    > 
3. 간과하기 쉬운 또 다른 중요한 동작은 오류 시나리오가 발생할 때 코드가 어떻게 동작하는 가다. 오류가 자주 발생할 것으로 예상하지 않기 떄문에 이러한 경우는 다소 경계 조건처럼 보일 수 있다.
    
    > 내 생각
      - 오류 시나리오는 expected behavior 중 unhappy path 혹은 unexpected behavior 로 볼 수 있을 것 같다 당연하게도 두가지 케이스 모두 테스트 케이스를 설계할 때 모두 고려되어야 하고, 테스트 코드 상으로도 구현이 되어야 만 한다
      - 내 경우는 주로 웹 백엔드 API를 작성하는 코드를 작성하기 때문에 HTTP status code와 error message를 어떻게 적절하게 내려줄것인가를 주민 고민하고, 테스트에 반영한다 대개의 경우 unhappy path는 400 대 에러, unexpected behavior는 500 대 에러를 기본으로 보고 FE와 각각의 상태코드 일 때 어떻게 처리할지 까지 얘기를 하는게 맞다고 생각한다
    > 
4. 좋은 단위 테스트는 궁극적으로 중요한 행동을 테스트해야 한다. 이렇게 하면 테스트는 코드의 문제점을 정확하게 감지할 가능성을 극대화하며 구현 세부 사항에 독립적으로 된다.
    
    > 내 생각
      - 개인적으로 테스트를 작성할 때, 이 문장을 잘 기억하고 작성하면 좋을 것 같다. 우리의 목표는 커버리지 100을 충족하는 한치의 오차도 없는 테스트를 작성하기 위해서 private 함수까지 테스트하는 것이 아니라, 정말로 중요한 비즈니스 로직을 테스트 코드를 통해 검증을 해야한다는 것이다
      - 과거에는 무언가 꼼꼼하게 테스트 코드를 작성해서 모든 케이스를 단순하게 커버하려고 했으나, 요즘에는 정말로 중요한 비즈니스로직에서의 모든 케이스를 커버하려고 하는지? 를 더 많이 살펴보고 있다
    > 
5. 그러나 클래스(또는 코드 단위)가 더 복잡하거나 많은 논리를 포함하면 퍼블릭 API를 통해 모든 동작을 테스트하는 것이 까다로울 수 있다. 이 경우는 코드의 추상화 계층이 너무 크다는 것을 의미하기 때문에 더 작은 단위로 분할하는 것이 유익하다
    
    > 내 생각
      - 내가 딱 말하고 싶었던 부분이다 퍼블릭 API 만을 테스트해야한다 라는 얘기를 잘못 이해하면, 많은 경우에 퍼블릭 API 를 테스트하는 것 자체에만 집중하여서, 좋은 클래스 설계를 놓치는 경우가 많다 이 결과로 퍼블릭 APi가 너무 많은 책임을 가지면서 테스트가 고통 스러워진다
      - 대표적으로, 내가 이전까지 테스트코드를 작성하던 방법은 하나의 API 단위로, 모든 의존성이 포함된 통합테스트 성격의 테스트 코드를 작성하고 있었는데, API의 내부의 비즈니스로직이 복잡하면 복잡할 수록, 의존성이 많으면 많을 수록, 테스트 코드를 작성하기도 힘들고, 작성하더라도 이해하기도 힘들고, 유지보수가 힘들었던 경험이 있다 그때는 내가 코드를 못짜서 그런건줄 알았는데, 내가 코드를 못짜는 것은 너무 나도 당연한결과 였던 것이다 어느 순간부터는 클래스 혹은 함수단위로 책임을 나누고 테스트 하기 쉬운 형태로 맞춰서 구현 했었던 것 같다
    > 
6. 10장에서는 좋은 단위 테스트의 주요 특징 중 하나로 이해하기 쉬운 테스트 코드를 언급했다. 이렇게 하나의 테스트 케이스로 모든 행동을 테스트하면 테스트 코드는 이해하기 어려워진다는 것을 바로 알 수 있다.
    
    > 내 생각
      - 하나의 테스트 메소드에서 너무 많은 책임을 가지고 여러 항목들을 테스트하는 것을 경험해보았다. 내가 코드를 못짜기 때문에 테스트 코드를 제대로 작성못하는 것인줄 알았는데, 애초에 이런 구조에서는 좋은코드도, 읽기 좋은 코드가 절대 나올 수 없다고 생각한다
      - 다른 분들의 코드 작성 의도를 생각해보면, 하나의 메소드에서 여러개의 항목을 테스트 하는 것이 의도된 경우도 있었다. 메소드를 나누지 않고 한 메소드에서 테스트 하는 것을 응집성의 관점으로 보셨던 것 같다 개인적으로는 응집성은 클래스 단위로 테스트를 나누는 것으로 대체하고, 테스트 코드 자체는 확인하고 싶은 항목마다 최대한 잘라서 구현하는게 낫다고 생각한다
    > 
7. 테스트 용이성을 위해 의존성 주입을 사용하라
    
    > 내 생각
      - 내가 느끼기에는 이책 에서 말하는 의존성 주입의 맥락은 파이썬에서는 fixture를 테스트 메소드로 주입하는 것 같다. 파이썬의 pytest를 사용하면 외부 의존성(특히 DB)에 대한 fixture를 생성하고, 이를 인자를 통해서 주입 할 수 있다 이미 fixture로 만들어진 instance를 인자로 넘기거나, factory instance를 넘겨서 DB와 관련된 객체를 원하는 개수 만큼 생성 가능하다
      - 위에서 말한 미리 정의한 fixture를 인자로 주입하는 형태를 쓰지 않으면, 각 테스트가 돌 때마다 factory 클래스 혹은 메소드를 따로 만들어두고 사용하거나 매번 중복되는 코드를 테스트 메소드 내에 작성해야할 수 도 있다. 
      - 또한 fixture는 한번 정의하고, 여러 테스트클래스의 테스트 메소드 인자로 쉽게 주입할 수 있지만, 이를 사용하지 않으면서 Mixin 형태의 클래스를 만들어서 상속해서 사용해야 한다. unittest 를 사용하게 된다면 주로 이렇게 Mixin을 구현해서 여러 테스트 클래스에서 공통적으로 쓸 수 있게 코드를 작성 했던 것 같다
    > 

## 질문

- 10, 11장을 통해서 테스트와 관련된 다양한 얘기를 하였는데, 본인이 과거에 겪어보았거나 혹은 현재 상황에서 가장 어렵고 힘든 부분 혹은 고민 되는 부분은 무엇인지 얘기해보면 좋을 것 같습니다