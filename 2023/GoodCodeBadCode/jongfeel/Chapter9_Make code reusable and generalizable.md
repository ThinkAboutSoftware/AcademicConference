## 9장 코드를 재사용하고 일반화할 수 있도록 하라

<pre>
논의주제)
많은 다른 책에서도 언급하지만 static 메서드의 사용은 거의 죄악시 되고 있고 여기 9.2 전역 상태를 주의하라 에서도 같은 주제로 이상 동작과 버그 발생을 근거로 static 사용을 금지하고 조금 더 객체지향적인 의존성 주입을 권고하고 있다.
역시 좋은 팀에서도 static 메서드의 사용은 자제하는데, 아직도 많은 회사, 많은 팀, 많은 개인들이 static을 저자가 주장하는 바 대로 쉽고 빠르게 처리하는 방법이라 생각하고 많이 사용하는데

<b>static을 사용하는 것이 왜 문제인가? 에 대해 옹호하는 사람의 주장을 들은 바가 있다면 얘기해 보면 재밌을 것 같습니다.</b>

제가 제일 많이 들었던 주장은 "어차피 큰 문제 없다"였고 그 다음은 "문제일 수 있지만 시간이 없다 빨리 개발해야 한다" 였습니다. 그 외에도 기본 라이브러리 패키지에도 static을 쓰는데 이게 문제였냐? static은 아무 문제가 없다 등도 있었습니다.
</pre>

다른 개발자가 이미 주어진 하위 문제를 해결했다면, 해당 문제에 대한 해결책을 재사용하는 것이 타당 하다.
이렇게 하면 시간을 절약할 수 있고, 재사용하는 코드는 이미 테스트되고 실행되었기 때문에 버그 발생 가능성도 줄어든다.

향후에 재사용이 가능하도록 의도적으로 코드를 작성하고 구조화하는 것이 바람직하다.
이것은 초기에 노력이 좀 더 필요할 수 있지만 (대개의 경우 아주 많이 필요하지는 않다)
장기적으로 보면 자신과 팀 동료들의 시간과 노력을 절약할 수 있다.

### 9.1 가정을 주의하라

코드 작성 시 가정을 하기 전에 그 가정으로 초래될 비용과 이점을 생각해 봐야 한다. 코드 단순화 또는 효율성의 명백한 이득이 미미하다면 늘어난 취약성으로 인한 비용이 장점을 능가하기 때문에 가정을 하지 않는 것이 최선일 수 있다.

#### 9.1.1 가정은 코드 재사용 시 버그를 초래할 수 있다

Article.getAllImages() 함수는 기사에 포함된 모든 이미지를 반환한다. 함수 이름과 달리 이 코드는 이미지가 포함된 섹션이 하나만 있을 것이라고 가정한다. 이 가정은 코드 내에서 주석문으로 설명되지만, 코드를 사용하는 쪽에서는 알 수 없다.

섹션 하나의 이미지를 발견하자 마자 이미지를 반환하는 건 미약한 성능 향상은 있지만 미미하므로 중요하지는 않다.
섹션이 두 개 이상 있으면 잘못된 가정으로 모든 이미지를 반환하지 않는 사실이 중요하다.

가정을 포함하는 코드

``` java
class Article {
  private List<Section> sections;
  ...
  List<Image> getAllImages() {
    for (Section section in sections) {
      if (section.containsImages()) {
        return section.getImages();
      }
    }
    return [];
  }
}
```

누구든지 getAllImages()라는 함수를 보면 ‘모든’ 이미지를 반환한다고 가정할 것이다. 불행하게도 이것은 숨겨진 가정이 사실일 때만 올바르다.

#### 9.1.2 해결책: 불필요한 가정을 피하라

**섣부른 최적화**

> 섣부른 최적화를 피하려는 열망은 소프트웨어 공학과 컴퓨터 과학 내에서 잘 정립된 개념이다. 코드 최적화는 일반적으로 비용이 든다.
대부분의 경우에는 큰 효과 없는 코드 최적화를 하느라고 애쓰기보다는 코드를 읽을 수 있고, 유지보수 가능하며, 견고하게 만드는 데 집중하는 것이 좋다.

코드를 작성할 때 필요 이상으로 성능비용과 같은 문제에 주의를 기울이는 경우가 있다.
특정한 가정으로 인해 성능이 눈에 띄게 향상되거나 코드가 크게 단순해진다면, 그 가정은 충분히 가치 있는 것일 수 있다.
그러나 가정으로 인해 얻는 이득이 미미하다면, 오히려 비용이 이점보다 훨씬클 수 있다.

#### 9.1.3 해결책: 가정이 필요하면 강제적으로 하라

코드에 가정이 있으면 다른 개발자들이 그것을 여전히 모를 수 있고 무의식중에 곤란을 겪지 않도록 하기 위해 가정을 강제적으로 시행해야 한다.

1. 가정이 '깨지지 않게' 만들라
2. 오류 전달 기술을 사용하라

##### 문제의 소지가 있는, 강제되지 않은 가정

강제되지 않은 가정은 오류나 경고가 발생하지 않기 때문에 모든 것이 잘 작동하는 것처럼 보인다.

##### 가정의 강제적 확인

오류 전달 기법을 사용하여 가정을 강제로 인지하게 함으로써 신속하게 실패하는 코드로 변경한다.
예로 getOnlyImageSection()과 같이 함수가 이미지 섹션이 하나만 있다고 가정하게 만드는 이름을 주고
가정이 실패하면 어서션을 통해 강제로 확인시킨다.

가정 때문에 치러야 할 비용이 그 가정으로 인해 얻는 이득보다 크다면, 가정을 하지 않는 것이 최선이다.
가정이 필요하다면 다른 개발자가 그 가정으로 인해 오류에 빠지지 않도록 최선을 다해야 한다.

### 9.2 전역 상태를 주의하라

전역 상태global state 또는 전역 변수global variable는 실행되는 프로그램 내의 모든 콘텍스트 사이에 공유된다.

전역변수는 프로그램 내의 모든 콘텍스트에 영향을 미치기 때문에
전역 변수를 사용할 때는 누구도 해당 코드를 다른 목적으로 재사용하지 않을 것이라는 암묵적인 가정을 전제한다.

#### 9.2.1 전역 상태를 갖는 코드는 재사용하기에 안전하지 않을 수 있다

어떤 상태에 대해 프로그램의 여러 부분이 공유하고 접근할 필요가 있을 때 이것을 전역변수에 넣고 싶은 마음이 들 수 있다.
이렇게 하면 코드의 어느 부분이라도 그 상태에 접근하기가 아주 쉽다.
하지만 이렇게 하면 코드를 재사용하는 것이 안전하지 않을 때가 있다.

온라인 쇼핑 애플리케이션에서 사용자는 항목을 탐색하고 바구니에 추가한 다음 마지막에 체크아웃 한다고 하자.
이 시나리오에서 사용자의 장바구니 항목은 애플리케이션의 많은 부분에서 접근하기 때문에 전역 변수로 만들고 싶을 수 있다.

##### 누군가가 이 코드를 재사용하려고 하면 어떻게 되는가?

장바구니 코드는 암묵적인 가정이 이루어졌는데, 쇼핑 애플리케이션 실행 인스턴스당 하나의 장바구니만 필요하다는 것이었다.
하지만 아래의 여러 시나리오로 가정이 깨지는 상황을 접할 수 있다.

- 서버는 많은 사용자로 부터 요청을 처리하기 때문에 사실 실행 인스턴스당 장바구니는 많이 존재해야 한다
- 장바구니 항목을 저장할 수 있는 기능을 추가한다면?
- 정상 재고 상품 외에 신선식품을 판매한다면 별도의 장바구니가 필요할 수 있다

원래의 가정이 취햑하고 어느 시점에 이르면 어떤 식으로든 그 가정을 깨트리는 그럴듯한 시나리오들이 충분히 있다.
이런 가정으로 인해 중복된 코드로 개발자가 유지 관리해야 하는 비용이 늘어나고, 최악의 경우 악성 버그가 발생한다.

#### 9.2.2 해결책: 공유 상태에 의존성 주입하라

의존성 주입은 전역 상태를 사용하는 것보다 더 통제된 방법으로 서로 다른 클래스 간에 상태를 공유하는 좋은 방법이기도 하다.

전역 상태는 프로그램의 여러 부분 간에 정보를 공유하는 빠르고 쉬운 방법처럼 보이기 때문에 전역 상태를 사용하고 싶은 망므이 들 수 있다.
그러나 이것을 사용하면 코드 재사용이 전혀 안전하지 않을 수 있다.
다른 개발자들은 전역 상태를 모를 수 있기 때문에 재사용하려고 하면 이상 동작과 버그를 발생시킬 수 있다.
상태를 공유해야 할 때는 의존성 주입을 사용하 통제된 방식으로 수행하는 것이 안전하다.

### 9.3 기본 반환값을 적절하게 사용하라

합리적인 기본값은 사용자 친화적인 소프트웨어를 만들기 위한 좋은 방법이다.
워드 프로세서의 글꼴, 텍스트 크기, 색상, 배경색, 줄 간격 등이 기본으로 세팅되어 있고 입력을 바로 시작할 수 있다.

클래스의 생성자가 10개가 제공이 되어도 모두 기본 값이 제공된다면 호출하는 쪽에서는 객체를 생성하는 일이 쉬워진다.

기본 값을 제공하려면 두 가지 가정이 필요하다

- 어떤 기본값이 합리적인지
- 더 상위 계층의 코드는 기본값을 받는지 명시적으로 설정된 값을 받는지 상관하지 않는다.

상위 수준의 코드는 특정 사용 사례에 더 밀접하게 결합하므로 코드의 모든 용도에 맞는 기본값을 선택하기가 더 쉽다.
반면에 낮은수준의 코드는 보다 근본적인 하위 문제를 해결하여 여러 사용 사례에 더 광범위하게 재사용되는 경향이 있다. 

#### 9.3.1 낮은 층위의 코드의 기본 반환값은 재사용성을 해칠 수 있다

기본 글꼴로 Arial을 원하지 않는 경우에 UserDocumentSettings 클래스를 다시 사용하고자 하는 경우 어려움을 겪을 수 있다.

기본값 반환

``` java
class UserDocumentSettings {
 private final Font? font;
 ...
 Font getPreferredFont() {
   if (font != null) {
     return font;
   }
   return Font.ARIAL;
 }
}
```

기본 반환값을 UserDocumentSettings 클래스와 묶어 놓은 것은 모든 상위 계층에 대해 Arial이 적합한 기본 글꼴이라고 가정한 것이 된다. 다른 개발자가 코드를 재사용하거나 요구 사항이 변경되면 이런 가정은 쉽게 문제가 될 수 있다.

UserDocumentSettings는 추상화 계층이 없이 하위 문제를 바로 구현한 것이므로 문제가 된다.
사용자 환경 설정과 프로그램 기본값 정의는 별개의 하위 문제로 볼 수 있으므로
두 하위 문제로 분리하고 상위 계층의 코드가 사용자에게 적합한 방식으로 기본값을 처리할 수 있도록 한다.

#### 9.3.2 해결책: 상위 수준의 코드에서 기본값을 제공하라

UserDocumentSettings에서 기본값 설정은 값이 없을 때 널값을 반환하는 것이다.
그러면 호출하는 쪽에서 원하는 방식으로 하위 문제를 해결할 수 있으며 코드의 재사용성을 높여준다.

기본값은 코드(및 소프트웨어)를 훨씬 쉽게 사용할 수 있으므로 활용할 가치가 충분하다.
기본값을 반환하면 그 위의 모든 상위 계층에서 해당 값을 사용할 것이라고 가정하기 때문에 코드 재사용과 적응성을 제한할 수 있다.
낮은 층위의 코드에서 기본값을 반환하는 것은 문제가 될 수 있다.

### 9.4 함수의 매개변수를 주목하라

함수가 한두 가지 정보만 필요로 할 때는 객체나 클래스의 인스턴스를 매개변수로 사용하는 것은 코드의 재사용성을 해칠 수 있다.

#### 9.4.1 필요 이상으로 매개변수를 받는 함수는 재사용하기 어려울 수 있다

너무 많은 매개변수를 받는 함수

``` java
void styleAsWarning(TextBox textBox) {
 TextOptions style = new TextOptions(Font.ARIAL, 12.0, 14.0, Color.RED);
 textBox.setTextColor(style);
}
```

TextBox.setTextColor 함수는 텍스트 색상만 설정한다. 따라서 전체 TextOptions 인스턴스를 매개변수로 사용할 필요가 없다.
이런 방식은 불필요함을 넘어, 조금 다른 상황에서 재사용할 때 해로운 영향을 끼친다.
함수는 필요한 것만 매개변수로 받는 것이 더 바람직하다.

#### 9.4.2 해결책: 함수는 필요한 것만 매개변수로 받도록 하라

일반적으로 함수가 필요한 것만 받도록 하면 코드는 재사용성이 향상되고 이해하기도 쉬워진다.
하지만 10가지 항목을 캡슐화하는 클래스에서 8개를 필요로 하는 함수가 있다면 객체 전달이 합리적일 수 있다.
모든 상황에 적용되는 한 가지 정답은 없으며, 취하고 있는 방법의 장단점과 초래할 결과를 알고 있는 것이 좋다.

### 9.5. 제네릭의 사용을 고려하라

다른 클래스를 참조하는 코드를 작성하지만 그 클래스가 어떤 클래스인지 신경 쓰지 않는다면 제네릭의 사용을 고려해야 한다.
제네릭을 사용하면 아주 적은 양의 추가 작업이 있긴 하지만 코드의 일반화가 크게 향상된다.

#### 9.5.1 특정 유형에 의존하면 일반화를 제한한다

단어 맞히기 게임의 예로 게임 참여자들이 각각 단어를 제출한 다음 돌아가면서 한 단어씩 동작으로 설명하면 다른 선수들이 어떤 단어인지 맞혀야 한다.

여기서 단어 모음을 저장하고, 한 단어씩 무작위로 선택한 후에 제한 시간 내에 맞히지 못한다면 다시 단어 모음에 넣는다.

RadomizedQueue는 add(String value) 함수와 String? getNext() 함수를 제공해서 기능을 구현할 수 있지만
String에 대한 의존도가 높으므로 다른 유형을 저장하는데 사용할 수 없다.
게임 참여자가 단어 대신 사진을 보고 설명하는 것만 요구 사항이 변경되고 나머지 룰은 동일한 게임을 다른 팀에서 개발한다고 하면 하위 문제를 해결해 줄 만큼 일반화 되어 있지 않으므로 재사용할 수 없다.

#### 9.5.2 해결책: 제네릭을 사용하라

RandomizedQueue<T>를 써서 제네릭 클래스를 정의한다.

**제네릭 및 널 형식**

> RadomizedQueue<String?>과 같이 정의하고 널값을 저장하면 문제가 된다. getNext()가 널 값을 반환할 때 이게 큐에 존재하는 널값인지 큐가 비어 있다는 뜻의 널값인지 구별할 수 없기 때문이다. 이걸 지원하고자 하면 hasNext() 함수를 통해 큐가 비어 있는지 확인할 수 잇게 구현한다.

높은 수준의 문제를 하위 문제로 세분화하다 보면 다양한 사례에 적용할 수 있는 매우 근본적인 문제를 접한다.
하위 문제에 대한 해결책이 모든 데이터 유형에 쉽게 적용될 수 있을 때 특정 유형에 의존하는 대신 제네릭을 사용하더라도 추가적인 노력이 거의 들어가지 않는다.
이렇게 하면 코드는 보다 더 일반화되고 재사용이 가능하다는 측면에서 쉽게 효과를 볼 수 있다.

### 요약

- The same subproblems often crop up again and again, so making code reusable can save your future self and your teammates considerable time and effort.
- Try to identify fundamental subproblems and structure the code in a way that will allow others to reuse the solutions to specific subproblems even if they’re solving a different high-level problem.
- Creating clean layers of abstraction and making code modular often result in code that is a lot easier and safer to reuse and generalize.
- Making an assumption often has a cost in terms of making the code more fragile and less reusable.
  - Make sure the benefits of an assumption outweigh the costs
  - If an assumption does need to be made, then make sure it’s in an appropriate layer of the code and enforce it if possible
- Using global state often makes a particularly costly assumption that results in code that is completely unsafe to reuse. In most scenarios, global state is best avoided.