## 7장 코드를 오용하기 어렵게 만들라

<pre>
이번 챕터에서 언급한 코드 오용 사례들과 그걸 해결하는 방법에 대해 언급한 것 중 괜찮았거나 한번 써보면 좋을 것들에 대해 얘기해 보면 좋을 것 같습니다.

저의 경우는 record type에 대해 C# 9.0 에서 소개되서 관심을 가지게 됐는데 실제 현업에서는 사용하지 않아서 불변 객체를 만들 수 있는 record type에 대해 찾아보는 계기가 됐고 앞으로 써보면 좋겠다는 생각을 했습니다.

한가지 더 흥미로웠던 것은 기본 라이브러리에는 거의 date, time을 표현할 수 있는 클래스, 구조체를 제공해 주는데 C# 쪽에는 nodatime이라는 걸 이 책을 통해 처음 접했습니다. 이 역시도 기본 라이브러리와 어떤 점에서 좋은지 찾아보면 좋겠다는 생각이 들었습니다. 
</pre>

비합리적이거나 애매한 가정에 기반해서 코드가 작성되거나 다른 개발자가 잘못된 일을 하는 것을 막지 못할 때 코드는 오용되기 쉽다. 코드를 잘못 사용할 수 있는 몇 가지 일반적인 경우는 다음과 같다.

- 호출하는 쪽에서 잘못된 입력을 제공
- 다른 코드의 부수 효과(입력 매개변수 수정 등)
- 정확한 시간이나 순서에 따라 함수를 호출하지 않음
- 관련 코드에서 가정과 맞지 않게 수정이 이루어짐

코드를 오용하기 어렵게 설계하고 작성하는 것이 중요하다.

### 7.1 불변 객체로 만드는 것을 고려하라

객체가 생성된 후에 상태를 바꿀 수 없다면 불변immutable 객체이다.
가변mutability 객체가 어떻게 문제를 일으키는지 고려해 보면 아래와 같다.

- 가변 객체는 추론하기 어렵다
- 가변 객체는 다중 스레드에서 문제가 발생할 수 있다

#### 7.1.1 가변 클래스는 오용하기 쉽다

클래스를 가변적으로 만드는 가장 일반적인 방법은 setter 함수를 제공하는 것이다.
이런 방식은 클래스의 인스턴스를 쉽게 오용할 수 있다.
클래스의 setter 함수의 매개변수를 가변 객체로 전달하면서 내부에서 setter 함수를 통해 변경되는 것도 오용의 사례이다.

#### 7.1.2 해결책: 객체를 생성할 때만 값을 할당하라

모든 값이 객체의 생성 시점에만 가능하게 하고 그 이후로는 변경할 수 없도록 함으로써 클래스를 불변적으로 만들 수 있고 오용도 방지할 수 있다.
언어마다 const, final, readonly를 통해 더 명시적으로 클래스 내부의 변수 값이 변경되지 않도록 할 수도 있다.

만약 값의 변경이 필요한 경우가 생긴다면 복사copy-on-write 패턴을 사용할 수 있다.

가변 객체의 오용 사례

``` java
baseStyle.setFontSize(18.0);
```

복사 패턴으로 새로운 객체를 생성하는 사례
``` java
TextOptions newBaseStyle = baseStyle.withFontSize(18.0);
```

#### 7.1.3 해결책: 불가변성에 대한 디자인 패턴을 사용하라

일부 값이 반드시 필요하지 않거나 불변적인 클래스의 가변적 버전을 만들어야 하는 경우,
두 가지 유용한 디자인 패턴은 다음과 같다.

- 빌더 패턴
- 쓰기 시 복사 패턴

##### 빌더 패턴

클래스의 일부 값이 선택 사항인 경우 생성자로 생성하기에는 상당히 까다로울 수 있으므로
setter 함수를 추가하여 빌더 패턴을 사용하는 것이 낫다.

빌더 패턴은 한 클래스를 두 개로 나누는 효과를 갖는다

- 값을 하나씩 설정할 수 있는 빌더 클래스
- 빌더에 의해 작성된 불변적인 읽기 전용 클래스

빌더 패턴은 값의 일부(또는 전체)가 선택 사항일 때 불변적 객체를 만드는 매우 유용한 방법이다.
빌더 패턴 시 인스턴스의 복사본을 약간 수정해야 하는 경우는 미리 값이 채워진 빌더를 만드는 함수를 제공할 수 있다. 이 작업은 약간 번거로울 수 있다. 이 대안으로 쓰기 시 복사 패턴을 사용할 수 있다.

##### 쓰기 시 복사 패턴

renderTitle() 함수와 같은 코드에서 TextOptions 객체의 변경된 버전이 필요한 경우 원본 객체에 영향을 미치지 않고도 변경된 복사본을 쉽게 얻을 수 있다.

``` Java
void renderTitle(String title, TextOptions baseStyle {
  titleField.display(title, baseStyle.withFontSize(18.0));
}
```

클래스를 변경할 수 없게 하는 것은 클래스가 오용될 가능성을 최소화하는 좋은 방법이다. 이것은 세터 함수를 제거하고 인스턴스를 생성할 때에만 값을 제공하면 간단하게 할 수 있다.

### 7.2 객체를 깊은 수준까지 불변적으로 만드는 것을 고려하라

클래스가 실수로 가변적으로 될 수 있는 일반적인 경우는 깊은 가변성deep mutability 때문이다. 이 문제는 멤버 변수 자체가 가변적인 유형이고 다른 코드가 멤버 변수에 액세스할 수 있는 경우에 발생할 수 있다.

#### 7.2.1 깊은 가변성은 오용을 초래할 수 있다

다른 코드가 TextOptions 클래스의 글꼴 리스트를 참조하는 두 가지 시나리오가 있다.

- 시나리오 A: TextOptions 클래스를 생성하는 코드가 글꼴 목록에 대한 참조를 유지하고 나중에 변경할 수 있다.
- 시나리오 B: TextOptions.getFontFamily()를 호출할 때 글꼴 목록에 대한 참조를 받는다. 이참조를 사용하여 목록의 내용을 수정할 수 있다.

##### 시나리오 A

TextOptions 인스턴스 내의 fontFamily는 이제 Font.COMIC_SANS만 가지고 있다

생성된 후 수정되는 리스트

``` Java
List<Font> fontFamily = [Font.ARIAL, Font.VERDANA];
TextOptions textOptions = new TextOptions(fontFamily, 12.0);
fontFamily.clear();
fontFamily.add(Font.COMIC_SANS);
```

##### 시나리오 B

호출하는 쪽에 의해 수정된 리스트

``` Java
TextOptions textOptions = new TextOptions([Font.ARIAL, Font.VERDANA], 12.0);
List<Font> fontFamily = textOptions.getFontFamily();
fontFamily.clear();
fontFamily.add(Font.COMIC_SANS);
```

개발자가 textOptions.
getFontFamily()와 같은 함수를 호출할 때 리스트가 다른 함수나 생성자가 호출됨에 따라 여러 번전달될 수 있다. 그것이 어디서 왔는지 그리고 그것을 수정하는 것이 안전한지 추적하기가 쉽지 않다.

#### 7.2.2 해결책: 방어적으로 복사하라

클래스가 참조하는 객체가 클래스 외부의 코드에서는 참조할수 없도록 하면 이 문제를 방지할 수 있다. 이것은 클래스가 생성될 때 그리고 게터 getter 함수를 통해 객체가 반환될 때 객체의 복사본을 만들면 가능해진다. 이것은 반드시 최선의 해결책은 아니지만, 깊은 불변성을 담보하기 위해 효과가 있는 간단한 방법이다.

방어적으로 복사하면 불변적인 클래스를 만드는 데 꽤 효과적일 수 있지만, 단점도 명확하다.

- 복사하는 데 비용이 많이 들 수 있다
- 클래스 내부에서 발생하는 변경을 막아주지 못하는 경우가 많다. 변수를 final로 표현해도 변수에 대한 불변이지 변수가 참조하는 객체가 불변은 아니다. 즉 fontFamily.Add() 호출이  가능해진다.

#### 7.2.3 해결책: 불변적 자료구조를 사용하라

불변 객체의 장점은 생성되고 난 이후에는 아무도 내용을 변경할 수 없다는 것이다.
방어적으로 복사본을 만들 필요 없이 객체를 전달할 수 있다는 것을 의미한다.

Java, C#에서 `ImmutableList` 클래스를 사용할 수 있다.

불변적인 자료구조를 사용하는 것은 클래스가 깊은 불변성을 갖도록 보장하기 위한 좋은 방법 중 하나다.
방어적으로 복사해야 하는 단점을 피하고 실수로라도 클래스 내의 코드에서 변경되지 않도록 보장한다.

### 7.3 지나치게 일반적인 데이터 유형을 피하라

일반적으로 다재다능하다는 것을 뒤집어 생각해보면 데이터 유형 자체만으로는 무언가를 설명할 수 없고,
가질 수 있는 값에 있어서도 꽤 관대하다는 것을 의미한다.

정수나 리스트와 같은 유형으로 표현이 '가능'하다고 해서 그것이 반드시 '좋은' 방법은 아니다.

#### 7.3.1 지나치게 일반적인 유형은 오용될 수 있다

위도, 경도의 값을 List<Double>로 표현하고 그 리스트를 List<LIst<Double>>로 표현하는 것은 너무 일반적인 데이터 유형이다.

이런 방식은 코드를 오용하기 쉽게 만드는 단점이 있다.

- List<List<Double>> 유형 자체로는 아무것도 설명해주지 않는다.
- 개발자는 리스트에서 어떤 항목이 위도와 경도인지 혼동하기 쉽다.
- 형식 안전성이 거의 없다.

##### 패러다임은 퍼지기 쉽다

LocationDisplay.markLocationsOnMap() 함수의 작성자는 지도상의 위치를 나타내기 위해 List<Double>을 사용하는 것이 임시변통의 방법이라는 것을 알고 있다.
하지만 코드 베이스에 해를 끼지지는 않을 것이라고 생각하고, 이런 임시변통을 사용한 것을 정당화할 수 있다.
문제는 임시변통으로 작성한 코드는 다른 코드 전반에 퍼지는 경향이 있다는 점인데,
다른 개발자들도 같은 방식을 따르지 않으면 이미 임시변통으로 작성한 코드와 상호작용하기 어려워지기 때문이다.
이런 식으로 임시변통의 코드가 모르는 사이에 만연해 있게 되면 이를 바로잡기가 매우 어려워진다.

#### 7.3.2 페어 유형은 오용하기 쉽다

Pair<A, B>와 같이 쓰는 데이터 유형은 표준 라이브러리의 일부일 때도 있고 확장 라이브러리를 통해 제공되는 경우도 많다.
지도상의 위치를 List<Double>이 아니라 Pair<Double, Double>로 표현한다고 해도
역시 설명이 필요한 문서가 있어야 하며 이 위치 값의 리스트인 List<Pair<Double, Double>> 역시 무엇을 의미하는지 파악하기 쉽지 않다.

#### 7.3.3 해결책: 전용 유형 사용

무언가를 나타내기 위해 새로운 클래스(또는 구조체)를 정의하는 것은 많은 노력이 들거나 불필요한 것처럼 보일 수 있지만,
대부분 보기보다 노력이 덜 들어가고 다른 개발자가 코드를 읽을 때 이해하기 쉽고 버그의 가능성도 줄여준다.

class LatLong을 정의하고 위도와 경도를 나타내는 코드는 작성하고 테스트하는 데 몇 분 이상은 걸리지 않을 것이다.
또 의미도 명백하므로 문서가 필요가 없고 유형 안정성이 높아진데다가 위도와 경도를 혼동할 일이 없다.

데이터 객체는 데이터를 그룹으로 묶기만 하는 간단한 객체를 정의하는 것이다.

- Kotlin: data class는 한 줄 짜리 코드를 사용하여 데이터를 포함하는 클래스를 정의할 수 있다
- Java 14, C# 9: record 사용
- TypeScript에서는 인터페이스를 정의하고 이를 사용하는 객체가 반드시 포함해야 하는 속성에 대해 컴파일 타임 안전성을 제
- 그외 언어에서는 struct 사용

### 7.4 시간 처리

시간을 나타내는 것은 다음과 같은 점에서 상당히 까다롭다.

- '1969년 7월 21일 02:56 UTC'와 같이 절대적인 시간도 있지만, '5분 내'와 같은 상대적인 시간도 있다.
- '오븐에서 30분 굽기'와 같은 시간의 양을 언급하는 경우
- 표준 시간대, 일광 절약 시간, 윤년leap year, 윤초leap second와 같은 개념도 있다.

#### 7.4.1 정수로 시간을 나타내는 것은 문제가 될 수 있다

시간을 나타내는 큰 정수long integer는 어느 한 순간을 의미하는 시각, 그리고 시간의 양 두 가지를 모두 나타낸다.

- 순간으로서의 시간: 유닉스 시간unix epoch인 1970년 1월 1일 00:00:00 UTC 이후 몇 초로 표현하는 경우
- 양으로서의 시간: 초 혹은 밀리초 단위로 표시

##### 한순간의 시간인가, 아니면 시간의 양인가?

sendMessage()의 정수 매개변수로 deadline이 있는데 초 단위인 것만 알 수 있을 뿐 무엇을 하는지 알기 어렵다.
그러면 순간의 시간, 혹은 양의 시간으로 유추해야 한다.

- 시간의 절대 순간: 유닉스 시간 이후 경과된 초를 제공
- 시간의 양: 함수 호출 이후 타이머가 작동하고 지정된 시간에 도달하면 시한이 지난다. timeout 개념.

이 정도의 모호함이 있다면 문서화로도 명확하지 않고 문서화가 훌륭하지 않다는 점이 드러난다.

##### 일치하지 않는 단위

시간을 측정하는 단위가 밀리초millisecond, 초second, 마이크로초microsecond 와 같은 단위를 사용할 수 있다.
정수 유형으로는 어떤 단위에 있는지 나타내는 데 전혀 도움이 되지 않는다.

##### 시간대 처리 오류

순간으로서의 시간은 유닉스 시간 이후 지나간 초로 나타낸다.
보통 타임스탬프timestamp라고 부르는데, 이벤트가 발생했거나 발생할 시간을 정확하게 식별하기 위한 방법이다.
하지만 사람은 종종 시간에 대해 얘기할 때 그렇게 정확하게 표현하지 않는다.

서버가 서로 다른 위치에서 실행되고 시스템을 다른 표준 시간대로 설정한 경우 서버단의 논리만으로 잘못된 시간의 계산이 발생할 수 있다.

정수는 값이 의미하는 바나 나타내고자 하는 정보를 거의 전달하지 못하기 때문에 값을 오용하기 쉽게 만들 수 있다.

#### 7.4.2 해결책: 적절한 자료 구조를 사용하라

- Java: java.time 패키지의 클래스 사용
- C#: 노다Noda 시간 라이브러리
- C++: 크로노chrono 라이브러리
- JavaScript: 많은 서드 파티 라이브러리가 있고, 그 중 하나로 js-joda가 있다.

##### 양으로서의 시간과 순간으로서의 시간의 구분

Duration 유형을 사용함으로써 시간의 양을 나타낸다.

##### 더 이상 단위에 대한 혼동이 없다

Instant 및 Duration과 같은 유형이 제공하는 또 다른 이점은 단위가 유형 내에 캡슐화되어 있다는 점이다.
Duration 객체를 만드는데 사용하는 단위와 읽어들이는 단위가 달라도 문제 없이 읽을 수 있다.
이를 통해 코드의 서로 다른 부분이 상호작용할 때 원하는 어떤 단위라도 불일치의 위험 없이 사용할 수 있다.

``` java
Duration duration1 = Duration.ofSeconds(5);
print(duration1.toMillis()); // 5000

Duration duration2 = Duration.ofMinutes(2);
print(duration2.toMillis()); // 120000
```

##### 시간대 처리 개선

시간대에 신경 쓰지 않고 날짜와 시간을 다루는 방법을 제공하는데
LocalDateTime 클래스를 사용하면 이런 작업을 정확하게 수행할 수 있다.

### 7.5 데이터에 대해 진실의 원천을 하나만 가져야 한다

데이터는 종종 두 가지 형태로 제공된다.

- 기본 데이터primary data: 코드에 제공해야 할 데이터
- 파생 데이터derived data: 주어진 기본 데이터에 기반해서 코드가 계산할 수 있는 데이터

예)
기본 데이터: 대변credit 금액, 차변debit 금액
파생 데이터: credit 에서 debit을 뺀 금액

기본 데이터는 프로그램에서 진실의 원천source of truth이 된다.
예제에서 creadit과 debit에 대한 값은 계좌의 상태를 설명하고 상태를 추적하기 위해 저장되어야 하는 유일한 값이다.

#### 7.5.1 또 다른 진실의 원천은 유효하지 않은 상태를 초래할 수 있다

기본 데이터와 파생 데이터를 모두 처리하는 코드를 작성하는데, 논리적으로 잘못된 상태가 발생할 수 있다.

credit = 5
debit = 2
잔액balance 이 10 인 것은 말이 안된다.

UserAccount 클래스의 생성자가 UserAccount(Double credit, Double debit, Double balance)로 되어 있을 때
아래와 같이 잘못된 오류를 범할 수 있다.

```
UserAccount account = new UserAccount(credit, debit, debit - credit);
```

#### 7.5.2 해결책: 기본 데이터를 유일한 진실의 원천으로 사용하라

계좌 잔고는 대변과 차변만 가지고 완전히 계산할 수 있기 때문에 필요할 때에만 그 값을 계산하는 것이 훨씬 낫다.
즉 잔액은 getBalance() 함수가 호출될 때 마다 credit - debit 계산 값을 반환하고 매개변수에 사용하지 않으며 멤버 변수에도 저장하지 않는다. 

##### 데이터 계산에 비용이 많이 드는 경우

대변과 차변에 대한 하나의 값 계산이 아니라 트랜잭션 목록을 가지고 있다고 가정해 본다면
트랜잭션 목록은 기본 데이터이고 대변 및 차변 총액은 파생 데이터가 된다.
그러면 이렇게 파생된 데이터를 계산하려면 전체 트랜잭션 목록을 확인해야 하기 때문에 비용이 많이 든다. 

파생된 값을 계산하는데 비용이 많이 든다면, 지연lazily 계산한 후에 결과를 캐싱caching 하는 것이 좋다.
미리 계산해 두는게 아니라 그 값이 정말 필요할 때까지 계산을 미룬다는 것을 의미한다.

### 7.6 논리에 대한 진실의 원천을 하나만 가져야 한다

데이터 뿐 아니라 코드에 포함된 논리에도 진실의 원천sources of truth이 적용된다.
코드의 한 부분에서 수행하는 로직이 다른 부분에서 수행하는 로직과 일치해야 하는 경우에
논리를 위한 진실의 원천을 하나만 존재하도록 하는 것이 중요하다.

#### 7.6.1 논리에 대한 진실의 원천이 여러 개 있으면 버그를 유발할 수 있다

값을 직렬화하고 저장하는 코드가 있는 DataLogger 클래스와
값을 읽고 역직렬화하는 코드가 있는 DataLoader 클래스에서
파일이 저장되는 형식을 지정하는 논리가 DataLogger와 DataLoader 클래스에 독립적으로 포함되어 있다.
여기서 동일한 논리를 포함하지 않으면(한쪽은 10진수 한쪽은 16진수로 변환) 문제가 발생한다.

#### 7.6.2 해결책: 진실의 원천은 단 하나만 있어야 한다.

DataLogger와 DataLoader 두 클래스는 동일한 하위 문제(직렬화/역직렬화, 정수 형식 지정)를 해결하기 위해 각자의 고유한 논리를 가지고 있다.
직렬화된 정수를 저장하는 형식에 대한 진실의 원천을 하나만 갖게 되면 코드가 더 견고해지고 오류의 가능성을 줄일 수 있다.
serialize()와 deserialize()라는 두 가지 함수를 갖는 IntListFormat 클래스를 정의하여 이 작업을 수행한다.

코드베이스의 한 부분을 작업하는 개발자는 다른 부분에 있는 코드가 내포하고 있는 가정을 인식하지 못할 수 있다.
중요한 논리에 대해 진실의 원천이 하나만 존재하도록 하면 코드가 훨씬 더 견고해진다.

### 요약

- If code is easy to misuse, then there is a high chance that at some point it will be misused. This can lead to bugs.
- Some common ways in which code can be misused are:
  - Callers providing invalid inputs
  - Side-effects from other pieces code
  - Callers not calling functions at the correct times or in the correct order
  - A related piece of code being modified in a way that breaks an assumption
- It’s often possible to design and structure code in a way that makes it hard or impossible to misuse. This can greatly reduce the chance of bugs and save engineers a lot of time in the mid to long term. 