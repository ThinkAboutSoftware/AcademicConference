## 10장 단위 테스트의 원칙

```
논의내용)
마지막에 테스트 철학에 대한 저자의 생각이 매우 흥미로웠습니다.
저는 이 책에 소개된 바에 따르면 극단적 고전주의자에 가까운 것 같습니다.
테스트 더블을 사용한 테스트 보다는 진짜 같은 가짜(fake) 환경을 만들어서라도 테스트 하는 게 좋다고 보는 입장입니다. 

각자 자신이 테스트하는 환경을 봤을 때 어느 쪽 철학에 가까운지 얘기해 보고 왜 그런 방식을 따르게 됐는지 논의해 보면 좋겠습니다.

저는 실제 동작하는 코드를(네트워크, DB 의존성 포함) 테스트하지 않는 건 의미가 없다고 생각하는 경향이 강한 것도 있고
주니어 시절 부터 개발, 운영 환경이 분리된 의존성 상태에서 개발 했던 적이 많아서 그랬던 것 같습니다.
```

올바르게 작동하는 (그리고 계속해서 올바르게 작동하는) 코드와 소프트웨어를 만들기 위해 테스트는 필수적이다.

코드 변경은 언제나 위험하기 때문에 코드가 처음 작성될 때 그리고 수정될 때마다 코드가 의도한 대로 작동한다는 것을 스스로 확신할 수 있는 방법이 필요하다.

단위 테스트unit test에 대해서는 정확하게 내려진 정의가 없다.
상대적으로 격리된 방식으로 코드의 구별되는 단위를 테스트 하는 것에 관한 것이다.
코드의 단위unit of code라는 것이 정확히 의미하는 바는 다양할 수 있지만,
특정 클래스, 함수, 코드 파일을 의미할 가 많다.
상대적으로 격리된 방식relatively isolated manner 역시 의미하는 바가 다양하다.
대부분의 코드는 격리되어 있지 않고, 다른 수많은 코드에 의존한다.

궁극적으로 중요한 것은 코드를 잘 테스트하고 이 작업을 유지보수할 수 있는 방법으로 수행하는 점이다.

### 10.1 단위 테스트 기초

- 테스트 중인 코드code under test: '실제 코드'라고도 하고 테스트의 대상이 되는 코드를 의미한다.
- 테스트 코드test code: 단위 테스트를 구성하는 코드를 가리킨다. 
- 테스트 케이스test case: 테스트 케이스는 특정 동작이나 시나리오를 테스트한다.
  - 준비arrange: 테스트할 특정 동작을 호출하기 위해 설정을 수행하는 일
  - 실행act: 테스트 중인 동작을 실제로 호출하는 코드
  - 단언assert: 테스트 중인 동작이 실행되고 나면 실제로 올바른 일이 발생했는지 확인
- 테스트 러너test runner: 테스트를 실행하는 도구

> 주어진(given), 때(when), 그리고 나면(then)
일부 개발자가 선호하는 용어. 테스트 철학에 따라 다른 용어를 사용하지만, 코드 맥락에서는 동일한 의미이다.

테스트의 중요성은 너무 자주 언급되어 진부하게 들릴 수 있다. 진부하든 아니든 테스트는 중요하다.
전문적인 소프트웨어 개발 환경에서는단위 테스트가 동반된다.
그리고 '실제 코드'가 보여주는 모든 동작에는 테스트 케이스가 있을 것이라고 예상한다.
이것이 이상적이고 그렇게 되도록 노력해야 한다.

```
너무 뼈때리는 말인데, 이렇게 중요한 걸 왜 안하는 걸까?
```

기존 코드의 일부가 이러한 이상이나 기대에 부응하지 못하고 테스트가 부실한 코드베이스를 발견할 수 있다.
하지만 그렇다고 해서 이상에서 벗어나 우리 자신의 기준을 낮추기 위한 변명이 돼서는 안 된다.
나쁘거나 부적절하게 테스트된 코드는 언젠가 사고가 날 수밖에 없다.
소프트웨어 개발자라면 대부분 형편없는 테스트로 인해 겪었던 몇 가지 공포스러운 경험담을 말할 수 있을 것이다.

형편없는 테스트 중에 명백한 경우는 테스트가 아예 존재하지 않는 경우지만, 유일한 경우는 아니다.
훌륭한 테스트를 하기 위해서는 좋은 테스트가 필요하다.

```
계속 여러 군데 뼈를 맞아서 너무 아프다.
특히 자신의 기준을 낮추기 위한 변명이 되면 안된다는 부분에서 진짜 깊이 반성해야 한다고 본다
'시간이 없다', '할 줄 모른다', '안해도 여태까지 잘 했다', '왜 해야 하는지 잘 모르겠다' 등등은 모두 
자신의 기준을 낮추기 위한 변명으로 생각해 보기로 하자
```

### 10.2 좋은 단위 테스트는 어떻게 작성할 수 있는가?

단위 테스트에서 문제가 발생하면 유지 관리가 매우 어렵고, 버그가 테스트 코드에서 발견되지 못하고 배포한 뒤에 발생할 수도 있다.
그러므로 어떻게 해야 좋은 단위 테스트가 되는지 생각해보는 것이 중요하다.

좋은 단위 테스트를 위한 5가지 주요 기능을 정의한다.

- 훼손의 정확한 감지: 코드가 훼손되면 테스트가 실패한다.
- 세부 구현 사항에 독립적: 세부 구현 사항을 변경하더라도 테스트 코드는 변경하지 않는 것이 이상적이다.
- 잘 설명되는 실패: 코드가 잘못되면 테스트는 실패의 원인과 문제점을 명확하게 설명해야 한다.
- 이해할 수 있는 테스트 코드: 정확히 무엇을 테스트하는 것이고, 어떻게 수행되는지 이해할 수 있어야 한다.
- 쉽고 빠르게 실행: 작업 중 자주 실행되어야 하므로, 느리거나 실행이 어려우면 개발 시간이 낭비된다. 

#### 10.2.1 훼손의 정확한 감지

테스트 중인 코드가 훼손되면 컴파일 되지 않거나 테스트가 실패해야 하는데
이것은 매우 중요한 두 가지 역할을 수행한다.

- 코드에 대한 초기 신뢰를 준다.
  - 새로운 코드, 변경되는 코드와 함께 테스트 코드를 작성하면, 코드베이스로 병합되기 전에 이러한 실수를 발견하고 수정할 수 있다.
- 미래의 훼손을 막아준다.
   - 다른 개발자가 코드를 변경하는 과정에서 실수로 코드를 훼손할 수 있는데, 이걸 방어할 수 있는 효과적인 방법으로 컴파일 실패 혹은 테스트 실패를 하는 것이다.
   - 코드 변경으로 기능이 작동하지 않는 것을 회귀regression라고 한다.
   - 회귀를 탐지할 목적으로 테스트를 실행하는 것을 회귀 테스트regression test라고 한다.

'코드가 훼손되면 반드시 실패한다'는 것이 반드시
'코드가 훼손될 때만 테스트가 실패한다'는 것을 의미하지 않는다.

테스트가 때로는 통과하고 때로는 실패하는 테스트를 플래키flakey라고 한다.
무작위성, 타이밍 기반 레이스timing-based race 조건, 외부 시스템에 의존하는 등의 테스트의 비결정적indeterministic 동작에 기인한다.
플래키 테스트의 단점은 아무것도 아닌 것으로 판명 날 실패의 원인을 찾느라 시간 낭비하는 것이다.
이건 보기보다 훨씬 더 위험한데, 계속해서 테스트가 실패하면 경고를 무시하고 더 나가서 테스트를 비활성화 할 수도 있기 때문이다.
아무도 테스트 실패에 주의를 기울이지 않는다면 테스트가 없는 상황과 다를 바 없다.
그렇게 되면 앞으로 일어날 훼손으로 부터 보호되지 못하고, 버그가 유입될 가능성이 커진다.

코드에서 코드가 훼손된 경우에만 테스트가 실패하도록 하는 것은 매우 중요하다.

#### 10.2.2 세부 구현 사항에 대한 독립적

코드베이스에 대한 변경은 두 가지 종류가 있다.

- 기능적 변화: 외부로 보이는 동작을 수정하는 것으로 새로운 기능 추가, 버그 수정, 에러 처리 등이 있다.
- 리팩터링refactoring: 코드의 구조적 변화를 의미한다. 리팩터링이 되도 이론적으로는 코드의 외부에서 보이는 동작(또는 기능적 속성)이 변경되면 안 된다.

기능적 변경은 코드를 수정하므로 테스트도 수정해야 할 것으로 기대한다.
리팩터링의 경우에는 코드를 사용하는 사람에게 영향을 미치지 않아야 한다. 하지만 리팩터링이라고 하더라도 코드를 수정하는 것은 위험한 일이므로 실수로 코드의 동작을 변경하지 않았다는 것을 알 수 있어야 한다.

단위 테스트 접근 방식 A, B를 살펴본다.

- 접근 방식 A: 테스트는 코드의 모든 동작을 확인할 뿐만 아니라 다양한 구현 세부 사항도 확인한다.
- 접근 방식 B: 동작만 테스트할 뿐 구현 세부 사항은 확인하지 않는다.

몇 달 후에 코드를 리팩터링 해 보면 어떻게 될지 생각해보자.

- 접근 방식 A: 리팩터링과 관계없이 테스트가 실패하기 시작한다.
- 접근 방식 B: 리팩터링을 올바르게 했다면 테스트 코드를 수정할 필요 없이 테스트는 여전히 통과할 것이다.

접근 방식 A 에서는 리팩터링을 해도 코드의 동작을 바꾸는 실수를 하지 않았다는 확신을 하기가 어렵다.
접근 방식 B 에서는 테스트가 여전히 통과된다면 리팩터링이 잘 된 것이라고 확신을 갖기가 쉽다.

> 기능 변경과 리팩터링을 같이 하지 말라
두 가지 작업을 동시에 하는 건 좋지 않다.
동시에 하면 기능적 변화와 리팩터링의 실수 중 어떤 것이 나중에 문제가 되는지 구분하기 어려울 수 있다.
보통 리팩터링을 한 다음 기능 변경을 따로 하는 것이 좋다.

테스트가 구현 세부 정보에 의존하지 않으면 코드 리팩터링에 실수가 있었는지 확인해주는 테스트 결과를 신뢰할 수 있다.

#### 10.2.3 잘 설명되는 실패

테스트가 코드에서 동작하지 않는 부분을 명확하고 정확하게 설명하려면 문제가 발생했을 때 어떤 실패 메시지를 만들어낼지, 그리고 이것이 다른 개발자에게 유용할지 생각해볼 필요가 있다.

단지 잘못됐다고만 알려주는 테스트보다 무엇이 잘못되었는지 명확하게 설명하는 테스트 실패가 훨씬 더 유용하다.

하나의 테스트 케이스에 한 가지 사항만 검사하고 각 테스트 케이스에 대해 서술적인 이름을 사용하면
각각의 특정 동작을 확인하기 위한 작은 테스트 케이스가 많이 만들어진다.
작은 테스트 케이스에서 실패할 때 실패한 케이스의 이름을 확인하면 어떤 동작이 작동하지 않는지 정확하게 알 수 있다.

#### 10.2.4 이해 가능한 테스트 코드

테스트가 실패했을 때
코드가 다른 방식으로 동작한다는 것을 의미하는지
실제로 코드가 작동하지 않는 것인지는 상황에 따라 다르다.

변경한 사항이 원하는 동작에만 영향을 미친다는 확신을 가지려면 테스트의 어느 부분에 영향을 미치고 있는지,
테스트 코드에 대한 수정이 필요한지 여부를 알 수 있어야 한다.
그럴려면 테스트 케이스가 무엇을 테스트 하는지 그리고 어떻게 테스트하는지 이해하고 있어야 한다.

테스트 코드를 이해하기 쉽게 만들기 위해 노력해야 하는 또 다른 이유는 
다른 개발자를 위해 테스트 코드를 사용 설명서로 사용할 수 있기 때문이다.
특정 코드를 어떻게 사용하는지, 어떤 기능을 제공하는지 궁금하면 단위 테스트를 보는 게 좋은 방법이다.

#### 10.2.5 쉽고 빠른 실행

코드베이스 병합 전 뿐만 아니라 개발하면서도 단위 테스트를 수없이 많이 실행하기 때문에
테스트 속도가 느리면 개발자의 작업 속도를 느리게 만든다.
테스트가 느리면 테스트 코드를 작성하는 작업이 힘든 작업이 되고, 그러면 하고 싶지 않은 마음이 든다.
테스트를 쉽고 빠르게 실행할 수 있으면 효율적으로 작업할 수 있고, 테스트도 더 광범위하고 철저하게 할 수 있다.

### 10.3 퍼블릭 API에 집중하되 중요한 동작은 무시하지 말라

퍼블릭 API에 초점을 맞추면 세부 사항이 아닌 동작에 집중할 수 밖에 없게 되는데,
세부 사항은 목적을 이루기 위한 수단일 뿐이다.
이렇게 하면 중요한 것만 테스트 하는데 도움이 되며, 구현 세부 사항에 상관없이 테스트를 수행할 수 있다.

#### 10.3.1 중요한 동작이 퍼블릭 API 외부에 있을 수 있다

테스트 대상 코드는 수 많은 다른 코드에 의존하는 경우가 많은데
그 의존 코드로부터 외부 입력이 제공되거나 부수 효과를 일으킨다면 테스트의 의미가 미세하게 달라질 수 있다.

이렇게 되면 '퍼블릭 API'가 의미하는 바가 주관적이 되고,
개발자들이 중요한 동작을 테스트하지 않고 방치하는 것을 정당화하기 위해 '공용 API만을 이용한 테스트'를 언급하게 된다.

구현 세부 사항implementation detail의 정의는 어떤 것이 세부 사항인지 맥락에 따라 달라진다.
테스트에 관해서는 퍼블릭 API로 제공되지 않는 것 중에서도 테스트 코드가 알아야 할 다른 사항들이 있을 수 있다. 

**커피 자동판매기 예제**

퍼블릭 API에 대해 '커피를 사는 고객이 기계와 상호작용할 것으로 기대되는 방식'으로 정의할 수 있다.
그러면 퍼블릭 API는
신용카드 리더기 기능
커피 선택 기능
선택한 커피를 컵에 제공하는 기능
이 있고 그 외에
신용 카드 거부나 기계가 작동하지 않을 때를 생각해 볼 수 있다.

엄밀히 따지면 퍼블릭 API 이상의 것을 테스트해야 하는 것을 고려해볼 수 있다.
의존성 문제로 전원 연결, 물탱크에 물 채우기, 커피콩 담기가 완료되지 않으면 퍼블릭 API 테스트 시작이 불가능하다.
고객 입장에서는 구현 세부 사항이지만, 테스터 입장에서는 이걸 설정하지 않고 테스트할 방법이 없다.

또, 퍼블릭 API가 아닌데도 테스트 해야 하는 것이 있을 수 있는데
스마트 자판기라고 했을 때 물이나 커피콩이 떨어지면 인터넷 연결을 통해 알림을 주는 기능이 있다면
역시 고객 입장에서는 몰라도 되는 세부 사항이지만, 자판기 동작에 필요하므로 테스트할 필요가 있다.

고객과 테스터 외에도 커피 감별사라면 물을 데우는 방식에 있어 열전차단기thermoblock을 사용하는지 보일러를 사용하는지에 따라 물을 데우는 방법을 달리 할 수 있다면 테스트할 필요가 있다.

**이메일 주소 조회 기능**

user id를 통해 lookupEmailAddress() 함수를 호출하고 이메일 주소를 반환 받는 퍼블릭 API가 있다면
내부에 ServerEndPoint 클래스에 의존해서 이메일 주소를 캐시에 저장하는 일은 세부 사항이 된다.

가능하면 퍼블릭 API를 사용하여 코드의 동작을 테스트해야 하지만
퍼블릭 API를 어떻게 정의하느냐에 따라 모든 동작을 테스트 할 수 없는 경우가 있다.
의존성 설정, 특정 부수효과 발생 여부를 통해 알 수 있고, 몇 가지 예는 아래와 같다.

- 서버와 상호작용하는 코드: 서버 설정, 시뮬레이션 필요. 또 얼마나 자주 호출하는지, 유효한 호출 형식인지에 따라 어떤 부수 효과가 있는지 확인이 필요할 수 있다.
- 데이터베이스에 값을 저장하거나 읽는 코드: 데이터베이스에 저장된 여러 다른 값으로 코드를 테스트해야 할 경우가 있다. 부수 효과로 데이터베이스에 어떤 값을 저장한다면 그 값을 확인해야 할 수도 있다.

'퍼블릭 API만을 이용해 테스트하라'와 '실행 세부 사항을 테스트하지 말라'는 둘 다 훌륭한 조언이지만, 테스트를 어떻게 할지 안내하는 원칙일 뿐이다.

'퍼블릭 API'와 '구현 세부 사항'의 정의는 주관적이고 상황에 따라 달라질 수 있다는 점을 알아야 한다.

궁극적으로 중요한 것은 코드의 모든 중요한 동작을 제대로 테스트하는 것이고,
퍼블릭 API라고 생각하는 것만으로는 테스트를 할 수 없는 경우가 있다.

테스트는 구현 세부 사항에 최대한 독립적으로 수행하도록 해야 하므로
다른 대안이 없는 경우에만 퍼블릭 API를 벗어나 테스트해야 한다.

### 10.4 테스트 더블

의존성을 실제로 사용하는 것에 대한 대안으로 테스트 더블test double이 있다.
의존성을 시뮬레이션 하는 객체이면서 테스트에 더 적합하게 사용할 수 있게 만든다.

#### 10.4.1 테스트 더블을 사용하는 이유

- 테스트 단순화: 테스트하기 까다롭고 힘든 의존성이 있는 경우
- 테스트로부터 외부 세계 보호: 실제로 부수 효과가 일어나는 의존성의 경우
- 외부로부터 테스트 보호: 외부 세계는 의존성 코드가 다른 데이터베이스에 있고 시간이 지나면 변경될 수 있는 경우

##### 테스트 단순화

테스트 더블을 사용하면 실제로 의존성을 설정하거나 하위 종속성에서 무언가를 검증할 필요가 없다.
테스트 코드는 테스트 더블과만 상호작용하면 설정과 부수 효과 검증을 할 수 있다.

의존성 코드에서 계산 시간이 드는 작업이나 설정이 있다면 테스트 더블을 통해 테스트를 더 빠르게 실행하는 것이다.

하지만 사례별로 테스트 더블을 사용 여부를 고려해야 하는데
테스트 더블을 설정하는 것이 의존성을 실제로 사용하는 것보다 더 복잡할 때가 있기 때문이다.

##### 테스트로부터 외부 세계 보호

어쩔 수 없이 격리된 상태로 테스트해야 하는 경우가 있는데
고객의 은행계좌에서 돈을 인출하는 테스트 코드가 그렇다. 실제로 돈이 인출되면 안되기 때문이다.

이것은 테스트로부터 외부 세계를 보호해야 하는 (극단적인) 예이다.

실제 서버로 요청을 전송하거나 실제 데이터베이스에 값을 쓰는 부수 효과를 유발하는 테스트는 다음과 같은 문제가 발생할 수 있다.

- 사용자는 이상하고 혼란스러운 값을 볼 수 있다.
- 모니터링 및 로깅에 영향을 미칠 수 있다.

비즈니스에 중요한 시스템은 테스트가 부수 효과를 일으키지 않는 것이 중요하다.
이런 시스템은 테스트로부터 보호되어야 하며 테스트 더블은 테스트를 격리함으로써 이것을 효과적으로 수행한다.

##### 외부로부터 테스트 보호

데이터베이스에서 정기적으로 변경되는 값을 읽거나 난수를 생성해서 ID를 만드는 것은 실제 의존성이 있을 수 있다.
이런 의존성을 테스트에 사용하면 테스트 결과를 신뢰하기 어려울 때가 있다.

계좌 잔액은 계좌 주인에 의해 수시로 변동되므로 테스트 코드가 실제 은행 계좌를 사용해 잔액을 읽게 되면 테스트가 엉망이 될 수 있다.

테스트를 실제 은행 시스템과 분리 시키고 테스트 더블을 통해 수행하게 한다.

테스트 더블을 사용하는 것이 낫겠다고 판단하면 목, 스텁, 페이크 중 어떤 걸 사용할지 결정해야 한다.

#### 10.4.2 목(mock)

목mock은 클래스나 인터페이스를 시뮬레이션하는 데 멤버 함수에 대한 호출을 기록하는 것 외에는 어떠한 일도 수행하지 않는다.
함수가 호출될 때 인수에 제공되는 값을 기록한다.
테스트 대상 코드가 의존성을 통해 제공되는 함수를 호출하는지 검증하기 위해 목을 사용할 수 있다.
따라서 목은 테스트 대상 코드에서 부수 효과를 일으키는 의존성을 시뮬레이션하는 데 가장 유용하다.

목은 테스트로부터 외부 세계를 보호할 수 있지만, 비현실적이고 중요한 버그를 잡지 못할 위험이 있다.

#### 10.4.3 스텁(Stub)

스텁stub은 함수가 호출되면미리 정해 놓은 값을 반환함으로써 함수를 시뮬레이션 한다.
테스트 대상 코드는 특정 멤버 함수를 호출하고 특정 값을 반환하도록 의존성을 시뮬레이션 할 수 있다.
그러므로 스텁은 테스트 대상 코드가 의존하는 코드로부터 어떤 값을 받아야 하는 경우 그 의존성을 시뮬레이션하는 데 유용하다.

개발자들이 일반적으로 목이라고 말할 때는 목과 스텁 둘 다 지칭한다.
JUnit의 mockito 같은 경우는 목 객체를 만들면 목과 스텁 둘다 생성하므로 스텁만 쓰고 싶어도 목을 만들어야 한다.

테스트 대상 코드가 실제 은행계좌의 잔액을 읽으면 자주 변경 되는 값을 읽는 것이므로 테스트가 비결정적이 되서 신뢰하기 어렵게 된다.
외부로부터 테스트를 보호해야 하는 상황으로 잔액을 얻는 BankAccount.getBalance() 함수에 스텁을 사용한다.
함수가 호출될 때마다 미리 정해진 값을 반환하도록 설정해 두면 테스트가 결정적deterministic이 되고 결과를 신뢰할 수 있다.

#### 10.4.4 목과 스텁은 문제가 될 수 있다

목과 스텁을 사용할 때 두 가지 주요 단점은 다음과 같다.

- 목이나 스텁이 실제 의존성과 다른 방식으로 동작하도록 설정되면 테스트는 실제적이지 않다.
- 구현 세부 사항과 테스트가 밀접하게 결합하여 리팩터링이 어려워질 수 있다.

##### 목과 스텁은 실제적이지 않은 테스트를 만들 수 있다.

개발자는 테스트 코드를 위해 목이나 스텁이 어떻게 동작할지 결정해야 한다.
그렇게 되면 실제와 다르게 동작하도록 할 수 있으므로 위험할 수 있다.
테스트가 통과되고 잘 작동한다고 착각하게 되고 실제 코드가 실행될 때 부정확하게 동작하거나 버그가 발생할 수 있다.

실제 세계에서는 일어나지 않는 방법으로 음수값으로 계좌에서 인출하면 계좌에 돈이 추가될 것이라고 암묵적인 가정을 한다.
실제 세계에서는 0보다 적은 금액으로 인출될 경우 예외를 발생시키는데, 이걸 묵인하고 목을 작성해서 테스트를 통과시키는 건 적절하지 않다.
즉 버그가 있다는 것이 명확하지만 테스트 코드와 목을 통해서는 버그가 드러나지 않는다는게 문제가 된다.
이것이 목의 주요 단점 중 하나이다.

테스트 코드를 작성하는 개발자는 목이 어떻게 동작할지 결정하게 되는데,
실제 의존성이 어떻게 동작하는지 이해하지 못하면 목을 설정할 때 실수를 할 가능성이 크다.

스텁 역시 의존성 코드가 특정 값을 반환할 때 테스트 코드가 동작하는지만 테스트한다.
하지만 그 값이 의존성 코드가 실제로 반환하는 값인지에 대해서는 검증을 하지 않는다.
BankAccount.getBalance() 함수가 정확한 잔액을 반환하는게 아니라 10의 배수로만 반환하는 정책이
주석이나 문서에 적혀 있다면 스텁을 구성할 때 간과해서 구성한 것이 된다.

##### 목과 스텁을 사용하면 테스트가 구현 세부 정보에 유착될 수 있다

목과 스텁에 구현 세부 정보를 확인하는 테스트 코드가 있을 때
리팩터링이 진행되서 구현 세부사항이 변경이 된다면 테스트가 실패하는 경우가 발생한다.
테스트는 구현 세부사항에 구애받지 않아야 하는데, 리팩터링을 한 개발자는 테스트 통과를 위해 테스트 케이스를 수정해야 하는 일이 발생하므로 리팩터링이 의도치 않게 동작을 변경하지 않았다는 확신을 하기 어렵다.

목과 스텁은 최소한으로 사용하는 것이 최선이다.
대안이 없다면 목이나 스텁을 테스트에 사용하는 것이 아예 테스트 코드를 작성하지 않는 것 보다는 낫다.
하지만 실제 의존성을 사용할 수 있거나 페이크를 사용하는 것이 가능하다면 그게 더 바람직하다.

#### 10.4.5 페이크(fake)

페이크fake는 클래스(또는 인터페이스)의 대체 구현체로 테스트에서 안전하게 사용할 수 있다.
페이크는 실제 의존성의 공개 API를 정확하게 시뮬레이션 하지만 구현은 단순한데,
외부 시스템과 통신하는 대신 페이크 내의 멤버 변수에 상태를 저장한다.

페이크의 요점은 코드 계약이 실제 의존성과 동일하기 때문에 실제 클래스나 인터페이스가 특정 입력을 받아들이지 않는다면 페이크도 마찬가지로 동작한다.
즉, 실제 의존성에 대한 코드 계약이 변경되면 페이크의 코드 계약도 동일하게 변경이 일어난다.

BankAccount 인터페이스를 구현하는 FakeBankAccount는 테스트 중에 BankAccount의 구현 클래스가 필요한 모든 코드에 사용할 수 있다.
debit()이나 credit() 함수가 마이너스 금액으로 호출되는 경우 ArgumentExcpetion 예외를 발생시켜서 코드 계약이 강제로 시행되고 페이크 객체가 실제 구현과 같은 방식으로 동작하게 한다.
getBalance() 함수 역시 코드 계약에 명시되어 있는 대로 10의 배수로 반내림한 잔액을 반환한다.

##### 페이크로 인해 보다 실질적인 테스트가 이루어질 수 있다.

코드에 버그가 있으면 테스트가 실패하고 코드에 버그가 있다는 것을 인지하는게 중요하다.
페이크는 이 일을 해주고 테스트 케이스를 실패하게 해 주므로 유용하다.

##### 페이크를 사용하면 구현 세부 정보로부터 테스트를 분리할 수 있다.

테스트가 페이크를 사용하는 경우 구현 세부 사항 대신 최종 결과가 정확한지 확인한다.
테스트는 구현 세부 사항과 관련해서 독립적으로 작성할 수 있고, 리팩터링이 동작을 변경하지 않는 한 테스트는 실패하지 않는다.

자신의 팀이 특정 클래스나 인터페이스에 대한 코드를 관리하고 있고
실제 코드를 테스트에 사용하는 것이 적합하지 않다면 페이크를 구현하는 것이 좋다.
그러면 테스트는 더 나아지고 코드에 의존하는 수많은 다른 개발자들에게도 도움이 될 것이다.

#### 10.4.6 목에 대한 의견

- 목 찬성론자mockist: 런던 학파. 단위 테스트 코드에서 의존성을 실제로 사용하는 것을 피해야 한다.
- 고전주의자classicist: 디트로이트 학파. 테스트에서 의존성을 실제로 사용하는 것을 최우선으로 하고, 목과 스텁은 최소한으로 사용해야 한다.

목 접근법은 상호작용을 테스트 하는 것으로 시험 대상 코드가 `어떻게` 하는가를 확인하는 반면
고전주의 접근법은 코드의 결과 상태와 의존성을 테스트 하는 것으로 코드를 실행하는 최종 결과가 `무엇인지` 확인하는 경향이 있다. (이것이 어떻게 달성되는지는 크게 상관하지 않는다)

목 사용을 지지하는 주장

- 단위 테스트가 더욱 격리된다. 특정 코드에 문제가 생기면 그 코드의 단위 테스트만 실패가 되며, 이 코드에 의존하는 다른 코드에 대한 테스트는 실패하지 않는다
- 테스트 코드 작성이 더 쉬워진다. 의존성을 설정할 필요가 없고 하위 종속성 설정에 대해서도 걱정하지 않아도 되므로 테스트에 필요한 설정이 간단하다.

고전주의적 접근법에 찬성하고 목 접근법에 반대하는 주장은 다음과 같다.

- 목은 코드가 특정 호출을 하는지만 확인할 뿐 실제로 호출이 유효한지는 검증하지 않는다. 코드에 문제가 있어도 테스트는 통과할 수 있다.
- 구현 세부 사항에 대해 더 독립적인 테스트를 할 수 있다. 테스트 대상 코드의 동작이 변경되었을 때에만 실패하며, 구현 세부 사항이 변경될 때는 실패하지 않는다.

필자(톰 롱)의 접근법은 목이었는데 테스트 코드 작성을 쉽게 만드는 것처럼 보였기 때문이다.
지금은 동작을 제대로 테스트하지 않고 코드 리팩터링을 어렵게 만드는 이유로 목 테스트는 하지 않는다.

필자 개인의 의견과 달리 모든 개발자는 이에 동의하지 않을 수 있다는 점은 참고해야 한다.
마틴 파울러의 기사 후반부에 이 주제에 대해 논의하고 있으므로 참고할만 하다.
https://martinfowler.com/articles/mocksArentStubs.html#ClassicalAndMockistTesting

```
마틴 파울러의 글에서 디트로이트와 런던 학파가 어떻게 생기게 됐는지에 대한 짧은 설명이 있다.
You sometimes see "Detroit" style used for "classical" and "London" for "mockist". This alludes to the fact that XP was originally developed with the C3 project in Detroit and the mockist style was developed by early XP adopters in London.
```

### 10.5 테스트 철학으로부터 신중하게 선택하라

현실은 다르고, 옳다고 생각하는 바를 여러 철학에서 신중하게 선택할 자유가 있다.
테스트 철학의 한 예로 테스트 주도 개발test-driven development, TDD가 있다.
코드를 구현하기 전에 테스트 코드를 먼저 작성해야 한다는 점이 포인트인데
많은 개발자들이 이론적인 이점은 인식하고 있지만 실제로 이렇게 하는 개발자가 많이 없는데,
TDD가 어떻게 할지에 대한 철학이 아니기 때문에 그렇다.

TDD를 철저하게 따르지 않는다고 해서, 그 철학을 완전히 무시하는 것은 아니다. 완전히 동의하지 않는다고 보는 게 맞다.
많은 개발자들은 TDD를 꼭 따르지 않더라도 여전히 테스트를 격리시키고, 집중하며, 구현 세부 사항을 테스트 하지 않는 등 TDD가 규정하는 많은 것들을 달성하려고 한다.

테스트 철학과 방법론의 몇 가지 예는 아래와 같다.

- 테스트 주도 개발test-driven development, TDD: 실제 코드는 테스트만 통과 하도록 최소한으로 작성하고 이후에 구조 개선 및 중복을 없애는 리팩터링을 한다.
- 행동 주도 개발Behavior-driven development, DBB: 사용자, 고객, 비즈니스의 관점에서 소프트웨어가 보여야 할 행동(또는 기능)을 식별하는데 집중하자는 것이다. 테스트는 소프트웨어 자체의 속성 보다는 원하는 동작을 반영해야 한다.
- 수용 테스트 주도 개발Acceptance test-driven development, ATDD: BDD와 비슷하지만 겹치는 정도가 다르다. 고객 관점에서 소프트웨어가 보여줘야 하는 동작(또는 기능)을 식별하고 소프트웨어가 필요에 따라 작동하는지 검증하는 것을 자동화된 수락 테스트acceptance test를 만드는 것을 수반한다. 이론적으로 테스트가 통과하면 소프트웨어는 완전한 것이고 고객이 수락할 준비가 된 것이다.

테스트 철학 및 방법론은 효과적이라고 생각하는 작업 방식이 있다.
하지만 궁극적으로 달성하고자 하는 목표가 목표를 달성하기 위한 방식보다 더 중요하다.
중요한 것은 고품질의 테스트 코드를 작성하고 고품질의 소프트웨어를 생산하는 것이다.
사람마다 일하는 방식이 다르고, 어떤 철학이나 방법론을 따를 때 가장 효과적으로 일할 수 있다면 좋은 일이다.
하지만 다른 방법으로 할 때 더 효과적이면 그것 역시 전적으로 좋다.

### 요약

- Pretty much every piece of “real code” submitted to the code base should have an accompanying unit test.
- Every behavior that the “real code” exhibits should have an accompanying test case that exercises it and checks the result. For anything other than the simplest of test cases, it’s common to divide the code within each of them into three distinct sections:
arrange, act, and assert.
- The key features of a good unit test are:
  - Accurately detects breakages
  - Agnostic to implementation details
  - Well explained failures
  - Understandable test code
  - Easy and quick to run
- Test doubles can be used in a unit test when it’s infeasible or impractical to use a real dependency. Some examples of test doubles are:
  - Mocks
  - Stubs
  - Fakes
- Mocks and stubs can result in tests that are unrealistic and that are tightly coupled to implementation details
- There are different schools of thought on the usage of mocks and stubs. My personal opinion is that real dependencies should be used in tests where possible. Failing that, a fake is the next best option. And mocks and stubs should be used only as a last resort. 