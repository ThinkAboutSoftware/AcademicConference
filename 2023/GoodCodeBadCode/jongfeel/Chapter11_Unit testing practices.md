## 11장 단위 테스트의 실제

```
논의내용)
좋은 단위 테스트를 만들기 위해서는 조금 노력이 필요한 것 같습니다.
테스트 프레임워크가 해주는 것 외에 테스트 케이스 이름이나 예외 메시지 같은 건 사람의 노력이 들어가야 하니까요.
참고할 만한 좋은 내용이었습니다.

질문이자 고민의 내용은
상태 공유는 데이터베이스 뿐 아니라 로그인 이후 동작에도 많이 썼던 방식이었습니다. 만약 로그인 이후 로그인 정보가 있어야 진행할 수 있는 테스트 케이스는 어떻게 해결해 보는 게 좋을까 고민이 됩니다

전 예전에는 상태 공유로 로그인을 한번 진행하고 그 이후로 토큰 값을 가지고 테스트 코드를 작성했었습니다.
책을 읽으면 그렇게 안하는 방향이 좋다고 느껴지는 데, 로그인이 필요한 테스트 케이스는 메번 로그인을 하는게 좋은 방향이지만 조금 비효율적이지 않나 고민이 또 되는 군요. 
```

좋은 단위 테스트가 가져야 하는 주요 특징 remind

- 코드의 문제를 정확하게 감지한다: 코드에 문제가 있으면 테스트는 실패해야 한다.
- 구현 세부 정보에 구애받지 않는다: 구현 세부 사항을 변경하더라도 테스트 코드는 변경이 필요 없어야 한다.
- 실패는 잘 설명된다: 테스트 실패는 문제에 대한 명확한 설명을 제공해야 한다.
- 테스트 코드가 이해하기 쉽다: 테스트가 무엇이고 어떻게 수행되는지 다른 개발자가 이해할 수 있어야 한다
- 테스트를 쉽고 빠르게 실행할 수 있다: 단위 테스트가 느리거나 실행이 어려운 경우 개발자의 시간이 낭비된다.

### 11.1 기능뿐만 아니라 동작을 시험하라

코드를 테스트하는 것은 할 일 목록을 만들어 작업하는 것과 비슷하다.
성공적인 결과는 실제로 목록에 있는 것들이 얼마나 올바른지에 달려 있다.

함수별로 테스트 케이스를 하나만 작성하면 중요한 동작을 놓칠 수 있다.
단순히 눈에 보이는 대로 함수 이름을 테스트 목록에 넣기 보다는 함수가 수행하는 모든 동작으로 목록을 채우는 것이 좋다.

#### 11.1.1 함수당 하나의 테스트 케이스만 있으면 적절하지 않을 때가 있다

고객이 주택담보대출을 받을 수 있는지와 대출을 할 수 있다면 얼마를 빌릴 수 있는지를 결정하는 로직에서 고려해야 할 것들이 있다.

- access() 함수를 통해 주택담보대출을 받을 자격이 있는지 여부를 판단한다.
  - 신용등급이 좋다.
  - 기존 주택담보대출이 없다.
  - 은행에 의해 금지된 고객이 아니다.
- 자격이 있을 경우 최대 대출 금액을 결정한다. 연간 소득에서 지출을 뺀 값에 10을 곱한 것으로 계산된다.

테스트 케이스를 대출이 되는 경우만 하고 거절될 경우의 케이스를 테스트 하지 않으면 충분한 테스트를 한 것이 아니다.

문제는 테스트를 행동이 아닌 기능 테스트에 집중했다는 점이다.
acces() 함수는 MortgageAssessor 클래스의 퍼블릭 API에 있는 유일한 함수여서 하나의 테스트 케이스만 작성했다.

#### 11.1.2 해결책: 각 동작을 테스트하는 데 집중하라

각각의 동작에 대해 테스트가 되어야 하며, 작성해야 할 테스트 케이스가 훨씬 많다.
다음과 같은 테스트 케이스를 고려해 볼 수 있다.

- 수입과 지출에 대한 여러 가지 다른 값을 사용
- 소득이나 지출이 전혀 없는 경우, 혹은 아주 많은 경우와 같은 일부 극단적 값을 사용하는 경우

테스트 코드의 양이 실제 코드의 양보다 많지 않다면, 모든 동작이 제대로 테스트되고 있지 않음을 나타내는 경고 표시일 수 있다.

테스트를 위해 코드가 보일 행동을 생각해내는 연습을 하는 것은 코드의 잠재적인 문제를 발견하는 좋은 방법이다.
예를 들어 지출이 수입을 초과하는 경우 최대 대출 금액이 마이너스가 될 것이고 이상한 결과이기 때문에 논리를 다시 의논하고 세련되게 처리하는 계기를 만들 수 있다.

##### 모든 동작이 테스트되었는지 거듭 확인하라

코드가 제대로 테스트되는지 특정하기 위한 한 가지 좋은 방법은 수정된 코드에 버그나 오류가 있음에도 여전히 테스트를 통과할 수 있는지에 대해 생각해보는 것이다.
아래 항목 중 하나라도 '예'라면 모든 행동이 테스트되고 있지 못하다는 걸 의미한다.

- 삭제해도 여전히 컴파일되거나 테스트가 통과하는 코드 라인
- if의 논리를 반대로 해도 테스트가 통과
- 논리, 산술 연산자를 다른 것으로 대체해도 테스트가 통과
- 상수나 하드 코딩된 값을 변경해도 테스트가 통과

요점은 테스트 대상 코드의 각 항목이 존재하는 이유가 있어야 한다는 것이다.
불필요하다면 제거되어야 하고
필요하다면 어떻게든 그 코드에 의존하는 중요한 행동이 있다는 것을 의미한다.
기능을 변경했다면 적어도 하나의 케이스가 실패해야 한다.
그렇지 않다면 모든 행동이 테스트되는 것이 아니다.

방어적으로 프로그래밍 오류를 검사하는 코드가 있을 수 있다. (check, assertion)
방어 논리를 테스트하는 방법은 코드를 의도적으로 잘못 수정해서 가정을 깨뜨리는 것이므로 테스트 하는 방법이 없을 수도 있다.

돌연변이 테스트mutation test를 사용하면 기능의 변화가 테스트 실패를 일으키는지 확인하는 걸 자동화할 수 있다.
돌연변이 테스트 도구는 약간 변형된 코드를 만들어 내므로, 코드가 변형된 후에도 테스트가 통과한다면
모든 동작이 제대로 테스트되고 있지 않다는 신호다.

##### 오류 시나리오를 잊지 말라

오류 시나리오가 발생할 때 코드가 어떻게 동작하는가에 대한 것도 테스트가 필요하다.
테스트 케이스에 예외를 발생시키는 코드를 호출하면 예외가 발생하는지 확인하는 것이 필요하고
예외에 예상하는 오류 메시지가 포함되어 있는지 확인한다.

하나의 함수라도 호출되는 값이나 시스템의 상태에 따라 다양한 동작을 나타내는 경우가 많다.
함수당 하나의 테스트 케이스만 작성하는 것으로 테스트가 충분히 되는 경우는 거의 없다.
중요한 모든 행동을 파악하고 각각에 대한 테스트 케이스가 있는지 확인하는 것이 더 효과적이다.

### 11.2 테스트만을 위해 퍼블릭으로 만들지 말라

때로 프라이빗 함수 중 일부를 테스트 코드에서도 접근할 수 있도록 만들어 직접 테스트하는 경우가 있는데 좋은 생각이 아닐 떄가 많다.
구현 세부 사항과 연관된 테스트가 될 수 있고
궁극적으로 우리가 신경 써야 하는 코드의 동작을 테스트하지 않을 수 있다.

#### 11.2.1 프라이빗 함수를 테스트하는 것은 바람직하지 않을 때가 많다

프라이빗 함수를 퍼블릭으로 만든 후에 테스트할 때의 문제는 다음과 같다.

- 이 테스트는 실제로 우리가 신경 쓰는 행동을 테스트하는 것이 아니다.
- 테스트가 구현 세부 사항에 독립적이지 못하게 된다. 프라이빗 함수에 대한 리팩터링이 들어간다면 실패하는 테스트 케이스가 발생할 수 있다.
- 테스트를 위해 퍼블릭으로 변경한 의도만 있지만, 주석으로 해 놓은 부분은 간과되기 쉽기 때문에 이후 다른 개발자가 변경된 퍼블릭 함수를 호출하여 의존성을 구현할 수 있다.

좋은 단위 테스트는 궁극적으로 중요한 행동을 테스트해야 한다.
프라이빗 함수를 테스트 하면 코드의 문제점을 감지할 가능성과 구현 세부 사항에 독립적이어야 한다는 목적에 어긋난다.

#### 11.2.2 해결책: 퍼블릭 API를 통해 테스트하라

프라이빗 함수도 결국 퍼블릭 API를 통해 호출하므로 퍼블릭 API를 통해 프라이빗 함수에 대해 테스트할 수 있는 케이스를 여러개 만들어 테스트 한다.

#### 11.2.3 해결책: 코드를 더 작은 단위로 분할하라

앞선 해결책은 논리가 간단할 때는 괜찮지만, 만약 복잡한 논리를 갖게 되면 다시 프라이빗 함수를 퍼블릭으로 만들어서 테스트하고자 하는 마음이 들 수 있다.

그래서 테스트를 위해 새롭게 퍼블릭 함수를 공개하고 복잡한 논리에 대한 테스트 케이스를 위해 퍼블릭 함수를 추가하는 코드를 작성하면 될 것으로 생각할 수 있는데
이때는 근본적인 문제로 클래스 내에서 하는 일이 많기 때문에 테스트 케이스가 많아지는 것으로 생각하는게 맞다.
즉, 추상화 계층이 너무 비대하기 때문에 퍼블릭 API로 테스트 하는 것이 어려워 보인다.

그래서 코드를 더 작은 계층으로 나누는 것이고
고객 신용 등급이 좋은지 판단하는 논리의 경우 별도의 클래스로 옮기는 작업을 한다.
CreditRatingChecker.isCreditRatingGood() 이라는 퍼블릭 API를 통해 더 쉽게 테스트할 수 있게 한다.

공개된 함수로만 테스트 케이스를 만드는 것이 어렵다면
하위 문제를 해결하는 더 작은 클래스로의 분할을 고려해 봐야 한다.

### 11.3 한 번에 하나의 동작만 테스트하라

때로 하나의 시나리오로 여러 동작을 테스트하도록 만드는 방법이 있는데, 가능하다고 해서 다 좋은 것은 아니다.

#### 11.3.1 여러 동작을 한꺼번에 테스트하면 테스트가 제대로 안 될 수 있다

유효한 쿠폰만 추려내는 함수 getValidCoupons() 는 몇 가지 동작을 수행한다

- 유효한 쿠폰만 반환
- 사용한 쿠폰은 유효하지 않음
- 유효기간이 지난 쿠폰은 유효하지 않음
- 다른 고객에게 발행한 쿠폰은 유효하지 않음
- 내림 차순 정렬

테스트 케이스 하나만 작성하고 이 안에서 함수의 모든 동작을 한 번에 테스트한다면
테스트 코드가 너무 길어 파악하기 어렵고, 모든 행동을 테스트 하면 이해하기 어려워진다.

테스트 케이스가 모든 동작을 테스트하게 되면 실패했을 때 어떤 동작에 문제가 있는지
테스트 케이스 이름만 보고 알 수 없을 뿐 아니라 실제 메시지로 부터 어떤 문제가 있는지 이해하기도 어렵다.

모든 것을 한꺼번에 테스트하는 테스트 케이스는 무엇이 변경됐는지 알려주는 대신, 무언가 변경됐다는 것만 알려준다.
코드가 변경 되면 어떤 동작이 영향을 받았고 어떤 동작이 영향을 받지 않았는지 정확히 알기 어렵다.

#### 11.3.2 해결책: 각 동작은 자체 테스트 케이스에서 테스트하라

잘 명명된 테스트 케이스를 사용하여 각 동작을 개별적으로 테스트 한다.
개별적으로 테스트 할 때 테스트 케이스에 적절한 이름을 사용하면 테스트가 실패할 경우 어떤 동작이 실패했는지 잘 알 수 있다.

예) testGEtValidCoupons_alreadyRedeemed_excluded failed:
테스트 케이스의 이름을 통해 실패했을 때 테스트 케이스 이름과 실패 메시지를 통해 어떤 문제인지 이해하기 쉽다.

#### 11.3.3 매개변수를 사용한 테스트

테스트 프레임워크에서 매개변수를 사용해 테스트할 수 있는 기능을 제공하면
이를 통해 테스트 케이스 함수는 한 번 작성해 두고 매개변수에 다른 값을 설정해서 여러 시나리오를 테스트할 수 있다.

> 실패가 잘 설명되도록 하라
매개변수를 사용해 테스트 케이스를 작성할 때 각 매개변수 세트에 이름을 추가하는 것은 일반적으로 선택 사항이다.
실패시에 메시지가 어떻게 보일지 생각해 보고 생략 여부는 생각해 보는 것이 좋다. 

각 언어별 테스트 프레임워크에서 매개변수 지원

- C# NUnit으로 TestCase 속성 제공
- Java JUnit은 매개변수 테스트를 지원한다
- JavaScript Jasmine은 매개변수를 사용한 테스트를 맞춤형 방식으로 쉽게 작성할 수 있다.

### 11.4 공유 설정을 적절하게 사용하라

의존성 설정, 테스트 데이터 저장소에 값 세팅, 다른 종류의 상태 초기화 등 어느 정도 설정이 필요할 때가 있다.
테스트 프레임워크에서는 테스트 케이스 간에 설정을 쉽게 공유할 수 있는 기능을 제공한다.

- BeforeAll: 테스트 케이스가 실행되기 전에 `단 한 번` 실행된다. 일부 테스트 프레임워크에서는 OnTimeSetUp이라고 한다.
- BeforeEach: 테스트 케이스가 실행되기 전에 `매번` 실행된다. 일부 테스트 프레임워크에서는 SetUp이라고 한다.
- AfterAll: 테스트 케이스가 실행된 후 `한 번` 실행된다. 일부 테스트 프레임워크에서는 OneTimeTearDown이라고 한다.
- AfterEach: 테스트 케이스가 실행된 후 `매번` 실행된다. 일부 테스트 프레임워크에서는 TearDown이라고 한다.

```
Java와 C#에서 쓰는 방법으로 Before, After는 Java 문법, Setup, TearDown은 C# 문법이다.
```

이것은 두 가지 중요한 방식으로 일어날 수 있다.

- 상태 공유sharing state: BeforeAll을 통해 모든 테스트 케이슨 전에 한번 실행된다. 설정된 모든 상태가 모든 테스트 케이스 간에 공유되므로 설정 시간에 오래 걸리거나 비용이 많이 드는 서버 시작이나 데이터베이스 인스턴스 생성 같은 경우에 유용하다. 하지만 설정 상태가 가변적인 경우는 다른 테스트 케이스에 영향을 미칠 수 있는 위험이 있다.
- 설정 공유sharing configuration: BeforeEach를 통해 각 테스트 케이스가 실행되기 전에 실행된다. 설정 코드가 특정 값을 포함하거나 특정 방식으로 의존성을 설정하는 경우에 사용한다. 테스트 케이스 전에 실행되므로 테스트 케이스 간에 공유 상태는 없지만, 나중에 문제가 될 수 있다.

테스트 설정을 공유하는 것은 양날의 검이 될 수 있다.
잘못된 방법으로 테스트 설정을 공유하면 테스트가 취약하고 효과적이지 못할 수 있다.

#### 11.4.1 상태 공유는 문제가 될 수 있다

테스트 케이스는 서로 격리되서 실행되므로 한 테스트 케이스가 수행하는 모든 조치는 다른 테스트 케이스의 결과에 영향을 미치지 않아야 한다.
테스트 케이스 간에 상태를 공유하고 이 상태가 가변적이면 이 규칙을 실수로 위반하기 쉽다.

데이터베이스의 인스턴스를 생성하는 것은 리소스가 많이 들고 속도가 느리므로 BeforeAll 블록에서 인스턴스를 생성한다.
동일한 데이터베이스 인스턴스가 모든 테스트 케이스 간에 공유되고, 이것은 상태가 공유된다는 것을 의미한다.
이로 인해 테스트는 효과적이지 못하게 된다.

#### 11.4.2 해결책: 상태를 공유하지 않거나 초기화하라

가변적인 상태를 공유하는 데서 오는 문제점을 해결하기 위한 가장 분명한 방법은 애초에 공유하지 않는 것이다.
데이터베이스 생성이  생각보다 느리지 않다면, 각 테스트 케이스 내에서 새 인스턴스를 생성하는 것도 고려해볼 수 있다.

다른 방법으로 테스트 더블을 사용하는 것이다.
FakeDatabase 인스턴스를 만드는 것은 빠르기 때문에 각 테스트 케이스에 대해 새로운 인스턴스 생성을 할 수 있고
이는 곧 공유되는 상태가 없다는 것을 의미한다.

위 두 케이스를 사용할 수 없는 경우에는 테스트 케이스 간에 반드시 데이터베이스 상태가 초기화되도록 많은 주의를 기울여야 한다.

> 전역 상태
테스트 대상 코드가 전역 상태를 유지한다면 테스트 케이스마다 전역 상태를 확실하게 초기화해야 한다.
전역 상태가 코드의 테스트 용이성에 영향을 미친다.

```
뇌피셜이지만 싱글톤 돌려까기 같은 느낌이 강하다.
```

#### 11.4.3 설정 공유는 문제가 될 수 있다

주문 처리 예에서 소포에 대한 우편 요금 라벨을 생성하는 시스템.

공유되는 설정 값에서 주문 생성, 주문 고객 생성, 주문 고객의 주소 생성, 주문 고객의 박스 생성 3개를 BeforeEach로 설정
이 값을 testOrder라는 값으로 테스트 케이스 설정 공유를 해 두면
테스트 케이스는 이 값에 의존해서 작성하게 되고 박스 3개에 대한 테스트 케이스를 작성하게 된다.

나중에 우편 라벨에 위험물 표시가 있는 걸 추가해 둔다면, 테스트 케이스 역시 추가해야 한다.
여기서 기존 testOrder에 있던 박스 3개에 추가로 위험물 박스 하나를 추가하게 된다면
기존 박스 3개에 대한 테스트 코드는 문제가 발생하게 된다.

> 테스트 상수 공유
테스트 상수를 클래스 내에 상수로 설정해 두면 문제는 여전히 발생할 가능성이 있다
테스트 간에 상수를 공유하는 방법이지만 불변으로 상수를 생성하는게 바람직하고 가변적인 상태는 공유되지 않아야 한다는 것을 의미한다.

설정을 공유하면 어떤 테스트 케이스가 어떤 특정 항목에 의존하는지 추적하는 것이 어려우며,
향후 변경 사항이 발생하면 테스트 케이스가 원래 목적했던 동작을 더 이상 테스트하지 않게 될 수 있다.

#### 11.4.4 해결책: 중요한 설정은 테스트 케이스 내에서 정의하라

테스트 케이스가 특정 값이나 설정 상태에 의존한다면 그렇게 하는 것이 더 안전한 경우가 많다.
헬퍼 함수를 사용해 이 작업을 쉽게 할 수 있기 때문에 코드를 반복하지 않아도 된다.

테스트 케이스의 결과가 설정값에 직접 영향을 받는 경우 해당 테스트 케이스 내에서 설정하는 것이 가장 좋다.
향후의 코드 변경으로 인해 의도치 않게 테스트 코드에 문제가 발생하는 것을 막을 수 있다.
테스트 케이스에 영향을 미치는 설정이 테스트 케이스 내에 있으므로 원인과 결과가 명확해진다. 

#### 11.4.5 설정 공유가 적절한 경우

필요하면서도 테스트의 결과에 직접적인 영향을 미치지는 않는 설정이 있을 수 있다.
이 경우에는 설정 공유를 통해 불필요한 코드 반복을 피할 수 있고 테스트는 더 뚜렷한 목적을 갖고 이해하기 쉬워진다.

인스턴스 생성시 반드시 필요하긴 하지만 테스트와 상관 없는 데이터의 경우는 
테스트 케이스에서 반복적으로 설정할 필요 없이 설정 공유 방식으로 상수를 정의해 사용할 수 있다.

> 함수 매개변수는 꼭 필요한 것만 갖는 것이 이상적이다.
만약 코드에 대한 테스트를 할 때 필요는 하지만 코드의 동작에는 별로 관련이 없는 설정을 해야 한다면, 함수(또는 생성자) 매개변수의 목적이 명확하지 않다는 것을 알려주는 신호일 수도 있다.

테스트 설정을 공유하는 것은 양날의 검이 될 수 있다.
코드 반복이나 비용이 많이 들어가는 설정의 반복적인 수행을 피하기 위해서는
유용하지만 테스트가 효과적이지 못하거나 파악하기 어려울 수 있다.
적절하게 사용하기 위해 심사숙고할 필요가 있다.

### 11.5 적절한 어서션 확인자를 사용하라

어서션 확인자assertion matcher는 보통 테스트 통과 여부를 최종적으로 결정하기 위한 테스트 케이스 내의 코드다.
어서션 확인자는 테스트가 실패하면 실패 이유를 설명하는 메시지를 생성한다.
테스트가 실패하는 이유가 잘 설명되어야 좋은 단위 테스트이므로 적절한 어서션 확인자를 선택하는 것이 중요하다.

#### 11.5.1 부적합한 확인자는 테스트 실패를 잘 설명하지 못할 수 있다

getClassNames() 함수는 모든 클래스 이름의 목록을 반환하도록 작성할 수 있는데,
주석에 클래스 이름은 특정한 순서를 갖지 않는다고 하지만 세부 사항이므로 주목해서 살펴봐야 한다.

테스트 케이스 작성시 의도한 것 보다 더 많은 것을 테스트할 수 있고
클래스 이름이 반환되는 순서가 변경되면 테스트가 실패한다.

이를 해결하기 위해 각각의 클래스 이름이 포함되어 있는지에 대한 contains() 함수를 통해 개별적으로 테스트한다.
또 실패 메시지의 경우 실패 이유가 설명되야 하므로 적절한 어서션 확인자를 선택할 필요가 있다. 

#### 11.5.2 해결책: 적절한 확인자를 사용하라

리스트가 순서에 관련 없이 특정 항목을 포함하고 있는지 검증할 수 있는 확인자가 제공된다.

- 자바: 트루스Truth 라이브러리에 containsAtLeast() 확인자가 있다
- 자바스크립트: 자스민Jasmine 프레임워크에 jasmine.arrayContaining() 확인자가 있다

적절한 어셔선 확인자를 사용하면 테스트가 실패할 경우 실패의 이유를 잘 설명한다.
그 외에도 적절한 확인자를 사용하면 테스트 코드 이해가 조금 더 쉬워진다.

테스트가 어떻게 실패할지에 대해 생각해보는 것이 중요하다.
적절한 어서션 확인자를 사용하면 테스트 실패 시 실패 이유에 대해 잘 알 수 있다.

### 11.6 테스트 용이성을 위해 의존성 주입을 사용하라

의존성 주입을 사용하면 코드가 개선되는 예는 많다.
테스트 시에 의존성 주입을 사용하면 코드의 테스트 용이성이 크게 향상된다.

#### 11.6.1 하드 코딩된 의존성은 테스트를 불가능하게 할 수 있다

고객에게 송장 리마인더를 보내는 InvoceReminder 클래스가 있다.
특징은 AddressBook과 EmailSender를 의존성 주입을 사용하지 않고 생성자에서 의존 객체를 만든다.

``` java
class InvoiceReminder {
  private final AddressBook addressBook;
  private final EmailSender emailSender;

  InvoiceReminder() {
    this.addressBook = DataStore.getAddressBook();
    this.emailSender = new EmailSenderImpl();
  }

  Boolean sendReminder(Invoice invoice) {
    EmailAddress? address = addressBook.lookupEmailAddress(invoice.getCustomerId());
    if (address == null) {
      return false;
    }
    return emailSender.send(address, InvoiceReminderTemplate.generate(invoice));
  }
}
```

아래와 같이 각 동작을 테스트 하면 이상적이다.

- sendReminder() 함수는 고객의 이메일 주소가 주소록에 있을 때 고객에게 알림 이메일을 보낸다.
- 알림 이메일이 전송되면 sendReminder() 함수는 참을 반환한다.
- 고객의 이메일 주소를 찾을 수 없을 때 sendReminder() 함수는 알림 이메일을 보내지 않는다.
- 알림 이메일이 전송되지 않으면 sendReminder() 함수는 거짓을 반환한다.

하지만 아래의 이유로 테스트가 어려우며 불가능할 수도 있다.

- 생성자에서 DataStore.getAddressBook()을 호출하여 AddressBook 인스턴스를 자체적으로 생성한다. 시간이 지나면서 데이터베이스의 데이터는 변경될 수 있기 때문에 실제 고객 데이터를 테스트에 사용하기에 적합하지 않다. 또 테스트 환경에서는 실제 데이터베이스에 액세스할 권한이 없을 수 있기 때문에 주소록이 작동하지 않을 수 있다.
- 자체적으로 EmailSenderImpl을 생성하고 ,실제 이메일을 보내는 결과를 초래한다. 테스트할 때 일어나는 부수 효과로 일어나면 안되는 일이고, 테스트로 부터 외부 세계를 보호해야 하는 예이다.

일반적으로 AddressBook과 EmailSender에 대한 테스트 더블을 사용할 수 있는데
테스트 더블로 InvoiceReminder 클래스의 인스턴스를 생성할 수 없기 때문에 안된다.

#### 11.6.2 해결책: 의존성 주입을 사용하라

의존성 주입을 사용하면 InvoiceReminder 클래스는 테스트하기 쉬워지고 이 문제를 해결할 수 있다.
생성자 주입과, 정적 팩토리 생성 패턴을 사용해서 의존성을 생성하고 주입할 수 있다.

``` java
class InvoiceReminder {
  private final AddressBook addressBook;
  private final EmailSender emailSender;

  InvoiceReminder(AddressBook addressBook, EmailSender emailSender) {
    this.addressBook = addressBook;
    this.emailSender = emailSender;
  }

  static InvoiceReminder create() {
    return new InvoiceReminder(DataStore.getAddressBook(), new EmailSenderImpl());
  }

  Boolean sendReminder(Invoice invoice) {
    EmailAddress? address = addressBook.lookupEmailAddress(invoice.getCustomerId());
    if (address == null) {
      return false;
    }
    return emailSender.send(address, InvoiceReminderTemplate.generate(invoice));
  }
}
```

의존성 주입을 통해 서로 모듈화 된 객체의 테스트가 용이해진다.

### 11.7 테스트에 대한 몇 가지 결론

단위 테스트 외에 사용할 가능성이 큰 다른 두 가지 테스트 수준은 다음과 같다.

- 통합 테스트integration test: 여러 구성 요소와 모듈, 하위 시스템을 서로 연결하는 프로세스를 통합integration이라고 한다. 통합 테스트는 이러한 통합이 제대로 작동하는지 확인하기 위한 테스트이다.
- 종단 간 테스트end-to-end test: 처음부터 끝까지 전체 소프트웨어 시스템을 통과하는 여정(또는 작업 흐름)을 테스트 한다.

알고 있으면 좋을 몇 가지 테스트 개념은 아래와 같다.

- 회귀 테스트regression test: 소프트웨어 동작이나 기능이 바람직하지 않은 방식으로 변경되지 않았는지 확인하기 위해 정기적으로 수행하는 테스트이다.
- 골든 테스트golden test: 특성화 테스트characterization test라고도 하며, 일반적으로 주어진 입력 집합에 대해 코드가 생성한 출력을 스냇샷으로 저장한 것을 기반으로 한다. 아무것도 변경되지 않았음을 확인하는 데는 유용하지만 실패한 경우 원인을 파악하기 어려울 수 있다. 어떤 경우에는 취약하고 신뢰하기 어렵다.
- 퍼즈 테스트fuzz test: 무작위 값이나 '흥미로운'값으로 코드를 호출하고 그들 중 어느 것도 코드의 동작을 멈추지 않는지 점검한다.

단위 테스트만으로는 테스트의 모든 요구 사항을 충족할 수 없기 때문에 다양한 테스트 유형과 수준에 대해 알아보고 새로운 툴과 기술에 대한 최신 정보를 유지하는 것이 좋다.

### 요약

- Concentrating on testing each function can easily lead to insufficient testing. It’s usually more effective to identify all important behaviors and write a test case for each.
- Test the behaviors of the code that ultimately matter. Testing private functions is nearly always an indication that we’re not testing the things that ultimately matter.
- Testing one thing at a time results in tests that are easier to understand as well as better explained test failures.
- Shared test setup can be a double-edged sword. It can avoid the repetition of code or expensive setup, but it can also lead to ineffective or flakey tests when used inappropriately.
- The use of dependency injection can considerably increase the testability of code.
- Unit testing is the level of testing that engineers tend to deal with most often. But it’s by no means the only one. Writing and maintaining software to a high standard often requires the use of multiple testing techniques. 