# 7장 코드를 오용하기 어렵게 만들라

## # 논의 내용

- 데이터만 보관하는 객체 말고 객체를 불변 객체로 만드는 방법이 있을까요?
    
    → 개인적으로 생각나는 방법 중 하나는 함수형 프로그래밍입니다. 함수형 프로그래밍에 대한 이해도가 높지는 않지만 기본적인 개념은 가공해야하는 데이터를 반환하고 이를 재사용하기 때문에 굳이 멤버변수를 선언을 최소화할 수 있기 때문이죠.

## 1. 불변 객체로 만드는 것을 고려하라

> 가변 객체는 코드의 복잡성을 늘리고 문제를 일으킬 수 있기 때문에, 기본적으로 불변적인 객체를 만들되 필요한 곳에서만 가변적이 되도록 하는 것이 바람직하다.
> 

### [문제점]

- 가변 클래스는 오용하기 쉽다.
    - 세터 함수가 있는 클래스는 가변적이다.
    - 세터 함수가 있는 클래스를 전달하면 이후 코드에서 객체를 변경할 수 있기 때문에 오용의 위험성이 크다.

### [해결책]

- 객체를 생성할 때만 값을 할당하라
    - 생성자를 통해서만 값을 변경할 수 있도록 한다.
    - 멤버 변수를 정의할 때 const, final, readonly 키워드를 사용해서 값이 변경되지 않도록 한다.
- 불변성에 대한 디자인 패턴을 사용하라
    - 불변 클래스의 가변적 버전을 사용해야 하는 경우 빌더 패턴과 쓰기 시 복사 패턴을 활용할 수 있다.
        - 빌더 패턴
            - 클래스의 속성 값이 모두 필수가 아닌 경우 사용을 고려
            - 필수적인 값은 빌더의 생성자를 통해서 할당하고 필수적이지 않는 값은 세터 함수를 통해 할당한다.
        - 쓰기 시 복사 패턴
            - 클래스의 속성 값을 변경했을 경우 새로운 인스턴스를 생성해서 전달한다.

**개인적인 생각**

객체가 반드시 불변 금지 상태로 있어야 한다면 객체를 생성할 때만 값을 할당하는 것이 좋아 보인다.

하지만 불가피하게 객체의 값을 변경해야 하는 경우라면 이곳 저곳에서 값을 변경할 수 있도록 오픈하는 것보다 되도록 한 곳에서 객체의 값을 변경할 수 있도록 잘 몰아가는 것이 좋아 보인다. 즉, 책에서 예로 설명한 빌더 패턴 또는 쓰기 시 복사 패턴을 활용하는 것이다.

다만 쓰기 시 복사 패턴의 경우 매번 새로운 인스턴스를 Heap에 생성하기 때문에 GC로 인한 성능 이슈가 있을 수 있다는 점을 고려해야 할 부분이다.

## 2. 객체를 깊은 수준까지 불변적으로 만드는 것을 고려하라

### [문제점]

- 깊은 가변성은 오용을 초래할 수 있다.
    - 멤버 변수가 참조 타입이고 해당 멤버 변수를 외부의 값을 통해 초기화를 한다면 아무리 멤버 변수를 private으로 가린다고 해도 원본 값이 변경되면 멤버 변수의 값이 변경된다.

### [해결책]

- 방어적으로 복사하라
    - 참조 타입의 멤버 변수가 불변해야 한다면 깊은 복사(Deep Copy)를 해야 한다.
    - C#에서는 Deep Copy를 아래와 같이 구현이 가능하다([참고 링크](https://learn.microsoft.com/ko-kr/dotnet/api/system.object.memberwiseclone?view=net-7.0))
        
        ```csharp
        public class Person
        {
            public int Age;
            public string Name;
            public IdInfo IdInfo;
        
            public Person ShallowCopy()
            {
               return (Person) this.MemberwiseClone();
            }
        
            public Person DeepCopy()
            {
               Person other = (Person) this.MemberwiseClone();
               other.IdInfo = new IdInfo(IdInfo.IdNumber);
               other.Name = String.Copy(Name);
               return other;
            }
        }
        ```
        
- 불변적 자료구조를 사용하라
    - ImmutableList와 같은 불변적 자료구조를 사용하라
    - 실제로 C#에서 ImmutableList를 사용하면 값을 변경했을 경우 원본 데이터는 그대로 있고 새로운 객체를 생성한다. 즉 쓰기 시 복사와 같이 동작하게 된다([참고 링크](https://learn.microsoft.com/en-us/dotnet/api/system.collections.immutable.immutablelist-1.add?redirectedfrom=MSDN&view=net-7.0#System_Collections_Immutable_ImmutableList_1_Add__0_))
    - 따라서 새로운 객체를 생성하는 것조차 방지하기 위해서는 C#의 `ReadOnlyCollection`과 같은 타입을 사용하는 것이 좋아 보인다.

## 3. 지나치게 일반적인 데이터 유형을 피하라

### [문제점]

- 지나치게 일반적인 유형은 오용될 수 있다
    - 2개 이상의 특정 정보를 활용할 때 List<List<Double>>와 같은 너무 일반적인 유형을 사용하면 오용할 수 있다.
    - 이럴 경우 2차원 배열의 열과 행이 각각 어떤 것을 의미하는지 직관적으로 확인하기가 어렵다.
- 페어 유형은 오용하기 쉽다
    - Pair<Double, Double>과 같은 형태도 first와 second가 각각 어떤 값을 의미하는지 직관적으로 확인하기 어렵다.

### [해결책]

- 전용 유형 사용
    - List<Data>와 같이 전용 데이터 객체를 만들어서 List에 보관한다.
    - 즉 무언가 구체적인 것을 나타낼 필요가 있을 경우 전용 유형을 정의하는 것이 좋다.
    - 각 언어에서 제공하는 데이터 전용 클래스를 활용하는 것도 좋다.
        - ex Kotlin)
            
            ```kotlin
            data class DataModel (
                val date : String = "",
                val memo : String = ""
            )
            ```
            

## 4. 시간 처리

### [문제점]

- 정수로 시간을 나타내는 것은 문제가 될 수 있다
    - 한순간인지 소요된 시간의 양인지 모호할 수 잇다.
    - 시간을 표현하는 단위가 달라서 요용할 수 있다(밀리초 vs 초 )
    - 나라 별로 시간대가 다르기 때문에 DB에 저장된 날짜가 서로 다른 날짜로 표시될 수 있다.

### [해결책]

- 적절한 자료구조를 사용하라
    - 각 언어에서 제공하는 시간 라이브러리를 활용한다.
    - 나라별로 시간대가 다른 이슈는 Utc로 전환하여 사용하는 것도 좋은 방법으로 보인다.

## 5. 데이터에 대한 진실의 원천을 하나만 가져야 한다

### [문제점]

- 또 다른 진실의 원천은 유효하지 않은 상태를 초래할 수 있다.
    - 기본 데이터들을 통해 생성되는 파생 데이터를 생성자를 통해 초기화하면 오용할 수 있다.

### [해결책]

- 기본 데이터를 유일한 진실의 원천으로 사용하라
    - 기본 데이터를 활용하여 사용하는 파생 데이터를 만들어서 사용할 때 기본 데이터만 생성자를 통해 값을 초기화할 수 있도록 한다.
    - 파생 데이터를 만드는 비용이 클 경우 캐싱을 활용해서 최초 1회만 파생 데이터를 생성할 수 있도록 한다.

## 6. 논리에 대한 진실의 원천을 하나만 가져야 한다.

### [문제점]

- 논리에 대한 진실의 원천이 여러 개 있으면 버그를 유발할 수 있다.
    - 서로 다른 클래스가 같은 하위 문제를 가지고 있을 경우 진실의 원천이 여러개로 볼 수 있다.

### [해결책]

- 진실의 원천은 단 하나만 있어야 한다
    - 하위 수준의 문제를 추상화해서 서로 다른 클래스가 한 곳을 바라볼 수 있도록 설계하는 것이 좋다.

개인적인 생각

대대적인 리팩토링 작업을 조만간 진행을 해야하는데 좋은 팁을 얻을 것 같아 기분이 좋다.

더불어 설계 단계에서 오용하기 어렵게 만드는 개념을 활용하는 것도 신선했다.

초반에 투입 시간이 다소 있는 게 나중에 더 많은 시간을 줄일 수 있다.