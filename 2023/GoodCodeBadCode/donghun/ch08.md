# 8장 코드를 모듈화하라

## # 논의 내용

상속 구조로 되어 있는 구조에서 피(?)를 본 경험이 혹시 있을까요?

→ 제가 직접 짠 구조는 아니지만 강의에서 캐릭터 로직을 설계할 때 상속에 상속을 구현하는 모습을 본 적이 있습니다. 

구조가 아래와 같았는데요, 문제는 BaseController에서 구현한 virtual 메서드를 자식 클래스에서 끊임없이 override를 하고 있어서 BaseController를 수정했을 때 파급효과가 정말 무시무시 했습니다..

실제 구현부를 찾기도 쉽지 않았구요. 비슷한 경험을 한적이 있다면 공유해 주세요.

[플레이어]

`BaseController` 

⬆

`CreatureController` 

⬆

`PlayerController`

⬆

`MyPlayerController`  

[몬스터]

`BaseController` 

⬆

`CreatureController` 

⬆

`MonsterController`

## 1. 의존성 주입의 사용을 고려하라

### [문제점]

- 하드 코드화된 의존성은 문제가 될 수 있다.
    - 클래스 내부에서 다른 클래스와 의존성을 가지고 있을 때 이를 하드 코드화해서 단 하나의 객체만 참조하면 다른 요구 사항에 유연하게 대처하기 힘들 수 있다.

### [해결책]

- 의존성 주입을 사용하라
    - 클래스 생성자의 매개 변수를 해당 클래스의 멤버 변수가 참조한다면 그 클래스는 훨씬 더 모듈화되고 다용도로 사용이 가능하다.
    - 단, 이렇게 되면 클래스의 생성자가 좀 더 복잡해 질 수 있는 단점이 생기는데 이는 팩토리 함수를 제공하면 된다.
    - 더불어 언어별로 제공하는 의존성 주입 프레임 워크도 사용을 고려하면 좋다.
- 의존성 주입을 염두에 두고 코드를 설계하라
    - 인터페이스를 통해 의존성을 주입할 수 있도록 설계하는 것이 낫다.
    - 해당 인터페이스를 사용하는 어떤 코드라도 원한다면 의존성 주입을 사용할 수 있으며 코드의 적응성도 높아진다.

## 2. 인터페이스에 의존하라

### [문제점]

- 구체적인 구현에 의존하면 적응성이 제한된다.
    - 특정 클래스만 의존하게 되면 해당 클래스 외 다른 클래스를 사용하기가 어렵다.

### [해결책]

- 가능한 경우 인터페이스에 의존하라
    - 인터페이스에 의존하면 하위 문제를 해결하기 위한 추상화 계층을 제공할 수 있어 좀 더 구현 중심적인 방식으로 문제를 해결할 수 있다.

## 3. 클래스 상속을 주의하라

### [문제점]

- 클래스 상속은 문제가 될 수 있다
    - 두 가지 사물이 진정한 is-a 관계를 갖는다면 상속이 적절할 수 있다(즉, 완변한 포함 관계 → 자동차는 차량이다 (o), 차량은 자동차이다(x))
    - 상속을 하게 되면 자식 클래스가 부모의 불필요한 기능까지 모두 상속 받게 되어서 오용을 유발할 수도 있다.
    - 즉 원하는 기능보다 더 많은 기능을 노출할 수도 있다.

### [해결책]

- 구성을 사용하라
    - 해결해야 하는 문제가 정의된 인터페이스를 참조한다.
    - 즉, 클래스의 멤버 변수로 하위 수준의 문제가 정의된 인터페이스를 정의하고 의존성 주입을 통해 인스턴스를 할당하는 방식을 사용한다.
- 진정한 is-a 관계는 어떤가?
    - 진정한 is-a 관계라도 문제가 될 수도 있다.
        - 취약한 베이스 클래스 문제: 슈퍼클래스 수정 시 서브 클래스에도 문제 발생 가능
        - 다이아몬드 문제: 여러 슈퍼 클래스가 동일한 기능을 하는 함수를 가질 수 있는데 이때 어떤 슈퍼클래스를 상속 받아야 모호
        - 문제가 있는 계층 구조: 설계한 계층 구조가 문제가 있을 수 있음
    - 인터페이스를 통해 설계한 구조는 기능에 초첨이 맞춰 있기 때문에 확장성이 좋다.

개인적인 생각

객체 지향의 핵심이 왜 인터페이스인지 다시금 느낄 수 있는 파트였습니다.

인터페이스를 왜 사용해야 하는지에 대한 이유를 설득력 있게 소개를 해주고 있어서 좋았고 객체 지향을 이해하기 위한 기초 토대를 다시금 잘 다질 수 있어서 좋았습니다.

## 4. 클래스는 자신의 기능에만 집중해야 한다

### [문제점]

- 다른 클래스와 지나치게 연관되어 있으면 문제가 될 수 있다
    - 요구 사항이 변경되면 그 개념에 해당하는 하나의 클래스만 수정하는 것이 좋다.
    - 하나의 개념을 여러 클래스에 분산되었을 경우 요구 사항이 변경 되었을 때 여러 클래스에서 수정을 해야 할 수 있다.

### [해결책]

- 자신의 기능에만 충실한 클래스를 만들라
    - 코드를 모듈화 했을 경우 한 가지 변경 사항이 코드의 한 부분만 영향을 미치도록 할 수 있다.

> cf) 소프트웨어 엔지니어링 원칙에 대한 여러 주장을 읽고 발생할 수 있는 장단점을 고려하는 것이 좋다. 여러 주장을 읽고 자신만의 의견을 갖되 근거를 기반으로 하기를 권한다.
> 

소프트웨어 공학에서 말하는 원칙들의 장점만 볼 것이 아니라 단점도 고려하고 장단점을 근거로한 내 의견을 갖는 것이 좋아보인다.

## 5. 관련 있는 데이터는 함께 캡슐화하라

### [문제점]

- 캡슐화되지 않은 데이터는 취급하기 어려울 수 있다.
    - 서로 연관 되어 있는 데이터를 한 클래스에 두지 않으면 데이터가 함께 움직이기 힘들 수 있다.

### [해결책]

- 관련된 데이터는 객체 또는 클래스로 그룹화하라
    - 서로 관련 있는 항목을 단일 클래스로 제공하여 더욱 모듈화 시킬 수 있다.

## 6. 반환 유형에 구현 세부 정보가 유출되지 않도록 주의하라

### [문제점]

- 반환 형식에 구현 세부 사항이 유출될 경우 문제가 될 수 있다.

### [해결책]

- 추상화 계층에 적합한 유형을 반환하라
    - 반환 타입을 너무 상세한 값을 반환하는 것이 아닌 해당 문제를 해결하기 위해 필요한 값만 반환한다(Payload → Byte 배열(이미지 바이트 값))

## 7. 예외 처리 시 구현 세부 사항이 유출되지 않도록 주의하라

### [문제점]

- 예외 처리 시 구현 세부 사항이 유출되면 문제가 될 수 있다
    - 추상화 되어 있는 구조에서 인터페이스 정의 부분이 아닌 구현부에서 예외를 처리할 시 해당 클래스에서만 예외가 처리되어 문제가 발생할 수 있다.

### [해결책]

- 추상화 계층에 적절한 예외를 만들라
    - 인터페이스 정의 부분에서 예외를 던질 수 있도록 정의를 해서 구현부에서도 예외를 던질 수 있도록 한다.