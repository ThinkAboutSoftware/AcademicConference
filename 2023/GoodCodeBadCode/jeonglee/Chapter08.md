## 8장 코드를 모듈화하라  

> 요구사항이 어떤 식으로든 바뀐다는 점은 확신할 수 있다.  

### 논의 사항

데이터 객체에 대한 생각이 궁금합니다.

저는 데이터객체를 사용하는 것이 바람직하다고 생각은 들지만 만약 소프트웨어의 덩치가 커짐에 따라 데이터 객체가 많이 세분화 되거나 하나의 데이터객체가 점점 커져서 필요 이상의 덩치를 가지게 될 것 같다는 생각이 듭니다.  

그대로 진행하게 되면 너무 세분화된 데이터 클래스가 많아서 헷갈리게 되면 결국 문서화로 이어지게 되고 한가지 데이터 객체가 너무 많은 부담을 받아서 문제가 발생한 경우에는 수정하기 어려움도 커질 것 같습니다.

### 책의 내용 및 정리  

핵심 주제  

* 모듈화된 코드의 이점
* 이상적인 코드 모듈화가 되지 않는 일반적인 방식
* 코드를 좀 더 모듈화하기 위한 방법

모듈화의 주된 목적 중 하나는 향후에 어떻게 변경되거나 재구성될지 정확히 알지 못한 상태에서 변경과 재구성이 용이한 코드를 작성하는 것이다.  

이를 달성하기 위해선 각각의 기능이 코드베이스의 서로 다른 부분에서 구현되어야 한다는 것이다.  

이것이 달성된다면 요구 사항 중 하나가 변경된다면, 코드 베이스에서 그 요구 사항이나 기능과 관련된 부분만 수정하면 된다.  

즉, 추상화 개념이 핵심이며 하위 문제에 대한 해결책의 자세한 세부사항들이 독립적이고 서로 밀접하게 연관되지 않도록 하는 것(디커플링)으로 귀결된다.  

이렇게 하면 적응성이 뛰어난 코드가 될 뿐만 아니라 소프트웨어 시스템에 대한 추론을 쉽게 해준다.  

모듈화된 코드는 재사용과 테스트에 더욱 적합하기 때문에 많은 이점을 가진다.

#### 의존성 주입의 사용을 고려하라  

일반적으로 클래스는 다른 클래스에 의존한다.  

높은 수준의 문제를 하위 문제들로 나눠서 해결하는 방법을 알아봤다.  

여기서 하위 문제에 대한 해결책이 항상 하나만 존재하는 것은 아니므로 하위 문제를 재구성할 수 있는 방식으로 코드를 작성하는 것이 유용할 수 있다.  

*DI(dependency Injection)*  

[<mark style='background-color: #4F96F3'>DI 정리글</mark>](https://fkdl0048.github.io/patterns/Patterns_DI/)

##### 하드 코드화된 의존성은 문제가 될 수 있다  

하드코드로 구현된 종속성코드의 예제로 나름 인터페이스를 사용해서 클래스를 구현했지만 생성자에서 의존성을 따로 주입하지 않았기 때문에 코드 자체에 하드코딩이 들어갔다.  

이렇게 구현할 일이 있을까 싶다가 앞서 말한 요구사항을 생각하지 않고 급하게 만들면 이렇게 할수도 있겠다는 생각이..  

##### 의존성 주입을 사용하라

의존성 주입을 사용하게 되면 일단 디커플링이 이뤄낼 수 있고 다형성을 가져갈 수 있다.  

인터페이스로 추상화까지..  

또한 의존성 주입을 통한 팩토리함수를 사용하여 입구와 출구를 하나로 만들어서 쉽게 관리할 수 있다.  

여기 나온 내용이 저번 아카데미 컨퍼런스에서 끝나고 이야기를 나눴던 내용인 것 같다..  

[<mark style='background-color: #4F96F3'>Factory Method Pattern 정리글</mark>](https://fkdl0048.github.io/patterns/Patterns_FactoryMethod/)

그나저나 `CreateDefaultNorthAmericaRoutePlanner()`메서드 명이 진짜 길다.  

필수로 들어가야하는 내용은 잘 들어간 것 같은데 이 정도면 길다고 말할 수 없는건지 궁금하다.  

**의존성 주입 프레임워크**  

의존성 주입은 클래스를 좀 더 변경할 수 있게 해주는 장점이 있지만, 생성하는 부분의 코드는 더 복잡해진다는 단점이 있다  

이를 해결하기 위해 팩토리 함수를 작성할 수도 있지만 그 또한 대응되는 클래스를 만들어야하고 반복적으로 작성하는 코드가 많아질 수 있다.  

**제네릭을 사용한다면..?**  

아직 의존성 주입 프레임워크를 많이 접해보지 못해서 어떤 형태로 존재하는지 모르겠다..  

검색해도 안나오다니..

##### 의존성 주임을 염두에 두고 코드를 설계하라  

코드를 작성할 때 의존성 주입을 사용할 수 있다는 점을 의식적으로 고려하는 것이 유용할 때가 있다.  

코드를 작성하다 보면 나중에는 의존성 주입을 사용하고 싶어도 사용이 거의 불가능한 코드가 짜여질 수 있기 때문이다.  

처음부터 정적함수에 의존하는 형태로 작성한 예를 보면 의존성 주입을 넣고 싶어도 넣지 못하는 문제가 발생한다.  

하위 문제를 해결할 때 그것이 문제에 대한 유일한 해결책이라고 생각하기 쉽다.  

이러한 문제를 해결할 때 쉽게 정적함수로 해결하면 쉽게 해결되기 때문에 별 생각없이 `정적 매달림`에 빠질 수 있다.  

정적함수는 대부분 Util성격의 함수로 구성된 하나의 해결책만 있는 근본적인 하위 문제를 다루는 것이 좋다.  

#### 인터페이스에 의존하라  

의존할꺼면 인터페이스에 의존해라..!!  

앞서 다룬 예제와 같이 모듈화를 위해선 인터페이스를 정말 잘 활용해야 한다.  

##### 구체적인 구현에 의존하면 적응성이 제한된다  

앞서 다룬 안좋은 예제의 버전 2다..  

생성자 자체를 클래스로 가져가기 때문에 (추상클래스 제외)적응성이 제한되게 된다.  

##### 가능한 경우 인터페이스에 의존하라  

구체적인 구현 클래스에 의존하면 인터페이스를 의존할때 보다 적응성이 제한되는 경우가 많다.  

인터페이스는 하위 문제를 해결하기 위한 추상화 계층을 제공하는 것으로 생각할 수 있다.  

**클래스가 인터페이스를 상속받아 구현하고 인터페이스가 필요한 동작을 정의한다면 이것은 곧 다른 개발자가 해당 인터페이스에 대해 다르게 구현한 클래스를 작성할 수 있다는 것을 강력하게 시사한다.**  

*의존성 역전 원리: 보다 구체적인 구현보다는 추상화에 의존하는 것이 낫다는 생각의 핵심*  

#### 클래스 상속을 주의하라  

대부분 객체지향 프로그래밍 언어의 핵심 기능 중 하나는 한 클래스가 다른 클래스를 상속할 수 있다는 것이다.  

클래스 상속은 확실히 쓸모가 있고 때로는 적합한 도구이다.  

두 가지 사물이 진정한 is-a 관계를 갖는다면 상속이 적절할 수 있다.  

상속은 강력한 도구지만, 몇 가지 단점이 있고 상속이 야기하는 문제가 치명적일 수 있기 때문에 한 클래스가 다른 클래스를 상속하는 코드를 작성하는 것에 대해서는 신중하게 생각해야 한다.  

상속을 사용할 수 있는 많은 상황에서 구성을 상속 대신 사용할 수 있다.  

클래스를 확장하기보다는 인스턴스를 가지고 있음으써 한 클래스를 다른 클래스로부터 구성할 수 있다.  

구성도 멘토님과 추상클래스에 대해서 조언을 구할 때 알려주신 방법으로 상속이 익숙하지 않다면 먼저 해볼 것을 추천해주셨다.  

**구성**은 컴포넌트 패턴과 같은 개념인 것 같다..  

[<mark style='background-color: #4F96F3'>Component 정리글</mark>](https://fkdl0048.github.io/patterns/Patterns_Component/)

처음 한 10개월 전에 C#을 공부하기 시작하면서 "상속은 좋은 거구나..!"하며 뭔갈 해볼려고 상속을 무작정사용하던 생각이 난다..  

지금도 상속을 잘 사용하고 싶지만 어렵지만 반드시 상속을 해야하는게 아니라는 것을 알게된 것 같아서 좋다.. 그래도..  

##### 클래스 상속은 문제가 될 수 있다  

상속의 예로 많이 나오는 Animal이나 Vehicle예제는 상속의 의미자체는 잘 전달하지만 개발자들이 만나게 되는 함정을 설명하기엔 너무 추상적이다.  

상속에서 발생하는 현실적인 문제들을 다룬 예를 살펴보자  

쉼표로 구분된 정수를 가지고 있는 파일을 열어서 정수를 하나씩 읽어 들이는 클래스를 작성해야 한다고 가정해보자.  

이 문제에 대한 하위 문제는 다음과 같다.  

* 파일에서 데이터를 읽는다.
* 쉼표로 구분된 파일 내용을 개별 문자열로 나눈다.
* 각 문자열을 정수로 변환한다.  

*지금보니 하위문제를 추출하는 방법으로 상위문제에 대한 하위문제를 이 처럼 글로 나열하는 방법이 다시한번 좋다는 걸 알았다.*  

상속에서 가장 강조되는 부분은 **확장**의 개념이다.  

**상속은 추상화 계층에 방해가 될 수 있다.**  

한 클래스가 다른 클래스를 확장하면 슈퍼클래스의 모든 기능을 상속한다.  

이러한 기능은 유용할 때가 있지만, 원하는 것보다 더 많은 기능을 도출할 수도 있다.  

이로 인해 추상화 계층은 복잡해지고 구현 세부 정보가 드러날 수 있다.  

물론 추상화 클래스를 잘 설계하여 상속 받아서 만든다면 문제가 세부정보를 가릴 수 있다.  

하지만 요구사항이 변동되거나 데이터를 예측하기에 어렵고, 순수한 추상클래스를 만들기 어렵다.  

**상속은 적응성 높은 코드의 작성을 어렵게 만들 수 있다.**  

요구사항이 변동되어 쉼표뿐만 아니라 세미콜론으로 구분된 값도 읽을 수 있어야 한다고 가정해보자.  

그런데 이미 세미콜론으로 구분된 값을 읽을 수 있는클래스가 있다는 것을 알게 됐다.  

따라서 쉼표구분클래스 대신 세미콜론클래스를 상속하도록 바꾸면 될 것 같지만 그렇지 않다.  

유일한 해결방법은 새 클래스를 만들어 상속받아 구현하는 것이다.  

하지만 만들고 본다면 중복되는 코드들이 눈에 보일 것이고.. 유지보수 비용과 버그 발생 가능성을 높이기 때문에 바람직하지 않다.  

##### 구성을 사용하라  

상속을 원래 사용한 동기는 쉼표로 구분하여 읽는 클래스의 일부 기능을 재사용하는 것이었다.  

앞서 발견한 몇 가지 단점이 존재하기 때문에 쉼표 클래스의 기능을 재사용하는 방법으로 구성을 사용하는 것이다.  

즉, 클래스를 확장하기보다 해당 클래스에서 인스턴스를 가지고 있음으로써 하나의 클래스를 다른 클래스로부터 **구성**한다는 것을 의미한다.  

8.15예제 정말 깔끔하다ㅠ..  

**더 간결한 추상화 계층**  

상속을 사용할 때 서브 클래스는 슈퍼클래스의 모든 기능을 상속하고 외부로 제공한다.  

이것은 외부로 노출하고 싶어하지 않는 API까지 만들어진다.  

상속 대신 구성을 사용하면 클래스가 전달이나 위임을 사용하여 명시적으로 노출하지 않는 한 해당 클래스의 기능이 노출되지 않는다.  

**적응성이 높은 코드**  

여기서 쉼표나 세미콜론에 해당되는 인터페이스를 기능으로 구분하여 제공하면 좀 더 적응성이 높은 코드로 이어진다.  

##### 진정한 is-a 관계는 어떤가?  

앞 서 두 클래스가 진정한 is-a 관게를 맺고 있다면 상속이 타당할 수 있다고 언급했다.  

Car is a Vehicle의 관계는 명확하기 때문에 확장할 수 있다.  

하지만 앞서 다룬 예제는 is-a관계라고 보기 어렵다.  

*FileHandler -> 관계의 파생은 괜찮아 보인다.*  

내 생각은 기능적인 부분이기 때문에 인터페이스를 통한 (각각의 명확한 기능을 명시) 구성이 제일 좋아보이는데 책에서 말하는대로 답은 없으며 주어진 상황과 작업중인 코드에 따라 다르다.  

진정한 is-a관계라도 상속하는 것에 대한 여전히 문제가 될 수 있음을 알아야 한다.  

다음과 같이 몇가지 주의할 점이 있다.  

* **취약한 베이스 클래스 문제**

서브클래스가 슈퍼클래스에서 상속되고 해당 슈퍼클래스가 나중에 수정되면 서브클래스가 작동하지 않을 수도 있다.  

* **다이아몬드 문제**

일부 언어는 두 대 이상의 슈퍼클래스를 확장할 수 있는 **다중 상속**을 지원한다. 여러 슈퍼 클래스가 동일한 함수의 각각 다른 다른 버전을 제공하는 경우에 어떤 슈퍼클래스로부터 함수를 상속받아야 하는지 모호하기 때문이다.(죽음의 다이아몬드라고 알고 있었다.)  

* **문제가 있는 계층 구조**

많은 언어가 다중 상속을 지원하지 않으므로 클래스는 오직 하나의 클래스만 직접 확장할 수 있다. 이를 **다중상속**이라고 하며 다른 유형의 문제가 발생할 수 있다.

Car라는 클래스와 AirCraft라는 클래스가 있다고할 때 FlyingCar는 어떤 클래스를 상속받아야 할까?  

따라서 단일 상속만 가능한 경우 논리적으로 둘 이상의 클래스에 속할때 문제가 발생할 수 있다.  

때로는 계층 구조를 피할 수 없는 경우도 있다.  

클래스 상속에 숨어 있는 많은 함정을 피하면서 계층 구조를 달성하기 위해선 다음과 같은 것을 할 수 있다.  

* 인터페이스를 사용하여 계층 구조를 정의한다.
* 구성을 사용하여 코드를 재사용한다.  

#### 클래스는 자신의 기능에만 집중해야 한다  

모듈화의 핵심은 목표 중 하나는 요구사항이 변경되면 그 변경과 직접 관련된 코드만 수정한다는 것이다.  

이는 단일 개념이 단일 클래스 내에 완전히 포함된 경우라면 이 목표를 달성할 수 있다.  

어떤 개념과 관련된 요구 사항이 변경되면 그 개념에 해당하는 단 하나의 클래스만 수정하면 된다.

이것과 반대되는 상황이 하나의 개념이 여러 클래스에 분산되는 경우다.  

해당 개념과 관련된 요구 사항을 변경하려면 관련된 클래스를 모두 수정해야 한다.  

이 때 개발자가 관련 클래스 중 하나를 잊어버리고 수정하지 않으면 버그가 발생할 수 있다.  

클래스가 다른 클래스의 세부 사항에 지나치게 연관되어 있을 때 이런 일이 흔히 일어날 수 있다.  

##### 다른 클래스와 지나치게 연관되어 있으면 문제가 될 수 있다  

책에서 주어진 예제와 같이 책과 챕터를 나타내는 클래스가 있다고 할 때 책클래스에 챕터 클래스가 **구성**되어 있다고 해서 구성된 클래스만을 다루는 코드를 책 클래스 내부에 만들게 되면 문제가 될 수 있음을 나타낸다.  

##### 자신의 기능에만 충실한 클래스를 만들라  

코드 모듈화를 유지하고 한 가지 사항에 대한 변경 사항이 코드의 한 부분만 영향을 미치도록 하기 위해, Book과 Chapter클래스는 가능한 란 자신의 기능에만 충실하도록 해야 한다.  

따라서 예제의 경우는 Book클래스에서 Chapter클래스의 함수를 사용하여 값을 반환한다.  

즉, 장의 단어를 세는 논리는 챕터클래스가 기능에 충실하게 가지고 있고 책은 해당 컨테이너의 역할로 존재  

**디미터의 법칙: 한 객체가 다른 객체의 내용이나 구조에 대해 가능한 최대한으로 가정하지 않아야 한다는 소프트웨어 공학 원칙이다.**

클래스는 서로에 대한 어느 정도의 지식을 필요로 할 때도 있지만, 가능한 한 이것을 최소화하는 것이 좋을 때가 많다.  

이를 통해 코드 모듈화를 유지할 수 있으며 적응성과 유지 관리성을 크게 개선할 수 있다.  

#### 관련 있는 데이터는 함께 캡슐화하라  

2장에서 다룬 한 클래스가 대한 책임이 많아질수록 야기될 수 있는 문제점을 살펴보았다.  

너무 많은 것들을 한 클래스에 두지 않도록 주의해야 하지만 한 클래스안에 함께 두는 것이 합리적일 때는 그렇게 하는 것의 이점을 놓쳐서도 안 된다.  

서로 다른 데이터가 서로 밀접하게 관련되어 있어 그것들이 항상 함께 움직여야 할 때가 있다.  

이 경우에는 클래스로 그룹화하는 것이 합리적이다.  

이렇게 하면 코드는 여러 항목의 세부사항을 다루는 대신, 그 항목들이 묶여 있는 단일한 클래스가 제공하는 상위 수준의 개념을 다룰 수 있다.  

이를 통해 코드는 더욱 모듈화하고 변경된 요구사항을 해당 클래스에서만 처리할 수 있다.  

##### 캡슐화되지 않은 데이터는 취급하기 어려울 수 있다  

책에서 보여주는 예처럼 `displayMessage()`함수의 경우 uiSettings의 값을 읽어와서 전달한다.  

여기서 생기는 문제점은 새로운 renderType이 필요할 경우 매개변수를 하나 늘려서 UserInterface를 수정해야 하는 것을 의미한다.  

모듈화의 핵심은 요구사항에 발맞춰서 해당 부분만 수정해야 하지만, 서로 다른 데이터를 다룰 때 현재 메서드처럼 연관되어 있다면 전부 따라 올라가며 수정을 해줘야 한다.  

지금은 하나의 예지만 실제 프로젝트에선 더욱 다양한 값들을 추척해야 할것이다.  

*책에선 이러한 상황을 세부사항, 세부적인 내용으로 다룬다.*  

간단한 예시로 택배기사, 웨이터등 캡슐화된 데이터를 전달할 때는 해당 데이터가 뭔지 몰라야한다.  

하지만 지금의 형태는 displayMessage()함수는 전달하는 내용을 정확하게 알고 있어야 한다.  

##### 관련된 데이터는 객체 또는 클래스로 그룹화하라  

TextOptions 캡슐화 클래스를 만들어서 텍스트 사이즈, 폰트 등등을 캡슐화하여 인스턴스로 전달할 수 있다.  

이렇게 만들어 displayMessage()함수는 캡슐화된 데이터만 전달해주는 택배기사와 동일하다.  

#### 반환 유형에 구현 세부 정보가 유출되지 않도록 주의하라  

간결한 추상화 계층을 가지려면 각 계층의 구현 세부 정보가 유출되지 않아야 한다.  

구현 세부 정보가 유추되면 코드의 하위 계층에 대한 정보가 노출될 수 있으며, 향후 수정이나 재설정이 매우 어려워질 수 있다.  

코드에서 구현 세부정보를 유출하는 일반적인 형태 중 하나는 해당 세부 정보와 밀접하게 연결된 유형을 반환하는 것이다.  

##### 반환 형식에 구헌 세부 사항이 유출될 경우 문제가 될 수 있다  

말 그대로 반환 형식에 세부 구현 사항이 유출될 경우 문제가 될 수 있다.  

이는 앞서 다룬 참조에도 해당되는 이야기이며 세부 사항은 세부사항으로 만든 이유가 있기 때문이다.  

##### 추상화 계층에 적합한 유형을 반환해라  

외부로 노출할 개념을 최소화하는 유형을 새로 정의해 사용하면 좀 더 모듈화된 코드와 간결한 추상화 계층을 얻을 수 있다.  

#### 예외 처리 시 구현 세부 사항이 유출되지 않도록 주의하라  

구현 세부 정보가 유출될 수 있는 또 다른 일반적인 경우는 예외를 발생할 때다.  

##### 예외 처리 시 구현 세부 사항이 유출되면 문제가 될 수 있다  

비 검사 예외의 핵심 기능 중 하나는 예외가 발생하는 위치나 시기, 코드가 어디에서 그 예외를 처리하는지 등에 대한 그 어떠한 것도 컴파일러에 의해 강제되지 않는다는 것이다.  

인터페이스를 구현하는 클래스가 반드시 인터페이스가 규정하는 오류만 발생시켜야만 하는 것은 아니다.  

##### 추상화 계층에 적절한 예외를 만들라  

구현 세부 사항의 유츨을 방지하기 위해 코드의 각 계층은 주어진 추상화 계층을 반영하는 오류 유형만을 드러내는 것이 이상적이다.  

### 느낀점

모듈화에 대한 지식이 뽝..!  

가장 신경써서 읽은 챕터중에 하나로 뒷 부분의 8.7 예외부분은 이해하기 어려웠고 중간에 서버관련 반환값도 조금 어려웠다.  

다른 예제는 직관적이고 이미 지키고 있거나 비슷한 예가 많아서 이해가 더 잘된 것 같다.  

오용과 마찬가지로 전체적으로 말하고자 하는 줄기는 비슷한 것 같다.  

앞의 내용들을 좀 더 세분화하여 예제로 보여주는 것 같았다.
