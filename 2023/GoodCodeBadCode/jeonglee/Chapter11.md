## 11장 단위 테스트의 실제

### 논의 사항

실제로 책에서 나온 대로 테스트 코드를 짜기 위해서 코드 구조가 변경되는 경우가 많나요?  

### 책의 내용 및 정리  

핵심 주제  

* 코드의 모든 동작을 효과적이고 신뢰성 있게 테스트하기
* 이해하기 쉽고 실패가 잘 설명되는 테스트 코드의 작성
* 의존성 주입을 사용하여 테스트가 용이한 코드의 작성

이번 장에서 설명할 많은 기법의 동기는 이 특징을 직접 따르는데, 다시 한번 상기하자면 다음과 같다.  

* 코드의 문제를 정확하게 감지한다: 코드에 문제가 있으면 테스트는 실패해야 한다. 그리고 테스트는 코드에 실제로 문제가 있는 경우에만 실패해야 한다.  
* 구현 세부 정보에 구애받지 않는다: 구현 세부 사항을 변경하더라도 테스트 코드에 대한 변경은 필요 없는 것이 이상적이다.  
* 실패는 잘 설명된다: 코드에 문제가 있는 경우 테스트 실패는 문제에 대한 명확한 설명을 제공해야 한다.  
* 테스트 코드가 이해하기 쉽다: 테스트가 정확히 무엇이고 테스트가 어떻게 수행되는지 다른 개발자가 이해할 수 있어야 한다. 
* 테스트를 쉽고 빠르게 실핼할 수 있다: 개발자는 일상적인 작업에서 단위 테스트를 꽤 자주 실행해야 한다.

#### 기능뿐만 아니라 동작을 시험하라  

코드를 테스트하는 것은 할 일 목록을 만들어 작업하는 것과 약간 비슷하다.  

테스트 대상 코드가 수행하는(코드를 작성하기 전에 테스트를 작성하는 경우라면 수행할 예정인) 작업이 여러 가지 있으며 이 각각의 작업에 대해 테스트 케이스를 따로 작성해야 한다.  

클래스에 함수가 2개 있으면 함수마다 하나의 테스트 케이스를 작성하는 식이다.  

10장에서 코드가 보이는 중요한 행동을 모두 테스트해야 한다는 것을 살펴봤다.  

각 함수들 테스트하는 데만 집중할 때의 문제점은 한 함수가 종종 여러 개의 동작을 수행할 수 있고 한 동작이 여러 함수에 걸쳐 있을 수 있다는 점이다.  

함수별로 테스트 케이스를 하나만 작성하면 중요한 동작을 놓칠 수 있다.  

##### 함수당 하나의 테스트 케이스만 있으면 적절하지 않을 때가 많다.  

예제에서 주어지는 퍼블릭 API의 케이스만 테스트하기 때문에 assess함수가 올바른 방식으로 동작하는지 확인하기에 충분치 않다.  

##### 각 동작을 테스트하는 데 집중하라  

함수와 동작 사이에 일대일로 연결이 안 되는 경우가 많다.  

함수 자체를 테스트하는 데만 집중하면, 정작 실제로 신경 써야 할 중요한 동작을 검증하지 않는 테스트 케이스를 작성하기가 매우 쉽다.  

*테스트 코드의 양이 실제 코드의 양보다 많지 않다면, 모든 동작이 제대로 테스트되고 있지 않음을 나타내는 경고 표시일 수 있다.*

#### 테스트만을 위해 퍼블릭으로 만들지 말라

일반적으로 코드의 공개 API는 public함수로 이루어진다.  

클래스는 퍼블릭 함수 외에도 프라이빗 함수를 갖는 것이 일반적인데 이들은 클래스 내에서만 사용할 수 있다.

프라이빗 함수는 구현 세부 사항이며 클래스 외부의 코드가 인지하거나 직접 사용하는 것이 아니다.  

때로는 이러한 프라이빗 함수 중 일부를 테스트 코드에서도 접근할 수 있도록 만들어 직접 테스트하고자 할 수 있다.  

그러나 이는 좋은 생각이 아닐 때가 많다.  

구현 세부 사항과 밀접하게 연관된 테스트가 될 수 있고, 궁극적으로 우리가 신경 써야 하는 코드의 동작을 테스트하지 않을 수 있기 때문이다.  

##### 프라이빗 함수를 테스트하는 것은 바람직하지 않을 때가 많다.  

좋은 단위 테스트는 궁극적으로 중요한 행동을 테스트해야 한다.  

이렇게 하면 테스트는 코드의 문제점을 정확하게 감지할 가능성을 극대화하며 구현 세부 사항에 독립적으로 된다.  

##### 퍼블릭 API를 통해 테스트하라  

구현 세부 사항이 아닌 실제로 중요한 동작을 테스트하도록 개발자에게 가이드를 제공하는 것이다.  

프라이빗 함수여야 하는데도 퍼블릭으로 표시되어 외부로 공개되어 있다면, 이 원칙을 깨뜨리는 경고 신호로 봐야 한다.  

*실용적으로 하라: 테스트를 위해 프라이빗 함수를 퍼블릭으로 만들어 외부로 보이게 하는 것은 대부분의 경우 구현 세부 사항을 테스트한다는 것을 보여주는 경고 신호이다.*  

비교적 간단한 클래스의 경우 퍼블릭 API만을 사용하여 모든 동작을 테스트하기가 매우 쉽다.  

이렇게 하면 코드의 문제점을 보다 정확하게 감지하고 구현 세부 사항에 얽매이지 않는 더 나은 테스트를 수행할 수 있다.  

그러나 클래스(또는 코드 단위)가 더 복잡하거나 많은 논리를 포함하면 퍼블릭 API를 통해 모든 동작을 수행하는 것이 까다로울 수 있다.  

이 경우는 코드의 추상화 계층이 너무 크다는 것을 의미하기 때문에 코드를 더 작은 단위로 분할하는 것이 유리하다.  

##### 코드를 더 작은 단위로 분할하라  

퍼블릭 API를 통해 이러한 모든 복잡성과 모든 코너 사례를 테스트하는 것이 상당히 어려워 보인다.  

사실 이런 경우는 대부분 추상화 계층이 너무 비대하기 때문에 퍼블릭 API만으로 모든 것을 완벽하게 테스트하기 어려워 보인다.  

코드를 테스트하기 위해 프라이빗 함수를 퍼블릭으로 만든다면, 이것은 실제로 신경 써야 하는 행동을 테스트하지 않는다는 경고 신호로 받아들여야 한다. 

이미 공개된 함수를 사용해 코드를 테스트 하는 것이 대부분은 더 바람직하다.  

이것이 어렵다면 클래스가 너무 크기 때문에 하위문제를 해결하는 더 작은 클래스(또는 단위)로의 분할을 고려해봐야 하는 시점에 이르렀음을 의미한다.  

#### 한 번에 하나의 동작만 테스트하라  

주어진 코드에 대해 테스트해야 하는 동작은 여러 가지가 있다.  

많은 경우에 각각의 동작을 테스트하려면 약간 다른 시나리오를 설정해야 하므로, 각각의 시나리오는 그에 해당하는 별도의 테스트 케이스로 테스트하는 것이 가장 자연스럽다.  

그러나 때로는 하나의 시나리오로 여러 동작을 테스트하도록 만드는 방법이 있다. 하지만 다 좋은 것은 아니다.  

##### 여러 동작을 한꺼번에 테스트하면 테스트가 제대로 안될 수 있다.  

가능한 방법 한가지는 테스트 케이스를 하나만 작성하고 이 안에서 함수의 모든 동작을 한 번에 테스트하는 것이다.  

한꺼번에 테스트하면 테스트 케이스가 정확히 무엇을 하고 있는지 이해하기 어렵다는 점이다.  

이러한 문제는 `이해하기 쉬운 테스트 코드`에서 벗어난다.  

##### 각 동작은 자체 테스트 케이스에서 테스트하라  

휠씬 더 나은 접근법은 잘 명명된 테스트 케이스를 사용하여 각 동작을 개별적으로 테스트하는 것이다.  

각 동작을 개별적으로 테스트하고 각 테스트 케이스에 적절한 이름을 사용하면 테스트가 실패할 경우 어떤 동작이 실패했는지 잘 알 수 있다. 

##### 매개변수를 사용한 테스트  

테스트 프레임워크 중에 매개변수를 사용해 테스트할 수 있는 기능을 제공하는 프레임워크도 있다.  

매개변수를 사용한 테스틑 많은 코드를 반복하지 않고도 모든 동작을 테스트할 수 있는 좋은 도구다.  

언어마다의 프레임워크가 다 다르기 때문에 프로젝트의 성격에 맞게 장단점을 생각해 적용하는 것이 좋다.  

#### 공유 설정을 적절하게 사용하라  

테스트 케이스는 의존성을 설정하거나 테스트 데이터 저장소에 값을 채우거나 다른 종류의 상태를 초기화하는 등 어느 정도의 설정이 필요할 때가 있다.  

이런 설정을 하려면 시간과 노력이 상당히 많이 들어가고 리소스도 많이 필요할 수 있기 때문에 많은 테스트 프레임워크에서 테스트 케이스 간에 이 설정을 쉽게 공유할 수 있는 기능을 제공한다.  

##### 상태 공유는 문제가 될 수 있다.  

일반적으로 테스트 케이스는 서로 격리되어야 하므로 한 테스트 케이스가 수행하는 모든 조치는 다른 테스트 케이스의 결과에 영향을 미치지 않아야 한다.  

테스트 케이스 간에 상태를 공유하고 이 상태가 가변적이면 이 규칙을 실수로 위반하기 쉽다.  

##### 상태를 공유하지 않거나 초기화하라  

가변적인 상태를 공유하는 데서 오는 문제점을 해결하기 위한 가장 분명한 방법은 애초에 공유하지 않는 것이다.  

변경 가능 상태의 공유를 피하기 위해 가능한 또 다른 방법은 10장에서 설명한 테스트 더블을 사용하는 것이다.  

*전역 상태: 테스트 케이스 간 상태 공유가 테스트 코드를 통해서만 되는 것은 아니라는 점에 유의할 필요가 있다. 테스트 대상 코드가 전역 상태를 유지한다면 테스트 케이스마다 이 전역 상태를 확실하게 초기화해야 한다.*  

테스트 케이스 간에 가변적인 상태를 공유하는 것은 이상적이지 않다.  

피할 수 있다면 일반적으로 공유하지 않는 것이 바람직하다.  

피할 수 없다면 각 테스트 케이스 간에 상태를 초기화해야 한다.  

이를 통해 한 테스트 케이스가 다른 테스트 케이스에 악영향을 미치지 않도록 해야 한다. 

##### 설정 공유는 문제가 될 수 있다.  

테스트 케이스 간 설정을 공유하는 것은 상태를 공유하는 것만큼 위험해 보이지는 않지만 설정을 공유하면 테스트가 효과적이지 못할 때가 있다.  

설정을 공유하는 것은 코드의 반복을 피하는 데는 유용하지만 일반적으로 테스트 케이스에 중요한 값이나 상태는 공유하지 않는 것이 최선이다.  

설정을 공유하면 어떤 테스트 케이스가 어떤 특정 항목에 의존하는지 정확하게 추적하는 것은 매우 어려우며, 향후 변경 사항이 발생하면 테스트 케이스가 원래 목적했던 동작을 더 이상 테스트하지 않게 될 수 있다.  

##### 중요한 설정은 테스트 케이스 내에서 정의하라  

모든 테스트 케이스에 대해 반복해서 설정을 하는 것이 어려워 보일 수 있지만 테스트 케이스가 특정 값이나 설정 상태에 의존한다면 그렇게 하는 것이 더 안전한 경우가 많다.  

보통 헬퍼 함수를 사용해 이 작업을 좀 더 쉽게 할 수 있기 때문에 코드를 반복하지 않아도 된다.

테스트 케이스의 결과가 설정값에 직접 영향을 받는 경우 해당 테스트 케이스 내에서 설정하는 것이 가장 좋다.  

##### 설정 공유가 적절한 경우  

이전 하위 절에서는 테스틑 설정 공유를 주의해야 하는 이유를 설명했지만 그렇다고 테스트 설정을 절대 공유해서는 안된다는 의미는 아니다.  

필요하면서도 테스트 케이스의 결과에 직접적인 영향을 미치지 않는 설정이 있을 수 있다.  

오히려 이런 경우는 불필요한 코드 반복을 피하고 좀 더 뚜렷한 목적을 갖고 이해하기 쉬워진다.  

#### 적절한 어서션 확인자를 사용하라  

어서션 확인자는 보통 테스트 통과 여부를 최종적으로 결정하기 위한 테스트 케이스내의 코드이다.  

테스트 케이스가 실패하면 어서션 확인자는 실패 이유를 설명하는 메세지를 생성한다.  

각각의 어서션 확인자는 자신들의 목적에 따라 각자 다른 실패 메세지를 생성한다.  

테스트가 실패하는 경우 그 이유가 잘 설명되어야 하는 것은 단위 테스트가 갖는 주요 특징이다.  


##### 부적합한 확인자는 테스트 실패를 잘 설명하지 못할 수 있다.  

코드에 문제가 있을 때 테스트가 확실하게 통과되지 못하도록 하는 것은 필수적이지만, 이것만이 고려 사항의 전부는 아니다.  

코드에 정말로 문제가 있을 때에만 테스트가 실패하고 실패의 이유가 잘 설명돼야 한다.  

##### 적절한 확인자를 사용하라  

대부분의 최신 테스트 어서션 도구는 다양한 확인자를 무수히 많이 가지고 있다.  

리스트가 순서에 관련 없이 특정 항목을 포함하고 있는지 검증할 수 있는 확인자가 제공될 수도 있다.  

코드에 문제가 있을 때 테스트가 반드시 실패해야 한다는 점 외에도 테스트가 어떻게 실패할지에 대해 생각해보는 것도 중요하다.  

#### 테스트 용이성을 위해 의존성 주입을 사용하라 

앞선 장들에서 의존성 주입의 장점에 대해 알아봤는데 테스트의 용이성에서도 크게 향상된다는 장점이 있다.  

##### 하드 코딩된 의존성은 테스트를 불가능하게 할 수 있다.  

##### 의존성 주입을 사용하라  

테스트 용이성은 모듈화와 밀접한 관련이 있다.  

서로 다른 코드가 느슨하게 결합하고 재설정이 가능하면, 테스트는 훨씬 더 쉬워지는 경향을 띤다.  

의존성 주입은 코드를 좀더 모듈화하기 위한 효과적인 기술이며, 따라서 코드의 테스트 용이성을 높이기 위한 효과적인 기술이기도 하다.  

#### 테스트에 대한 몇 가지 결론  

소프트웨어 테스트는 방대한 주제이고 마지막 두 장에서 다룬 내용은 빙산의 일각에 불과하다.  

이 장에서는 개발자가 일상적으로 하는 작업에서 가장 자주 접하는 테스트 수준인 단위 테스트를 살펴봤다.  

* 통합 테스트(integration test)

한 시스템은 일반적으로 여러 구성 요소, 모듈, 하위 시스템으로 구성된다.  

이러한 구성 요소와 하위 시스템을 서로 연결하는 프로세스를 통합이라고 한다.  

통합 테스트는 이러한 통합이 제대로 작동하는지 확인하기 위한 테스트이다.  

* 종단 간 테스트(end-to-end test): 이 테스트는 처음부터 끝까지 전체 소프트웨어 시스템을 통과하는 여정(또는 작업 흐름)를 테스트한다.  

테스트하려는 소프트웨어가 온라인 쇼핑몰이라면, E2E 테스트의 예로는 웹 브라우저를 자동으로 구동하고 사용자가 구매를 완료하는 과정까지 거치면서 구매가 잘 이루어지는지 확인하는 것이다.  

여러 수준의 테스트 외에도 다양한 유형의 테스트가 있다.  

이들 테스트에 대한 정의는 서로 겹칠 때도 있고, 개발자들이 이들 테스트에 대해 언급할 때 의미하는 바가 항상 일치하는 것은 아니다.  

* 회귀 테스트(regression test): 소프트웨어의 동작이나 기능이 바람직하지 않은 방식으로 변경되지 않았는지 확인하기 위해 정기적으로 수행하는 테스트이다.  

* 골든 테스트(golden test): 특성화 테스트라고도 하며, 일반적으로 주어진 입력 집합에 대해 코드가 생성한 출력을 스냅샵으로 저장한 것을 기반으로 한다.  

테스트 수행 후 코드가 생성한 출력이 다르면 테스트는 실패한다.  

* 퍼즈 테스트(fuzz test): 퍼즈 테스트는 무작위 값이나 흥미로운 값으로 코드를 호출하고 그들 중 어느 것도 코드의 동작을 멈추지 않는지 점검한다.  

소프트웨어를 테스트하기 위해 개발자들이 사용할 수 있는 다양한 기술이 많다.  

소프트웨어를 높은 기준으로 작성하고 유지하려면 이러한 기술을 혼용해서 사용해야 하는 경우가 많다.  

단위 테스트가 가장 흔한 테스트 유형이지만, 단위 테스트만으로 테스트의 모든 요구 사항을 충족할 수 없기 때문에 다양한 테스트 유형과 수준에 대해 알아보고 새로운 툴과 기술에 대한 최신 정보를 유지하는 것이 좋다.  

### 느낀점 

10장과 마찬가지로 아직 테스트 코드의 대해서 미숙하다 보니 검색해보며 많이 찾아봤지만  

게임쪽에서 테스트 코드에 대한 정보가 많이 적은 것 같다.  

예제나 작성된 파일도 적어서 이해하기 많이 어려웠다.  

그래도 테스트 코드에 대한 기본적인 지식이 많이 채워진 느낌..  

나중에는 테스트 코드를 작성하는 방법에 대한 책을 읽고 싶다. 