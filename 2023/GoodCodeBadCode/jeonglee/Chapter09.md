## 9장 코드를 재사용하고 일반화할 수 있도록 하라  

> 간결한 추상화 계층을 만들고 코드를 모듈화하면 하위 문제의 해결책이 서로 느슨하게 결합하는 코드로 나뉘어지는 경향이 있다.  
> 이렇게 되면 보통 코드를 재사용하고 일반화하기 휠씬 더 쉽고 안전해진다.

### 논의사항

실제 대형 프로젝트에는 전혀 전역상태가 없는 것인지 궁금합니다.

흔히 말하는 싱글톤 == 안티패턴의 경우처럼 몇 백명이 모이면 확실히 없어야 안전하다는 생각은 들지만 진짜로 없는지 우회하거나 제한을 거는지 궁금합니다아

### 책의 내용 및 정리  

핵심 주제  

* 안전하게 재사용할 수 있는 코드 작성 방법
* 다양한 문제를 해결하기 위해 일반화된 코드를 작성하는 방법  

2장은 상위수준으 문제를 해결하기 위해 하위 문제로 세분화하는 방법에 대해 알아봤다.

프로젝트를 연이어 하다 보면 종종 동일한 하위문제들이 계속해서 나오는 것을 발견한다.  

다른 개발자가 이미 주어진 하위 문제를 해결했다면, 해당 문제에 대한 해결책을 재사용하는 것이 바람직 하다.  

그렇다고 해서 항상 재사용할 수 있는 것은 아니다.  

다른 개발자가 구현한 해결책이 자신의 사례와 맞지 않는 가정을 하거나, 그 해결책에 자신에게 필요 없는 다른 기능과 함께 구성된 경우 이러한 문제가 발생할 수 있다.  

#### 가정을 주의하라  

코드를 작성 시 가정을 하면 코드가 더 단순해지거나, 더 효율적으로 되거나, 둘 다일 수도 있다.  

그러나 이러한 가정으로 인해 코드가 더 취약해지고 활용도가 낮아져 재사용성하기에 안전하지 않을 수 있다.  

이러한 점을 고려할 때, 코드 작성 시 가정을 하기 전에 그 가정으로 초래될 비용과 이점을 생각해봐야 한다.  

코드 단순화 또는 효율성의 명백한 이득이 미미하다면 늘어난 취약성으로 인한 비영이 장점을 능가하기 때문에 가정을 하지 않는 것이 최선일 수 있다.  

범용적인 클래스를 만들고 싶어서 여러가지 가정을 하거나 예외를 생각하지 않고 짧고 간결하게 짜고 싶은 생각에서 오는 문제..

##### 가정은 코드 재사용 시 버그를 초래할 수 있다  

가정하여 상황에 맞게 코드를 제작하고 동작에 문제가 없었지만 코드를 재사용한다면 이야기가 달라진다.  

코드를 일반화, 재사용하기 위해선 낮은 수준의 추상적인 문제들로 구성되어야 안전하고 쉽다.  

하지만 예제와 같은 코드는 재사용하기 전에 문제가 발생하지 않았다고 해서 좋은 코드가 아니다.  

요구사항이 변경되거나, 다른 쪽에서 재사용될 때 발생할 수 있는 문제이다.  

##### 불필요한 가정을 피하라  

따라서 비용과 이익을 따져가며 가정을 하는 것 자체가 버그를 불러올 수 있다는 점을 알아야 한다.

**섣부른 최적화**  

섣부른 최적화를 피하려는 열망은 소프트웨어 공학과 컴퓨터 과학 내에서 잘 정립된 이론이다.  

최적화를 거듭할 수록 생산성은 떨어지고 생산성이 올라갈수록 최적화와 거리가 멀어진다.  

따라서 큰 효과가 없는 코드 최적화를 하느라 애쓰기보다는 코드를 읽을 수 있고, 유지보수 가능하며, 견고하게 만드는 데 집중하는 것이 좋다.

프로그램에 의심될 만한 깃발들을 세워두고 해당 기준이 넘거나 큰 효과를 볼 수 있을 때 최적화 작업을 해도 무방하다.  

##### 가정이 필요하면 강제적으로 하라  

때로는 가정이 필요하거나 가정으로 얻는 이득이 비용을 초과할 정도로 코드가 단순해질 수 있다.  

코드에 가정이 있을 때, 다른 개발자들이 그것을 여전히 모를 수 있다는 사실을 염두에 두어야 한다.  

그래서 우리가 상정한 가정으로 인해 다른 개발자들이 무의식중에 곤란을 겪지 않도록 하기 위해 가정을 강제적으로 시행해야 한다.  

* 가정이 '깨지지 않게' 만들라

가정이 깨지면 컴파일 되지 않는 방식으로 코드를 작성할 수 있다면 가정이 항상 유지될 수 있다.

* 오류 전달 기술을 사용하라  

가정이 깨는 것이 불가능하게 만들 수 없는 경우에는 오류를 감지하고 오류 전달 기술을 사용하여 신속하게 실패하도록 코드를 작성할 수 있다.  

#### 전역 상태를 주의하라  

전역변수는 프로그램 내의 모든 콘텍스트에 영향을 미치기 때문에 전역변수를 사용할 때는 누구도 해당 코드를 다른 목적으로 재사용하지 않을 것이라는 암묵적인 가정을 전제한다.  

이전 절에서 봤듯이 가정에는 비용이 수반된다.

전역 상태는 코드를 매우 취약하게 만들고 재사용하기도 안전하지 않기 때문에 일반적으로 이점보다 비용이 더 크다.  

##### 전역 상태를 갖는 코드는 재사용하기에 안전하지 않을 수 있다  

어떤 상태에 대해 프로그램의 여러 부분이 공유하고 접근할 필요가 있을 때 이것을 전역변수에 넣고 싶은 마음이 들 수 있다.  

이렇게 하면 코드의 어느 부분이라도 그 상태에 접근하기가 아주 쉽다.  

그러나 방금 언급했듯이 이렇게 하면 코드를 재사용하는 것이 안전하지 않을 수 있다.  

두개의 코드가 동일한 전역 상태를 읽고 수정한다면 의도하지 않은 결과를 초래한다..  

##### 공유 상태에 의존성 주입하라  

의존성 주입을 통한 객체의 공유는 같은 장바구니를 공유한다.  

이렇게 의존성 주입을 사용하여 공유한다면 재사용성 또한 올라간다.  

전역상태를 의존성주입 형태로 관리하는게 귀찮고 간편한 전역을 사용하고 싶어할 수 있다.  

그렇지만 재사용성 측면과 다른 개발자와 코드계약에 있어서 안전하지 않고 쉽게 사이드 이펙트를 유발한다.  

프로그램간의 서로 다른 상태를 공유해야 할 경우, 의존성 주입을 사용해 보다 통제된 방식으로 수행하는 것이 안전하다.  

읽으면서 다양한 생각을 해봤는데 게임의 경우 싱글톤을 사용하여 전체적인 게임을 관리하는 매니저를 자주 사용하게 된다.  

게임의 흐름을 관리하기 위해선 내 생각에 필수적인것 까진 아니더라도 퍼포먼스나 개발 속도에선 매우 좋은 방법이라고 생각한다.  

인디게임이나 적은 규모의 팀이라면 적극 사용할 것 이다.

물론 모든 공유를 매니저로 처리하는 것이 아닌 공유되는 인벤토리같은 기능은 위와 같은 방법을 사용하는 방법이 있다.  

책에서 말하는 것처럼 장점과 이점을 항상 생각하고 제한적으로 만든다면 입구나 출구를 하나로 둘 수 있기 때문에 관리에 더욱 용이해진다.  

#### 기본 반환값을 적잘하게 사용하라  

합리적인 기본값은 사용자 친화적인 소프트웨어를 만들기 위한 좋은 방법이다.  

워드의 예로 사용자의 편리를 위한 기본값은 유용하다. 생성자의 오버로딩, 선택적 매개변수의 예이다.  

기본값을 제공하려면 종종 다음과 같은 두 가지 가정이 필요하다.

* 어떤 기본값이 합리적인지
* 더 상위 계층의 코드는 기본값을 받든지 명시적으로 설정된 값을 받든지 상관하지 않는다.  

##### 낮은 층위의 코드의 기본 반환값은 재사용성을 해칠 수 있다.  

낮은 층위의 코드는 근본적인 하위 문제 해결에 더 많이 사용되고 따라서 상위 계층의 문제를 해결하기 위해 재사용될 가능성이 높다.  

즉, 하위 문제를 해결하기 위해 생각한 가정이 많은 상위 계층에 양향을 미친다.  

##### 상위 수준의 코드에서 기본값을 제공하라  

간단한 방법으로 하위 수준에서는 null을 반환하고 상위 수준에서 해결하는 것이다.  

기본값 또한 캡슐화 클래스로 만들어 의존성 주입을 통해 값을 가지고 있는다.  

상위 수준에서는 해당 값이 널이라면 기본값으로 만들어둔 캡슐화 클래스를 반환한다.  

C#의 ??를 사용하여 반환 값이 null이라면 디폴트 객체를 반환한다.  

#### 함수의 매개변수를 주목하라 

함수가 데이터 객체나 클래스 내에 포함된 모든 정보가 있어야 하는 경우에는 해당 함수가 객체나 클래스의 인스턴스를 매개변수로 받는 것이 타당하다.  

이렇게 하면 함수의 매개변수의 수가 줄어들고 캡슐화된 데이터의 자세한 세부 사항을 처리해야 하는 코드가 필요 없다.

그러나 함수가 한두 가지 정보만 필요로 할 때는 객체나 클래스의 인스턴스를 매개변수로 사용하는 것은 코드의 재사용성을 해칠 수 있다.  

##### 필요 이상으로 매개변수를 받는 함수는 재사용하기 어려울 수 있다.  

예제와 같이 필요 이상의 매개변수를 받게 되면 재사용하기 어려울 수 있음으로 해당 getter함수로 필요한 인자값만 넘기고 필요한 매개변수만 받으면 된다.  

#### 제네릭의 사용을 고려하라  

클래스는 종종 다른 유형 혹은 클래스의 인스턴스나 참조를 갖는다.  

대표적인 예로 리스트 클래스로 문자열과 정수를 저장하기 위한 완전히 다른 별개의 리스트 클래스를 가진다면 상당히 번거로울 것이다.  

*제네릭,템플릿*  

다른 클래스를 참조하는 코드를 작성하지만 그 클래스가 어떤 클래스인지 신경 쓰지 않는다면 제네릭의 사용을 고려해야 한다.  

제네릭을 사용하면 아주 적은 양의 추가 작업이 있긴 하지만 코드의 일반화가 크게 향상된다.

##### 특정 유형에 의존하면 일반화를 제한한다.  

RandomizedQueue클래스는 string에 대한 의존도가 높기 때문에 다른 유형을 저장하는 데는 사용하지 못한다.  

##### 제네릭을 사용해라  

예제에서 제공된 클래스는 제네릭을 도입하기 아주 쉬운 구조이다.  

하지만 만약 게임의 요구사항의 변경되어 문자열을 반환하기 전에 출제자의 난이도 또한 올려서 문자열에 단어 몇가지만 삭제된 상태로 반환된다고 한다면 제네릭은 사용할 수 없다.  

즉, 해당 자료형에 대한 성격이 확실하다면 도입하기 어렵고 제네릭 자체가 사용하기 어려운 것 같다.  

좀 더 생각해봐서 위의 경우처럼 삭제후 반환까지 제네릭을 도입한다면 RandomizedQueue클래스에 반환 전 삭제에 관련된 기능을 다루는 인터페이스를 의존성 주입 후 삭제 부분에서 다룬다면 9.21예제와 같이 사용도 가능하다..

### 느낀점

**가정**부분도 생각도 못하고 있던 부분이라 도움이 되었고  

공유를 다루기 위해 의존성 주입또한 고질적인 문제점을 해결하기 좋아보인다.  

++ 상위 계층에서 기본값을 처리하기도 굳굳