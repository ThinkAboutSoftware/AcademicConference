## 7장 코드를 오용하기 어렵게 만들라

> 비합리적이거나 애매한 가정에 기반해서 코드가 작성되거나 다른 개발자가 잘못된 일을 하는 것을 막지 못할 때 코드는 오용되기 쉽다.  

### 논의 사항

시간 부분에서 강력한 외부라이브러리에 대해 언급하는데 실제 회사 프로젝트에 외부 라이브러리가 많이 들어가나요?  

### 책의 내용 및 정리  

핵심 주제  

* 코드 오남용으로 인해 버그가 발생하는 방식
* 코드를 오용하기 쉬운 흔한 방식
* 코드를 오용하기 어렵게 만드는 기술  

코드를 잘못 사용할 수 있는 몇 가지 일반적인 경우는 다음과 같다.  

* 호출하는 쪽에서 잘못된 입력을 제공
* 다른 코드의 부수 효과(입력 매개변수 수정 등)
* 정확한 시간이나 순서에 따라 함수를 호출하지 않음
* 관련 코드에서 가정과 맞지 않게 수정이 이루어짐  

오용하기 어려움에 대한 일상적인 예제를 봤을 때 C#의 인터페이스, where키워드가 생각났다.  

앞서 다룬 예외의 부모예외로 잡아서 처리하는 것이 좋지 않는다는 맥락과 일치하는 것 같다.  

#### 불변 객체로 만드는 것을 고려하라  

객체가 생성된 후에 변경될 수 없다면 이 객체는 불변(불가변성)이다.  

불변성이 적합한 이유를 이해하기 위해선 그 반대인 가변객체의 문제를 생각해보면 된다.  

1. 설정함수를 같는 가변 클래스에서 어떻게 잘못된 설정이 쉽게 이루지는 문제
2. 입력 매개변수를 변경하는 함수가 어떻게 예상을 벗어나는 동작을 초래되는 문제
3. 가변 객체는 추론하기 어렵다.
4. 가변 객체는 다중 스레드에서 문제가 발생할 수 있다.

**가변 객체는 추론하기 어렵다.**

간단하게 배달음식의 봉인씰을 생각하면 된다.  

치킨을 시켰다면 치킨이 도착해야 하는 앞서 다룬 에제중에 비슷한 예가 있었는데 예측가능한 객체는 불변성을 가져야 한다.  

**가변 객체는 다중 스레드에서 문제가 발생할 수 있다.**

멀티 스레드에서 가장 많이 발생하는 문제라고 할 수 있다.  

*C#의 lock기능을 활용하면 좋지 않을까..?*

하지만 객체를 불변으로 만드는 것은 항상 가능하지 않고, 적절한 것도 아니다..  

필연적으로 만들어야 하는 상황이 오기 때문에 기본적으로 불변객체를 만들되 필요한 곳에서만 가변적으로 관리하는 것이 중요..  

##### 가변 클래스는 오용되기 쉽다  

클래스를 가변적으로 만드는 가장 일반적인 방법은 Setter함수를 제공하는 것이다.  

책에서는 TextOptions클래스의 문제점을 지적한다.  

다른 가변클래스에서 해당 setter함수에 접근하여 값을 변경하기 때문이다.  

처음에는 setter로 매핑해서 디버깅의 방어도 되고, 온전히 `messageBox.renderTitle()`메서드의 문제라고 생각했지만 책에서는 방어하지 못한 즉, 오용되게 만든 책임을 찾는다.  

멘토링에서 이 책에 대한 이야기를 잠깐 했는데 이 책은 정말 회사의 프로젝트, 큰 규모의 프로젝트를 기준으로 설명하기 때문에(이러한 기준으로 설명하는게 당연하지만..)관점을 다르게 해야한다는 이야기를 듣고나니 이해가 된다.  

##### 객체를 생성할 때만 값을 할당하라  

생성시에만 값을 할당하는 방법은 매우 유용하다..  

c#에서는 대부분 readonly키워드를 사용하여 값을 초기화하거나 프로퍼티를 get만 열어서 값을 열어둔다.  

하지만 어느 순간 재정의가 필요한 순간이 올 수 있는데 그땐, **빌더 패턴**이나 **쓰기 시 복사 패턴**을 사용하면 유용하다.

##### 불변성에 대한 디자인 패턴을 사용하라  

* 빌더 패턴  

가변 클래스는 오용하기 쉽기 때문에 불변의 객체를 만들기 위해 필드를 const, readonly로 둬서 생성시에만 초기화가 가능하도록 하는 것이 좋다.

빌더 패턴은 클래스를 두개로 나누어 빌더 클래스, 불변 클래스로 구분한다.

값을 설정하기 위한 빌더 클래스는 가변적이지만 빌더 클래스를 호출한 클래스의 인스턴스는 불변적 속성을 가진다.

[<mark style='background-color: #4F96F3'>구현 내용</mark>](https://fkdl0048.github.io/patterns/Patterns_Builder/)  

* 쓰기 시 복사 패턴  

이 패턴의 핵심은 앞서 다룬 `messageBox.renderTitle()`의 객체의 필드 값을 건드리기 때문에 애초에 새로운 불변 클래스를 생성하여 반환하는 것이다.  

애초에 생성 시 기본 생성자에선 필수로 필요한 필드만 초기화를 하고 가변되어 생성될 필드는 null 초기화한다.  

이후 메서드를 통해 사이즈나 폰트를 매개변수로 넘겨 새로운 객체를 반환하는 것  

원래 생성한 객체는 불변성을 유지할 수 있게 된다.  

#### 객체를 깊은 수준까지 불변적으로 만드는 것을 고려하라  

앞선 조언들을 따라서 불변성의 이점을 지키더라도 무심코 클래스가 가변적으로 될 수 있는 미묘한 경우를 간과하기 쉽다.  

이는 일반적으로 **깊은 가변성**때문이다.  

##### 깊은 가변성은 오용을 초래할 수 있다

예제에서 처럼 참조로 인한 깊은 가변성이 발생할 수 있다.  

TextOptions클래스는 참조를 가지고 있기 때문에 다른 코드에서 해당 참조를 가지고 있다면 변경에 따른 영향을 받을 수 있다.  

실제로 경험해본 문제라 찾기도 힘들었고 참조에 대한 문재점도 다시 생각해본 예제이다.  

두가지 시나리오지만 결국 동일한 참조를 가지고 있다는 점이 핵심이다.  

##### 방어적으로 복사하라  

동일한 참조를 가지는 것이 의도되었다면 유연한 기능이지만 이 처럼 오용될 수 있다면 치명적이다.  

따라서 얕은 복사가 아닌 깊은 복사를 통해 유일성을 확보한다.  

객체를 생성할 때 생성자로 리스트에 대한 참조를 받지만 생성 단계에서 copy하여 가지고 있고, getter을 통한 접근은 새로운 객체를 생성하여 반환한다.  

getter로 접근할 때 마다 새로운 객체가 생성되는 점에서 약간 위험할 수 있다는 생각이 든다..  

`readonly`라고 해서 불변성이 보장된다는 것이 아니라는것에 명심해야 한다.  

##### 불변적 자료구조를 사용하라  

앞서 말한 복사본을 생성하지 않아도 되는 경우가 자료구조 자체가 불변적이라면 객체자체를 전달할 수 있다.

따라서 불변적인 자료구조를 사용하는 것은 클래스가 깊은 불변성을 갖도록 보장하기 좋은 방법 중 하나다.  

#### 지나치게 일반적인 대이터 유형을 피해라  

정수, 문자열 및 리스트 같은 간단한 데이터 유형은 코드의 기본적인 구성 요소 중 하나다.  

쉽게 사용가능하고 다재다능하지만 정수나 리스트와 같은 유형으로 표현이 가능하다고 해서 그것이 반드시 좋은 방법이 아니다.  

설명이 부족하고 허용하는 범위가 넓을수록 코드 오용은 쉬워진다.  

##### 지나치게 일반적인 유형은 오용될 수 있다  

이 내용의 핵심은 앞 장에서 설명한 다른 개발자가 읽자마자 알수있어야 한다는 점이다.  

위치를 사용할 때 `List<int, int>`가 아닌 `Position`이라는 새로운 클래스나 구조체를 사용하는 것 처럼 오용되기 쉬운 일반적인 데이터를 피해야 한다.  

함수자체에서 문서나 명명된 인수를 사용할 수 있지만 좋은 방법은 아닌 것 같다..  

##### 페어 유형은 오용하기 어렵다  

페어 유형자체를 처음 봤다.  

튜플과 비슷한 것 같다..?  

내용의 핵심은 마찬가지로 문서가 필요하고 여전히 의미를 이해하기 어렵다는 점이다.  

##### 전용 유형 사용  

새로운 클래스나 구조체를 정의하는 것이 많은 노력이 들어가고 블필요해보일 수 있지만 보기보다 쉽고 버그의 가능성을 줄여준다.  

예제와 같이 위도와 경도를 나타내는 클래스를 정의하여 사용  

마찬가지로 같은 자료형이라고 Vector를 사용하거나, Position클래스를 다시 사용하는게 아닌 새로 정의하는 것이다.  

#### 시간 처리  

시간을 다룰 때 코드를 잘못 사용하고 혼동을 일으킬 여지가 굉장히 많다.  

* 절대적인 시간과 상대적인 시간의 표현법
* 시간의 양을 표현
* 표준시간대, 윤년등 다양한 시간 개념

##### 정수로 시간을 나타내는 것은 문제가 될 수 있다  

시간을 나타낼 때 일반적으로 정수나 큰 정수를 사용한다.  

이것으로 한순간을 의미하는 시각과 시간의 양을 표현한다.  

* 순간으로서의 시간은 유닉스 시간(unix epoch)인 1970년 1월 1일 00:00:00 UTC 이후 몇 초로 표현한느 경우가 많다.
* 양으로서의 시간은 초 혹은 밀리초 단위로 표시할 때가 많다.  

정수는 매우 일반적인 유형이기 때문에 시간을 나타내는 데 사용하는 경우 코드가 오용되기 쉽다.  

한순간의 시간인지, 아니면 시간의 양인가?  

책에서 보여주는 예처럼 매개변수로 시간을 전달할 때 해당 시간이 순간인지 양인지는 정수로 표현하면 알 수 없다.  

문서를 작성하는게 되면 세부조항이 늘어나고 좋은 방법이 아니다.  

코드에서 사용하는 초만 따져도 millisecond, second, microsecond와 같은 단위도 사용한다.  

함수이름이나 매개변수, 주석문으로 방어한다고 해도 여전히 코드를 오용하기 쉽다..  

**시간대 처리 오류**  

예제와 같이 같은 시간이라도 다른 표준 시간대로 설정한 경우에는 잘못된 값을 받을 수 있다.  

##### 적절한 자료구조를 사용하라  

우리가 알 수 있듯이 시간을 다루는 것은 복잡하고 까다로운 일이며 혼란의 여지가 많다.  

C#의 Noda..? [<mark style='background-color: #4F96F3'>관련 링크..</mark>](https://nodatime.org/)  

이러한 강력한 외부 라이브러리를 사용하여 알맞은 자료구조를 사용하면 나타내고자하는 바가 명백하다.  

물론 필요에 의해 제작할 수 있지만, 대부분 시간에 관한 내장라이브러리나 외부 라이브러리를 활용하자..  

#### 데이터에 대해 진실의 원천을 하나만 가져야 한다  

코드에서 숫자, 문자열, 바이트 스트림과 같은 종료의 데이터를 처리하는 경우가 많다.  

데이터는 종종 두 가지 형태로 제공된다.  

* 기본 데이터: 코드에 제공해야 할 데이터, 코드에 이 데이터를 알려주지 않고는 코드가 처리할 방법이 없다.  
* 파생 데이터: 주어진 기본 데이터에 기반해서 코드가 개선할 수 있는 데이터  

간단한 예제로 은행계좌시스템에 대변금액과 차변금액은 기본 데이터, 계좌 잔액은 파생데이터로 대변에서 차변을 뺀 금액이다.  

기본데이터는 프로그램의 **진실의 원천**이 된다.  

##### 또 다른 진실의 원천은 유효하지 않은 상태를 초래할 수 있다  

다른 예제로 `Vector3`라는 구조체가 x, y, z의 값을 들고 있을 때 x, y, z는 기본 데이터가 되고 이에 대한 방향 벡터를 구한다고 한다면  

기본데이터의 연산을 통해 구해야 정확할 것이다.  

하지만 해당 값을 매번 계산하는 것이 아닌 데이터에 담아두게 된다면 맞니 않는 값을 갖게 되고 이것이 두개의 진실의 원천을 같는 예이다.  

```cs
public float magnitude { get { return Mathf.Sqrt(x * x + y * y + z * z); } }
public MyVector normalized => new MyVector(x / magnitude, y / magnitude, z / magnitude);
```

*파생 데이터는 매번 계산하는 것이 바람직하다.*

##### 기본 데이터를 유일한 진실의 원천으로 사용하라  

예제와 같이 생성자로 불변성을 확보한 필드를 각각 계산하여 파생데이터를 반환한다.  

하지만 데이터의 계산에 비용이 많이 드는 경우에는 그 값을 지연계산한 후 결과를 캐싱하는 것이 좋다.  

동작과정이 Linq와 비슷하다는 생각이 들었다..  

Linq또한 값을 확인 할 때 동작한다고 알고 있는데 연관이 있는지 궁금하다..

마찬가지로 데이터가 불변적이 아니라면 더욱 복잡해지기 때문에 앞서 다룬 객체를 불변적으로 다뤄야 한다는 것 의미한다.  

#### 논리에 대한 진실의 원천을 하나만 가져야 한다  

진실의 원천은 코드에 제공된 데이터에만 해당되는 것이 아니라 코드에 포함된 논리에도 적용된다.  

##### 논리에 대한 진실의 원천이 여러개 있으면 버그를 유발할 수 있다

이런 경우가 있을지 모르겠지만 대규모 프로젝트의 경우에는 발생할 수 있는 문제인 것 같다..  

Json파일을 직렬화 역직렬화하는 과정에서 서로 다른 유틸리티를 사용하거나.. CSV를 통한 Read에서 다른 논리를 사용한다면 문제가 될 수 있다.

##### 진실의 원천은 단 하나만 있어야 한다  

예제와 같이 동일한 진실의 원천을 가질려면 동일한 클래스를 가지는 것이다.  

하위문제를 담당하는 클래스를 상위 수준 문제에서 동일한 로직으로 가지게 된다면 코드는 더욱 견고해진다.  

### 느낀점

코드를 오용하기 어렵게 만드는 방법을 읽고 느낀점은.. 어렵고 불편하게 만들어야 단단하고 가독성이 올라가는 것 같다.  

시작할 때 나온 말처럼 결국 가장 빠른길이 가장 느린길이였다는 생각이 드는 파트..  

다양한 방법들이 있지만 전부 명백해야 하고 어려운 구조를 가져야 한다.  

*유일성*  
