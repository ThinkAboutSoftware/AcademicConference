## 3. 모듈성

먼저, 모듈성(modularity)을 둘러싼 아키텍처 논쟁에서 자주 사용되는 용어들을 풀이하고 이 책 전체에서 계속 사용할 개념 몇 가지를 정의한다.  

> 소프트웨어 아키텍처 용어의 95%는 '모듈성'의 이로움을 찬양하는 데 사용되고 있지만, 정작 모듈성을 어떻게 달성할지에 대해서는 별다른 얘기가 없다.

플랫폼마다 제공하는 코드 재사용 메커니즘은 제각각이지만, 연관된 코드를 `모듈`로 묶는 방법은 모두 지원한다.  

하지만 모듈성은 쉽게 정의하기 어려운 개념이다.

본인이 선택한 개발 플랫폼에서 모듈성과 그것을 구현한 수많은 코드를 이해하는 것은 아키텍트에게 중요한 일이다.

아키텍처를 분석해야 할 매트릭, 피트니스, 시각화등 많은 도구가 바로 이 모듈성을 기반으로 하기 때문이다.  

모듈성을 잘 유지하는 건 우리가 암묵적 아키텍처 특성이라고 정의한 것의 좋은 예가 된다.

즉, 모듈이 확실히 구분되고 모듈 간 통신이 잘 되어야 한다고 공식적으로 아키텍트에게 요구하는 프로젝트는 드물지만, 코드베이스를 잘 발전시켜 나가려면 암묵적으로 질서와 일관성이 필요합니다.

### 3.1 정의

사전에서 모듈은 '복잡한 구조를 만드는 데 쓰이는 각각의 표준화한 부품이나 독립적인 단위'라고 나온다.  

우리는 모듈성을 이용해 객체 지향 언어의 클래스나 함수형 언어의 함수가 될 만한 서로 연돤된 코드를 논리적으로 묶는다.

프로그래밍 언어에서는 대부분 모듈성 메커니즘을 제공하며, 개발자는 보통 연관된 코드를 함께 묶는 수단으로 모듈을 사용한다.  

아키텍트는 개발자가 코드를 어떻게 패키징하는지 반드시 알아야 한다.  

아키텍처에 중요한 영향을 미치기 때문이다..  

여러 패키지가 서로 단단히 커플링되어 있으면 그 중 하나를 다른 작업에 재사용하기 아주 어렵다.

### 3.2 모듈성 측정

모듈성은 아키텍트에게 중요한 주제이므로 이것을 이해할 도구가 필요하다.  

아키텍트가 모듈성을 이해하는 데 도움이 될 만한 다양한 언어 독립적인 메트릭들을 선배들이 만어 놨다.  

여기서 세 가지 핵심 개념인 응집, 커플링, 커네이선스를 집중적으로 알아보자

#### 3.2.1 응집

응집(cohesion)은 한 모듈의 파트가 동일한 모듈 안에 얼마나 포함되어 있는지를 나타낸다.

즉, 모듈을 구성하는 파트가 서로 얼마나 연관되어 있는가, 라는 것이다.  

> 응집된 모듈을 나누려고 해봐야 더 커플링되고 가독성은 떨어진다.

응집도의 측정 범위를 정의했는데 가장 좋은 것부터 나쁜 순으로 나열한다.

1. 기능적 응집

모듈의 각 파트는 다른 파트와 연관되어 있고 가능상 꼭 필요한 모든 것이 모듈에 들어있다.

2. 순차적 응집

두 모듈이, 한쪽이 데이터를 출력하면 다른 한쪽이 그것을 입력받는 형태로 상호작용한다.

3. 소통적 응집

두 모듈이, 각자 정보에 따라 작동하고 어떤 출력을 내는 형태로 통신 체인을 형성한다.  
예를 들면, 데이터베이스에 레코드를 추가하면 그 정보에 따라 이메일이 만들어지는 식

4. 일시적 응집

모듈은 시점 의존성에 따라 연관된다.  

예를 들어, 많은 시스템들이 시동할 때 그다지 관련이 없어 보이는 것들을 초기화하는 경우가 많은데, 이런 작업들이 일시적으로 응집됐다고 할 수 있다.

5. 논리적 응집

모듈의 내부 데이터는 기능적이 아니라, 논리적으로 연관되어 있다.  

이를테면, 텍스트, 직렬화 객체, 스트림 형태로 받은 데이터를 변환하는 모듈이 그렇다.

6. 동시적 응집

같은 소스 파일에 모듈 구성 요소가 들어 있지만 그 외에는 아무 연관성도 없다.

이는 가장 좋지 않은 형태의 응집이다.

#### 3.2.2 커플링

코드베이스의 커플링은 그래프 이론에 기반한 좋은 분석 도구들이 많이 있다.

메서드의 호출과 반환은 호출 그래프를 형성하므로 수학적인 분석이 가능하다.

#### 3.2.3 추상도, 불안정도, 메인 시퀀스로부터의 거리

추상도는 추상 아티팩트와 구상 아티팩트의 비율, 즉 구현 대비 추상화 정도를 나타낸다.

가령 추상화를 전혀 하지 않고 하나의 엄청나게 큰 함수 코드가 있는 코드베이스도 있고, 반대로 너무 지나치게 추상화해서 코드가 서로 어떻게 연결되어 있는지 개발자가 파악하기 어려운 코드베이스도 있다.

#### 3.2.4 메인 시퀀스로부터의 거리

메인 시퀀스로부터의 거리는 아키텍처 구조를 평가하는 몇 가지 전체적인 메트릭 중 하나로, 불안정도와 추상도를 이용하여 계산한다.  

#### 3.2.5 커네이선스

> 두 컴포넌트 중 한쪽이 변경될 경우 다른 쪽도 변경해야 전체 시스템의 정합성이 맞는다면 이들은 커네이선스를 갖고 있는 것이다.

##### 정적 커네이선스  

소스 코드 레벨의 커플링으로, 구심/원심 커플링을 발전시킨 개념이다.  

다시 말해 아키텍트는 구심적이든, 원심적이든 다음 종류의 정적 커네이선스를 뭔가에 커플링된 정도라고 보는 것이다.

* 명칭 커네이선스

여러 컴포넌트의 엔티티명이 일치해야 한다.

메서드명은 코드베이스가 커플링되는 가장 일반적이면서 바람직한 방법이다.

특히, 최신 리팩터링 도구는 대부분 시스템 전체적으로 이름을 바꾸는 기능을 아주 잘 지원한다.

* 타입 커네이선스

여러 컴포넌트의 엔티티 타입이 일치해야 한다.

대부분의 정적 타입 언어에서 변수와 매개변수를 특정 타입으로 제한하는 일반적인 기능이다.

그러나 이것은 언어에 내장된 기능은 아니며, 클로저 또는 클로저 스팩등 선택적 타이핑 기능을 제공하는 동적타입 언어도 있다.

* 의미 커네이선스 또는 관례 커네이선스

여러 컴포넌트에 걸쳐 어떤 값의 의미가 일치해야 한다.

이런 종류의 커네이선스는 상수 대신 숫자를 하드코딩한 코드베이스에서 흔히 발견된다.

* 위치 커네이선스

여러 컴포넌트는 값의 순서가 일치해야 한다.

정적 타이핑이 가능한 언어에서도 메서드와 함수 호출 시 전달하는 매개변수 값은 순서가 맞아야 한다.

* 알고리즘 커네이선스

여러 컴포넌트는 특정 알고리즘이 일치해야 합니다.

흔한 예로, 서버/클라이언트 둘 다 실행되어야 하고 유저 인증 시 반드시 동일한 결과를 내야하는 보안 해시 알고리즘이 그렇다.

##### 동적 커네이선스

동적 커네이선스는 런타임 호출을 분석하는 또다른 유형의 커네이선스입니다.

* 실행 커네이선스

여러 컴포넌트의 실행 순서가 중요하다.

* 시점 커네이선스

여러 컴포넌트의 실행 시점이 중요하다.

* 값 커네이선스

상호 연관된 다수의 값들을 함께 변경할 때 발생한다.

*사각형의 한 꼭지점만 변경되는 경우*

* 식별 커네이선스

여러 컴포넌트가 동일한 엔티티를 참조할 때 발생한다.

##### 커네이선스 속성

커네이선스는 아키텍트와 개발자에게 유용한 분석도구이다.  

다음 프로퍼티를 잘 활용하면 개발자에게 도움이 된다.

* 강도

아키텍트는 개발자가 어떤 유형의 커네이선스를 얼마나 쉽게 리팩터링할 수 있는지에 따라 커네이선스 강도를 결정한다.

아키텍트와 개발자는 더 나은 유형의 커네이선스를 리팩터링해서 코드베이스의 커플링 특성을 개선할 수 있다.

* 지역성

커네이선스의 지역성은 코드베이스의 모듈들이 서로 얼마나 가까이 있는가, 입니다.

근접한 코드는 보통 더 분리된 코드보다 높은 형태의 커네이선스를 가진다.

즉, 모듈을 떨어뜨렸을 때 커플링이 형편없는 형태의 커네이선스는 모듈을 서로 가까이 붙여 놓는 식으로 개선할 수 있다.

개발자는 강도와 지역성을 함께 고민해야 한다.

동일한 모듈에서 더 강한 형태의 커네이선스가 발견된다면 그와 동일한 커네이선스가 널리 흩어져 있는 것보다 코드 스멜이 더하다는 증거다.

* 정도

커네이선스 정도는 커네이선스가 미치는 영향의 규모에 관한 것이다.

이 값이 작을수록 코드베이스 입장에서는 바람직하다.

모듈이 몇 개 안된다면 동적 커네이선스가 노아도 별로 해롭지 않지만, 일반적으로 코드베이스는 점점 커지기 마련이니 사소한 문제도 점점 더 악화될 것이다.

페이지-존스가 제안한 커네이선스를 활용해 시스템의 모듈성을 개선하는 세 가지 방법이다.

1. 시스템을 캡슐화한 요소들로 잘게 나누어 전체 커네이선스를 최소화한다.
2. 캡슐화 경계를 벗어나는 나머지 커네이선스를 모조리 최소화한다.
3. 캡슐화 경계 내부에서 커네이선스를 최대화한다.

정도의 규칙: 강한 형태의 커네이선스를 보다 약한 형태의 커네이선스로 전환하라

지역성의 규칙: 소프트웨어 엘리먼트간의 거리가 멀어질수록 보다 약한 형태의 커네이선스를 활용해라

#### 3.2.6 커플링과 커네이선스 메트릭을 통합

지금까지 우리는 시기와 목표가 상이한 커플링과 커네이선스를 이야기했다.

하지만 아키텍트 관점에서 이 두 가지 뷰가 서로 중첩된다.

### 3.3 모듈에서 컴포넌트로  

이 책에서는 연관된 코드의 묶음을 모듈이라고 일반 용어로 표현하지만 대부분의 프랫폼은 컴포넌트로 표현한다.  

### 느낀점

모듈성에 대한 내용과 아키텍트에 시점으로 잘 설명되었지만..... 어려운 수학내용이 있어서 읽기 힘들었따..

#### 논의사항

실제로 회사에서 작업을 할 때 메트릭을 다 시각화하는지... 궁금합니다..!
