## CHAPTER 6 아키텍처 특성의 측정 및 거버넌스

```
논의주제)
아키텍트 특성을 측정한다는 점에서 흥미로웠는데, 역시 서버나 데브옵스 하는 분은 운영적 측정, 그리고 클라이언트나 프론트엔드 하시는 분들은 구조적 특성을 더 생각해볼 것 같습니다. 저는 프로세스 측정을 할 수 있다는 점에서 테스트 코드와 커버리지 외에 버그/이슈 발생률로도 측정할 수 있다는 기본적인 사실에 다시 생각해 보게 됐습니다.

아키텍처 특성을 측정할 수 있다는 세 가지 포인트에서 어떤 부분이 눈에 더 들어왔는지 얘기해보면 좋겠습니다. 
```

### 6.1 아키텍처 특성 측정

아키텍처 특성을 정의할 때 발생하는 문제들

**물리학이 아니다**

의미가 모호하다. 민첩성이나 배포성을 위한 설계의 의미는 업계에서 바라보는 시각이 제각각이다.

**정의가 너무 다양하다**

성능 같은 중요한 특성에 대한 정의가 같은 조직에서도 부서마다 일치하지 않는다.

**너무 복합적이다**

아키텍처 특성은 대부분 더 작은 여러 특성들로 구성된다. 민첩성은 모듈성, 배포성, 시험성 등의 특성으로 세분화할 수 있다.

#### 6.1.1 운영적 측정

특정 요청에 대한 평균 응답 시간을 측정할 경우, 어떤 경계 조건으로 인해 1% 요청이 다른 요청보다 처리 시간이 10배나 오래 걸린다면? 사내 네트워크 리소스는 특이점이 나타나지 않을 수 있으므로 최대 응답 시간도 함께 측정해야 특이점을 잡아낼 수 있다.

**성능의 여러 가지 맛flavor**

> 대부분의 프로젝트는 성능에 대해서 일반적인 면만 살펴보지만, 아키텍트와 데브옵스 엔지니어는 성능 예산을 책정하는데 작업을 수행하고 최초 렌더링 시간에 대해 측정해서 운영팀의 경우는 섬세한 측정 체계를 구축한다.
그외 많은 회사들은 페이지 다운로드에 K-가중치 예산K-weight budget를 설정하는데, 한 번에 네트워크를 통해 이동할 수 있는 바이트 수는 제한적이라는 것에 기반하는 설정이다. 

수준 높은 팀은 달성하기 어려운 성능 수치를 정하는 대신, 통계 분석 결과로 얻은 나름대로의 정의에 기반한다.

아키텍처 특성은 빠르게 진화하고 있는데, 최초 콘텐츠 렌더링First Contentful Paint와 최초 CPU 유휴First CPU Idle 같은 메트릭에 성능 예산을 집중해서 모바일 기기로 접속한 유저의 성능 문제를 다룬다.

#### 6.1.2 구조적 측정

코드의 복잡도는 순환 복잡도cyclomatic complexity (CC)라는 메트릭을 통해 명쾌하게 측정할 수 있다.

**순환 복잡도**

> 1976년 토마스 맥케이브Thomas McCabe가 개발한 코드 레벨의 메트릭. CC는 코드에 그래프 이론을 적용하여 계산한다. 하나의 함수나 메서드에 CC를 구하는 공식은 CC = E - N + 2이다. N은 노드node(코드 라인), E는 간선edge(가능한 결정)이다. 가능한 결정인 간선의 개수는 if문의 조건분기로 판단하고 실행 경로가 두 갈래로 나오게 된다.

복잡도가 증가하면 코드 베이스를 장악하고 모듈성, 시험성, 배포성 등의 특성을 저해하는 요소이다.

**순환 복잡도는 어느 정도가 적당한가?**

> 도메인 자체의 복잡도를 고려하지 않을 경우, 일반적으로 10 이하의 CC는 괜찮다고 보는 것이 업계 기준이지만, 5 이하로 나와야 응집도가 괜찮은 짜임새 있는 코드가 된다.
테스트 주도 개발 같은 엔지니어링 프랙티스는 주어진 문제 영역에서 대체로 더 작고 덜 복잡한 메서드를 생성하는 긍정적인 효과를 가져온다. 구체적인 동작과 명확한 테스트 경계에 집중하면 짜임새 있고 고도로 응집된 메서드를 개발할 수 있으며 그 결과 CC 값도 낮게 나온다. 

#### 6.1.3 프로세스 측정

소프트웨어 개발 프로세스와 교차하는intersect 아키텍처 특성은 민첩성인데, 이는 시험성, 배포성 등의 특성으로 나눌 수 있는 복합적인 아키텍처 특성이다.

시험성은 테스트의 완전성을 평가하는 코드 커버리지 도구로 측정할 수 있고, 이는 객관적으로 측정할 수 있는 특성이다. 배포성 역시 실패 대비 배포 성공률, 소요 시간, 발생한 이슈/버그 등의 메트릭으로 측정할 수 있다.

배포 용이성과 시험성이 최우선 항목이라면 아키텍트는 모듈성, 격리성을 높이는 데 주력할 수 있다. 이는 아키텍처 특성이 구조를 주도하는 좋은 예이다.

### 6.2 거버넌스와 피트니스 함수

소프트웨어 프로젝트에서 긴급성urgency을 무시할 수는 없지만, 아키텍트는 거버넌스 메커니즘을 강구해야 한다. 

#### 6.2.1 아키텍처 특성 관리

아키텍처 거버넌스는 아키텍트가 영향력을 행사하려는 모든 소프트웨어 개발 프로세스를 포괄한다. 소프트웨어 품질 보장 업무는 아키텍처 범주 안에 속하므로 아키텍처 거버넌스 항목이다.

아키텍처 거버넌스의 여러 부분을 자동화하기 위해 사용하는 피트니스 기법이 <Building Evolutionary Architectures>에 소개 되어 있다.

```
check)
아쉽게도 이 책의 번역서는 없고 원서는 개정판이 최근에 나왔는데 가격이 무려 10만원에 달한다.
http://aladin.kr/p/fPbFk
```

#### 6.2.2 피트니스 함수

<Building Evolutionary Architectures> 책의 저자는 유전자 알고리즘의 도구를 비롯 진화적 컴퓨팅 분야에 오랫동안 연구를 한 사람이다. 개발자가 유전자 알고리즘을 설계하여 유익한 결과를 얻으려면 결과의 품질을 객관적으로 측정하면서 이 알고리즘을 통제할 수 있어야 한다. 이런 결과가 목표에 얼마나 근접했는지를 나타내는 목표 함수가 피트니스fitness function이다.

이 개념을 차용해 아키텍처 피트니스 함수architecture fitness function를 정의했다.

**아키텍처 피트니스 함수**

어떤 아키텍처 특성(또는 그런 특성들의 조합)의 객관적인 무셜성을 평가하는 모든 매커니즘

이 방식은 기존 도구들을 바라보는 새로운 시각이다. 사용하는 방법에 따라 메트릭, 모니터, 단위 테스트 라이브러리, 카오스 엔지니어링 등 기존의 많은 검증 매커니즘과 중첩되는 부분이 있다.

**순환 의존성**

컴포넌트 순환 참조가 일어나면 모듈성이 매우 떨어지고 컴포넌트 간에 커플링이 증가하므로 진흙잡탕 안티패턴에 빠져든다.
https://en.wikipedia.org/wiki/Anti-pattern#Software_engineering_anti-patterns

피트니스 함수를 통해 순환 참조 여부를 발견하고 문제를 해결할 수 있다. JDepend라는 메트릭 도구로 패키지 간 의존성을 체크하고, 순환 참조를 발견하면 테스트는 실패한다. 이 테스트를 프로젝트의 지속적 빌드의 일부로 세팅해서 순환참조의 발생을 사전에 예방할 수 있다.

**메인 시퀀스로부터의 거리' 피트니스 함수**

역시 JDepend로 수용 가능한 임계치를 설정하고 클래스가 이 범위를 벗어나면 테스트를 실패 처리한다.

이런 예제들은 아키텍처 특성을 객관적으로 측정하는 사례로, 피트니스 함수의 설계/구현 시 개발자, 아키텍트의 상호 협력이 얼마나 중요한지 나타낸다.

> 꿀팁) 아키텍트는 개발자에게 피트니스 함수 사용을 권하기 전에 그들이 정확한 목적을 이해할 수 있도록 충분히 설명해야 한다.

```
의견)
이건 꼭 피트니스 함수 뿐 아니라 어떤 사례나 프로세스를 적용할 때도 같은 방식을 써야 한다.
무지성으로 최신 유행이니까, 이게 좋다고 믿고 있고 내가 상사니까 그냥 해 라는 식은 결코 좋은 소프트웨어를 개발하는데 있어 
 어렵게 가는 방법이라고 본다.
```

ArchUnit(아크유닛)은 JUnit의 일부를 활용한 자바 테스트 프레임워크이다. ArchUnit은 단위 테스트로 코드화한 사전 정의된 거버넌스 규칙을 풍성하게 제공하므로, 아키텍트는 모듈성에 특화된 테스트를 작성할 수 있다.

개발자들은 아키텍처 근본을 침해하고 이후 조치를 취하지 않으면 장기적으로 아키텍처의 건정성을 해치게 된다.
(패턴의 중요성을 모르는 개발자 혹은 성능 관심사에 대해 무시하는 개발자)
이런 문제도 레이어 간의 올바른 관계를 정리하고 이를 실천하는 ArchUnit의 검증 피트니스 함수 코드를 통해 해결할 수 있다.

닷넷 진영에도 NetArchTest라는 도구가 있어서 활용할 수 있다.

넷플릭스의 카오스 멍키와 시미안 아미도 피트니스 함수의 응용 사례이다. 그 중 적합성confonity, 보안security, 문지기janitor 멍키는 피트니스 함수의 접근 방식을 잘 나타낸다.

**시미안 아미의 기원**

> 카오스 멍키는 일반적인 카오스를 프로덕션 환경에서 시뮬레이션하여 시스템이 얼마나 견딜 수 있는지 알아보는 것이다. 카오스 엔지니어링에 등장하는 이 프랙티스를 정착시켰고 시미안 아미simian Army로 발전했다.
카오스 엔지니어링은 아키텍처에 흥미롭고 신선한 관점을 제공한다. 무엇이 잘못될 것인지가 아니라 언제 그렇게 잘못될 것인지가 문제이므로 이런 장애와 테스트를 미리 대비하면 시스템이 더 견고해진다.

프로들이 아주 세부적인 일을 반복하면 간혹 빠뜨리고 지나치는 것들이 있으므로, 간결한 체크리스트는 효과적으로 기억을 되살려주는 역할을 한다. 피트니스 함수도 마찬가지로 무거운 거버넌스 메커니즘 보다는 아키텍트가 중요한 아키텍처 원칙을 표현하고 자동으로 검증할 수 있는 메커니즘을 제공한다.