## CHAPTER 8 컴포넌트 기반 사고

```
논의주제)
앞으로 설계 레벨을 클래스에서 컴포넌트 단위로 끌어올려야 겠다는 생각을 하게 됐고, 또 트레이드오프에 대해 많은 생각을 하게 해주면서도 예제가 좋아서 챕터 7과 비교해 재밌게 읽었습니다.

자기가 개발하고 있는 소프트웨어에서 도메인 혹은 레이어로 나눈 컴포넌트 설계를 한 부분이 있는지 생각해 보고 얘기해 보면 좋을 것 같습니다.

저는 작년에 서버 개발할 때 확실히 도메인 별로 개발하는 것이 마이크로서비스로 만드는데 좋다는 걸 경험했고, 도메인 별로 클래스의 묶음으로 진행했었습니다. 그런데 솔직히 공부하고 설계해서 만들었다기 보다는 예제나 프레임워크에서 제시된 대로 맞춰서 했다는 경향이 더 강한 것 같습니다.
```

모듈을 물리적으로 패키징한 것을 컴포넌트라고 하며, 자바 jar, 닷넷 dll, 루비 gem 파일처럼 대부분의 언어가 패키징을 지원한다.

### 8.1 컴포넌트 범위

개발자는 컴포넌트 개념을 다양한 팩터에 세분화하는 것이 유용하다.

컴포넌트는 아티팩트를 한데 묶어 필요시 중첩시켜 계층화하는, 언어에 특정한 매커니즘을 제공한다.
컴포넌트는 아키텍처에서 서브시스템이나 레이어 형태로도 나타나며, 많은 이벤트 프로세서를 위한 배포 가능한 작업 단위이다.
컴포넌트는 언어가 제공하는 저수준이 아닌, 더 높은 수준에서 모듈성을 가지는 것이 더 유용할 때가 많다.
컴포넌트는 아키텍처의 근본적인 모듈성을 구성하는 요소이다.

### 8.2 아키텍트 역할

아키텍트는 아키텍처 내부의 컴포넌트를 정의, 개선, 관리, 통제하는 일을 한다.
소프트웨어 개발팀이 사용 하는 것들을 다루는 것과 독립적으로 아키텍처는 개발 프로세스의 영향을 받지 않는다.
예외 사항으로 엔지니어링 프랙티스에서 배포 및 자동화 거버넌스 분야이다. 그 외에 일반적으로는 개발 프로세스와 분리되어 있으므로 요구사항의 출처에 영향을 받지 않는다.

```
의견)
아키텍처와 개발 프로세스가 별개인 것은
소프트웨어 공학에서 언급하는 요구사항 분석, 설계, 테스트, 유지보수에 대한 내용과
애자일 스프린트 개발 프로세스가 별개인 것에 대해 좋은 책들과 블로그 글을 통해 알고 있던 내용이기는 했다.
이 부분을 읽고 더 확실해졌다는 걸 알게 됐다. 
```

일반적으로 컴포너트는 아키텍트가 직접 맞닥뜨리는 최하위 소프트웨어 시스템이지만, 전체 코드베이스에 영향을 미치는 코드 품질 메트릭은 예외이다. 아키텍트는 특히 설계 패턴을 발견하여 적용할 때 클래스 설계에 참여해서도 안 되고 시스템의 세세한 설계 결정에 관여해서도 안된다. 다른 부서에서 중요한 결정을 내릴 수 있게 아키텍트가 허용해야 다음 아키텍트들에게 자율권을 부여할 수가 있게 된다.

#### 8.2.1 아키텍처 분할

소프트웨어 아키텍처 제1법칙에 따르면 소프트웨어는 만사가 다 트레이드오프이다.
최상위 분할top-level partitioning이라는 중요한 스타일을 이해해야 한다.

<img width="470" alt="image" src="https://user-images.githubusercontent.com/17442457/233059696-d0e9b981-3469-4283-b338-3328ff0db1d4.png">

모듈러 모놀리스modular monolith는 사이먼 브라운이 널리 보급한 아키텍처 스타일로, 기술적인 능력이 아닌 도메인에 따라 분할된 단일 배포 단위이다. 최상위 컴포넌트 내부에는 다른 컴포넌트들이 내장되어 있으므로 최상위 분할은 근본적인 아키텍처 스타일과 코드 분할 방법을 결정짓기 때문에 아키텍트에게는 특별한 관심사이다.

기술적 최상위 분할technical top-level partitioning은 레이어드 아키텍처와 같이 기술적인 능력에 따라 아키텍처를 구성하는 것이다.

<img width="480" alt="image" src="https://user-images.githubusercontent.com/17442457/233060374-e74d434e-afad-4726-813d-2c3abf0919ef.png">

기술 분할에서 예로 퍼시스턴스 코드가 어느 한 레이어에 있으면 개발자가 퍼시스턴스 관련 코드를 쉽게 찾을 수 있다. 이미 오래된 레이어드 아키텍처의 기본 개념은 MVC설계 패턴과 궁합이 잘 맞고 개발자가 이해하기 쉬워서 기본 아키텍처로 자리 잡았다.

이 레이어드 아키텍처는 흥미로운 부수 효과가 있는데, 레이어별 개발자가 한 곳에 모여 앉아서 마치 콘웨이의 법칙을 실현한 것 처럼 보인다.

**콘웨이의 법칙**

> 시스템을 설계하는 조직은 그 조직의 소통 구조를 그대로 옮겨 놓은 듯한 설계도를 그릴 수 밖에 없다.
사람들이 어떤 기술 아티팩트를 설계할 때는 결국 그들 간의 소통 구조가 설계 결과에 반영될 수밖에 없다는 뜻이다.
쏘우트웍스ThoughtWorks의 조니 리로이는 팀과 조직 구조를 함께 발전시켜 바람직한 아키텍처로 나아가기 위한 역 콘웨이 전략을 창안했다.

도메인 분할의 경우는 에릭 에반스의 <도메인 주도 설계>에서 시스템을 분리하는 모델링 기법을 참고한다. 서로 독립적으로 분리된 도메인 또는 워크플로를 식별하는데, 이는 마이크로서비스 아키텍처 스타일의 근본 사상이기도 하다. 여기서는 최상위 분할은 도메인을 중심으로 전개된다.

기술적 분할을 택한 아키텍트는 레이어 별로 기술적 능력에 따라 구성한다. 이 아키텍처의 구성 원칙은 기술 관심사의 분리separation of technical concerns로, 유용한 수준의 디커플링을 만든다. 시스템을 기술적으로 분할하여 구성하는 것은 분명 일리가 있고, 불가피한 트레이드오프는 고려해야 한다.

현실적으로 대부분 소프트웨어 시스템은 기술/기능을 넘나드는 워크플로를 필요로 한다.

<img width="482" alt="image" src="https://user-images.githubusercontent.com/17442457/233062442-44b4c35f-31eb-4589-8415-46e0cef8850f.png">

도메인 분할 아키텍처로 설계한 아키텍트는 워크플로 및 도메인을 중심으로 최상위 컴포넌트를 구축한다.

두 스타일 모두 어느 것이 더 낫다고 단정지을 수 없다. 최상위 분할을 어떻게 할 것인지는 아키텍트가 가장 먼저 결정해야 할 문제 중 하나이다.

#### 8.2.2 분할 사례 연구: 실리콘 샌드위치

실리콘 샌드위치를 도메인 분할 방식으로 설계한 그림

<img width="460" alt="image" src="https://user-images.githubusercontent.com/17442457/233063073-b033f13d-634c-4075-9a73-850dfcba6455.png">

공통 및 로컬 파트를 각 파티션으로 분리한 설계, 즉 기술적 분할 방식으로 설계한 그림

<img width="468" alt="image" src="https://user-images.githubusercontent.com/17442457/233063327-ba52c03b-12b2-4af1-b48a-3ec6588de774.png">

어느 설계가 더 나은지 아직도 고민인가? 경우에 따라 다르므로 분할하는 방식마다 일장일단이 있다.

**도메인 분할**

최상위 컴포넌트를 워크플로 및 도메인에 따라 나눈다.

장점

- 세부 구현보다 비즈니스 기능에 더 가깝게 모델링된다.
- 역 콘웨이 전략을 활용하여 도메인 별 다목적팀cross-functional team을 구성하기 쉽다
- 모듈러 모놀리스와 마이크로서비스 아키텍처 스타일에 더 가깝게 맞출 수 있다.
- 메시지의 흐름이 문제 영역과 일치한다
- 데이터와 컴포넌트를 분산 아키텍처로 옮기기 쉽다

단점

- 유저 정의 코드가 여기저기 널려 있다

**기술 분할**

MVC 또는 상황에 맞게 기술 분할된 레이어로 나타낼 수 있다.

장점

- 커스텀 코드가 명확하게 분리된다
- 레이어드 아키텍처 패턴에 더 가깝게 맞출 수 있다

단점

- 전역 커플링global coupling이 더 높다. 컴포넌트 중 하나가 변경되면 다른 컴포넌트가 영향을 받는다
- 개발자가 공통 레이어, 로컬 레이어 양쪽에 도메인 개념을 복제해야 할 수 있다.
- 데이터 레벨의 커플링이 높다. 나중에 분산 시스템으로 아키텍처를 옮기려고 할 경우 데이터 관계를 파헤치는 작업이 어렵다.

### 8.3 개발자 역할

일반적으로 클래스, 함수 설계는 아키텍트, 기술 리더, 개발자의 공동 책임이지만 대부분 개발자가 담당한다.

모든 소프트웨어 설계는 이터레이션을 거쳐 점점 다듬어지게 되므로 초기 설계는 초안으로 생각하고 이후 구현하면서 상세한 것들을 밝히고 하나씩 개선을 해 나가야 한다.

### 8.4 컴포넌트 식별 흐름

컴포넌트 식별 역시 후보를 도출하고 피드백을 통해 다듬어 가는 과정을 반복하는 것이 좋다.

<img width="460" alt="image" src="https://user-images.githubusercontent.com/17442457/233064983-e767874f-c4c4-4bfa-a5b3-4fb9ece316e8.png">

도메인에 따라 이런 프로세스에 단계가 추가되거나 전체적으로 다 바뀌는 경우도 있다.

#### 8.4.1 초기 컴포넌트 식별

아키텍트는 소프트웨어 프로젝트의 소스 코드가 생기기 전에 적용할 최상위 분할의 유형에 따라 최상위 컴포넌트를 어디서부터 시작할지 결정해야 한다. 초기 식별한 컴포넌트들만으로 제대로 된 설계가 나올 가능성은 거의 없으므로 아키텍트는 컴포넌트 설계를 이터레이션하면서 조금씩 개선해야 한다.

#### 8.4.2 요구사항을 컴포넌트에 할당

아키텍트는 요구사항(또는 유저 스토리)을 대입해서 맞는지 확인한다. 매핑이 정확할 필요는 없다. 앞으로 설계를 계속 보완할 수 있도록 큼지막한 단위의 기반coarse-grained substrate를 찾으려고 노력하면 된다.

#### 8.4.3 역할 및 책임 분석

아키텍트는 요구사항을 파악하는 단계에서 밝혀진 역할과 책임도 살펴보고 세분도granularity가 적합한지 확인한다. 컴포넌트의 세분도를 정확히 짚어내는 건 어려운 일이므로 더욱 이터레이션 과정이 필요하다.

#### 8.4.4 아키텍처 특성 분석

아키텍처의 특성들이 컴포넌트 분할 및 세분도에 어떤 영향일 미치는지 살펴봐야 한다. 기능적인 관점에서 컴포넌트를 설계하면 단일 컴포넌트가 도출되지만 아키텍처 특성을 분석하면 더 하위 컴포넌트로 잘게 나눌 수 있다.

#### 8.4.5 컴포넌트 재구성

소프트웨어 설계에서 피드백은 항상 중요하므로, 아키텍트는 개발자들과 함께 지속적으로 컴포넌트 설계를 반복해야 한다. 향후  어떻게 변경될지 알 수 없으므로 컴포넌트 설계를 반복하는 접근 방식이 정말 중요하다.

- 재설계를 포함하여 특이 사례를 전부 다 고려하기란 사실상 불가능하다.
- 아키텍처와 개발자는 애플리케이션 구축에 시간을 보낼 수록 서로의 기능과 역할을 어떻게 조정하면 좋을지 서로 다른 시각으로 보게 된다.

```
의견)
내가 멘토링 해줄때 항상 요구사항과 코드의 일치성을 서로 보완하면서 수정을 진행해야 하고,
필요할 때 마다 지속적으로 서로 보완 수정을 반복해서
최종 버전을 만드는 과정을 거쳐야 한다고 얘기해 주는데 여기서 비슷한 맥락의 내용이 나와서 좋은 것 같다.
```

### 8.5 컴포넌트 세분도

적당한 세분도를 찾는 건 어렵다. 컴포넌트를 너무 잘게 나누면 컴포넌트 간 통신이 많아지고, 너무 크게 나누면 내부적으로 커플링이 증가해서 모듈성 관점에서 부정적인 영향을 미친다.

### 8.6 컴포넌트 설계

왕도는 없다. 아키텍트는 아키텍처를 설계하면서 요구사항을 접수하고 애플리케이션의 구성 요소를 그려봐야 한다.

#### 8.6.1 컴포넌트 발견

초기 설계를 할 때의 목표는 아키텍처 특성을 고려하여 문제 영역을 큼지막한 덩어리로 나누는 것이다.

**엔티티 함정**

아키텍트가 다음 그림 처럼 요구사항에서 식별된 각각의 엔티티를 바탕으로 관리자 컴포넌트를 만들었지만 이건 아키텍처가 아니다. 프레임워크를 데이터베이스에 컴포넌트 관계형component-relational으로 매핑한 것에 불과하다.

이 안티패턴은 애플리케이션의 실제 워크플로에 관한 지식이 얼마나 부족한지 나타낸다. 엔티티 함정에 빠져 생성된 컴포넌트는 개발팀에게 지침이 될 만한 것이 하나도 없다.

<img width="470" alt="image" src="https://user-images.githubusercontent.com/17442457/233067755-465a768b-aa21-4397-ab22-0b2b2a902d15.png">

**네이키드 오브젝트와 유사 프레임워크**

> 단순 CRUD 애플리케이션을 기계적으로 생성하는 프레임워크 중에 대표적인 것이 네이키드 오브젝트Naked Objects이다. 이 프레임워크의 기본 사상은 데이터베이스 엔티티에 유저 인터페이스 프런트엔드를 제공하는 것이다.
아키텍트 니즈가 단지 데이터베이스를 유저 인터페이스로 매핑하는 것이라면 이런 프레임워크로도 충분하며 완전한 기능을 갖춘full-blown 아키텍처까지는 필요 없다.

**액터/액션 접근법**

액터/액션 접근법actor/actions approach은 래셔널 통합 프로세스Rational Unified Process(RUP)에 정의된 것으로 액터와 그 액션을 식별하고 시스템의 유저와 이들이 시스템의 어떤 종류의 일을 하는지 찾아내는 기법이다.

이 방법은 요구사항 측면에서 역할이 분명하고 그들이 수행하는 액션의 종류가 확실한 경우에 잘 작동하며 아직도 많이 쓰인다.

**이벤트 스토밍**

이벤트 스토밍event storming은 도메인 주도 설계에서 사용하는 컴포넌트 발견 기법이다. 요구사항과 식별된 역할에 따라 시스템에서 어떤 이벤트가 일어나는지 파악하고 컴포넌트를 이벤트와 메시지 핸들러 중심으로 구축한다. 이벤트와 메시지를 사용하는 마이크로서비스 같은 분산 아키텍처에서 주효하다.

**워크플로 접근법**

워크플로 접근법workflow approach은 이벤트 스토밍의 대안으로 DDD나 메시징을 사용하지 않는 더 일반화한 방법이다. 워크플로 접근법은 핵심 역할을 식별하고 이 역할이 관여하는 워크플로 유형을 결정하며 그렇게 식별된 활동에 따라 컴포는트를 구축한다.

여태까지 살펴본 기법 역시 다 일장일단이 있으므로 어떤 것이 더 우월하다고 할 수 없다.

### 8.7 컴포넌트 발굴 사례 연구: GGG

팀에 특별한 제약이 없고 범용적인 컴포넌트 분할을 고려하고 있다면 액터/액션 접근법이 일반적으로 괜찮은 솔루션이다.
GGG 역시 입찰자bidder, 경매인auctioneer, 내부 액션을 수행하기 위한 시스템system 이렇게 3개의 역할을 분명히 식별할 수 있다.
역할 별 초기 액션 세트는 다음과 같이 정리할 수 있다.

- Bidder: 비디오 스트림, 입찰 스트림, 입찰 참여
- Auctioneer: 온라인 입찰을 시스템 입력, 온라인 입찰 수신, 판매 완료된 아이템 표시
- System: 경매 시작, 대금 결제, 입찰자 활동 추적, 경매 종료

<img width="474" alt="image" src="https://user-images.githubusercontent.com/17442457/233071447-4569caca-b154-4004-b761-816a6e325f4f.png">

솔루션에 맞게 식별한 컴포넌트들의 역할

- VideoStreamer: 라이브 경매 스트림
- BidStreamer: 입찰 진행시 스트림
- BidCapture: 입찰 캡쳐
- BidTracker: 입찰 추척
- AuctionSession: 경매 세션 시작/종료, 경매 종료 후 결과를 입찰자에게 알림
- Payment: 신용카드 결제 처리 서드파티 결제 프로세서

입찰자의 경우는 수천명 단위로 증가하는 처리가 필요하므로 확장성, 탄력성과 같은 아키텍처 특성이 필요하다.
또 경매인에 관한 신뢰성(접속이 끊어지면 안됨)과 가용성(시스템이 가동중이어야 함) 같은 아키텍처 특성을 다른 시스템 파트보다 높게 보장해야 한다.
필요한 아키텍처 특성의 수준이 다르므로 BidCapture를 BidCapture와 AuctioneerCapture 두 컴포넌트로 나누고 다른 수준의 아키텍처 특성을 지원하는게 좋다.

<img width="488" alt="image" src="https://user-images.githubusercontent.com/17442457/233072405-9610442b-b3b3-45da-942b-32931c61eb52.png">

컴포넌트 분리를 한 컴포넌트 배치 그림 역시 최종 설계안이 아니고 더 많은 요구사항을 밝혀내야 하므로 향후 이터레이션을 진행하기에 좋은 출발점이 될 것이다.

어차피 정답은 하나만 있는 게 아니므로 정확하지 않아도 된다. 개발자가 구현하는 방법이 유일한 소프트웨어 시스템은 없다. 모든 설계는 서로 다른 트레이드오프 조합이 반드시 뒤따른다. 요구사항을 충족하는 설계안은 무수히 많이 나오므로 아키텍트는 하나의 진짜 설계를 발견하느라 집착해서는 안 된다. 트레이드오프를 객관적으로 판단하고 트레이드오프가 나쁜 것 중에서 제일 나은 것을 선택하도록 노력해야 한다.

```
의견)
트레이드오프는 객체지향 설계, 지금 생각해 보면 설계라는 용어를 언급하는 책에서는 많이 언급되는 내용이라고 본다.
내가 생각한 중요한 자세는 설계한 내용이 실제 구현 내용에 적합하지 않다면
변경을 하고 계속해서 더 나은 설계 구조와 그 코드 베이스를 가져가는게 좋다는 것이다.
(물론 설계 자체를 안하고 코드만 작성하는 건 논외이다)
```

### 8.8 아키텍처 퀀텀 딜레마: 모놀리식이냐, 분산 아키텍처냐

아키텍처 스타일은 다양한 트레이드오프가 있다. 근본적인 결정은 설계 프로세스 중에 식별된 아키텍처 퀀텀 수에 좌우된다. 즉 단일 퀀텀(한 세트의 아키텍처 특성)만으로 가능하다면 모놀리스 아키텍처가 장점이 더 많다.  반면 컴포넌트마다 아키텍처 특성이 달라지는 경우에는 이를 수용할 수 있는 분산 아키텍처가 필요하다. GGG의 VideoStreamer와 BidStreamer는 읽기 전용과 대용량 업데이트에 대한 다른 아키텍처 특성으로 분리되므로 분산 아키텍처를 선택하는게 좋다.

아키텍처 퀀텀을 활용하면 초기 설계 단계에서 아키텍처의 근본적인 설계 특성인 모놀리스 혹은 분산을 결정할 수 있으므로 아키텍처 특성의 범위와 커플링을 분석하는 방법으로서 장점이 부각된다.