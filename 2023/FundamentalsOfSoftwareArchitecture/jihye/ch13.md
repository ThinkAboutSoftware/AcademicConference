# 13장, 서비스 기반 아키텍처 스타일
서비스 기반 아키텍처(service-based architecture)는 마이크로서비스 아키텍처 스타일의 일종으로, 아키텍처가 유연해서 가장 실용적인 아키텍처 스타일 중 하나이다. 마이크로서비스나 이벤트 기반 아키텍처와 마찬가지로 분산 아키텍처지만 비교적 덜 복잡하고 비용이 많이 들지 않아서 많은 비지니스 관련 애플리케이션에 널리 채택된 아키텍처이다.

## 13.1 토폴로지
- 서비스 기반 아키텍처의 기본 토폴로지는 각각 따로 배포된 유저 인터페이스와 원격 서비스, 그리고 모놀리스 데이터베이스로 이루어진 대규모 분산 레이어 구조이다.
- 이 아키텍처 스타일에서 서비스는 큼지막한 단위로 분리해 별도로 배포하는 애플리케이션의 일부이다(보통 도메인 서비스라고함). 여러 서비스가 단일 모놀리식 데이터베이스를 공유하므로 애플리케이션 서비스는 다 합해도 4~12개, 평균 7개 정도이다.

## 13.2 토폴로지 변형
- 서비스 기반 아키텍처 스타일은 특유의 유연성 때문에 정말 다양한 변형이 존재한다. 단일 모놀리식 유저 인터페이스는 다시 여러 유저 인터페이스 도메인으로 나눌 수 있고, 한술 더 떠 각 도메인 서비스에 맞게 나눌 수도 있다.
- 또, 단일 모놀리식 데이터베이스 역시 개별 데이터베이스로 분리할 수 있고 (마이크로서비스 비슷하게) 각 도메인 서비스 전용 데이터베이스들로 쪼갤 수도 있다.

## 13.3 서비스 설계 및 세분도
- 서비스 기반 아키텍처의 도메인 서비스는 보통 단위가 크기 때문에 도메인 서비스를 API 퍼사드 레이어, 비지니스 레이어, 퍼시스턴스 레이어로 구성된 레이어드 아키텍처 스타일로 설계하는 것이 일반적이다. 모듈러 모놀리스 아키텍처 스타일처럼 서브도메인을 이용해서 각 도메인 서비스를 분할하는 방법도 많이 쓰인다.

## 13.4 데이터베이스 분할
- 서비스 기반 아키텍처에서 데이터베이스 테이블 스키마를 나타낸 공유 클래스 파일(엔티티 객체라고 함)은 전체 도메인 서비스가 함 사용하는 커스텀 공유 라이브러리에 둔다. 엔티티 객체가 공유하는 단일 라이브러리를 생성하께 프랙티스는 서비스 기반 아키텍처 관점에서 가장 비효율적인 구현 방법이다. 테이블 구조를 조금이라도 변경할 일이 발생하면 해당 엔티티 객체가 포함된 단일 공유 라이브러리도 같이 변경을 해야 하는데, 변경된 테이블의 사용 여부와 상관없이 전체 서비스를 일제히 변경 후 재배포할 수 밖에 없다.

## 13.7 언제 이 아키텍처 스타일을 사용하는가
- 서비스 기반 아키텍처는 도메인 주도 설계와 궁합이 잘 맞다. 서비스를 큰 단위로 나누고 그 범위를 도메인으로 한정하기 때문에 각 도메인은 개별 배포된 도메인 서비스에 딱 맞아 떨어지는 것이다. 서비스 기반 아키텍처의 서비스는 각각 지정된 도메인을 포함하므로 그 기능을 단일 소프트웨어 단위로 구분하면 해당 도메인을 더 쉽게 변경할 수 있다.
- 서비스 기반 아키텍처는 복잡하게 뒤얽히거나 세분도의 함정에 빠져 허우적거리지 않고도 아키텍처 모듈성을 괜찮을 수준으로 달성할 수 있다. 서비스를 더 잘게 나눌수록 오케스트레이션 및 코레오그래피 관련 이슈가 발생하기 시작하는데, 여러 서비스를 조율해서 비지니스 트랜잭션을 완성하려면 오케스트레이션과 코레오그래피 둘다 필요하다.
    - 오케스트레이션 : 트랜잭션의 워크플로를 제어/관리하는 중재자 서비스를 따로 두고 여러 서비스를 조율하는 기법. (오케스트라의 지휘자 같은)
    - 코레오그래피 : 각 서비스가 중앙의 중재자 없이 서로가 알아서 소통하는 방식. (무대에서 춤추는 댄서들처럼)
- 서비스가 더 잘게 쪼개지면 비지니스 트랜잭션을 완성하기 위해 서비스를 서로 단단히 묶어주는 오케스트레이션과 코레오그래피가 필요하다. 그러나 서비스 기반 아키텍처의 서비스는 더 큰 단위로 나뉘어지는 편이라서 다른 분산 아키텍처만큼 정교한 조율은 필요하지 않다.

### 느낀 점
- 이 챕터를 설명하면서 계속 트레이드오프와 적절한 선택에 대해 강조한다.트레이드오프를 고려하지 않고 특정 기술/개념에만 빠져버리는 잘못된 길을 가지 않도록 항상 유념해야겠다. 