## 17. 마이크로서비스 아키텍처 스타일

> 마이크로서비스는 최근 엄청난 탄력을 받고 있는, 아주 평판이 좋은 아키텍처 스타일이다.  
> 이 장에선 토폴로지와 철학, 두 가지 관점으로 나누어 이 아키텍처의 중요한 특성을 개괄한다.

### 17.1. 역사

마틴 파울러와 제임스 루이스가 쓴 `Microservices`라는 유명 블로그 게시글 덕분에 널리 퍼지게 되었다.

마이크로서비스는 소프트웨어 프로젝트의 논리적 설계 프로세스를 강조한 도메인 주도 설계(Domain-Driven Design, DDD)의 영향을 받았다.

특히, 디 커플링 스타일을 나타낸 경계 콘텍스트 개념은 마이크로서비스에 결정적인 영향을 미쳤다.

재사용은 유익하지만 커플링이 문제이다 (소프트웨어 아키텍처 제1법칙)

재사용을 선호하는 시스템을 설계하다 보면 결국 상속이나 조합을 이용하여 재사용하기 때문에 커플링이 발생한다.

그러나 고도의 디커플링이 아키텍트의 목표라면 재사용보다 중복을 우선할 것이다.

마이크로서비스의 주요 목표는 경계 콘텍스트의 논리적 개념을 물리적으로 모델링하는 고도의 디커플링이다.

### 17.2. 토폴로지

다른 분산 아키텍처에 비해 단일 목적만을 가지기 때문에 규모가 작다.

실제로 각 서비스에는 데이터베이스 및 기타 종속적인 컴포넌트 등 서비스가 독립적으로 작동되는데 필요한 모든 것이 준비되어 있다.

### 17.3. 분산

마이크로서비스는 분산 아키텍처를 형성한다.

빠르게 진화하며 물리적인 컴퓨터에서 컨테이너를 사용하게 되고 자주 발생하는 문제들을 해결할 수 있게 되었다.

### 17.4. 경계 콘텍스트

마이크로서비스의 근본 철학은 경게 콘텍스트 개념이다.

서비스마다 도메인이나 워크플로를 모델링하는 개념..!

*마이크로서비스는 커플링을 가급적 삼가므로 이 아키텍처 스타일을 구축하는 아키텍트는 커플링보다는 차리리 중복이 낫다고 생각합니다.*

#### 17.4.1. 세분도

> '마이크로서비스'라는 용어는 명칭이지, 명세가 아니다.  
> 마틴 파울러

**목적**: 가장 확실한 경계는 바로 이 아키텍처 스타일의 본래 의도인 도메인이다.
**트랜잭션**: 여러 엔티티가 함께 개입하여 작동되는 트랜잭션은 아키텍트에게 좋은 서비스 경계 후보입니다.  
**코레오그래피**: 도메인 격리는 아주 잘 되어 있지만, 서로 광범위한 통신을 해야 제대로 작동되는 서비스 세트를 구축할 경우, 아키텍트는 통신 오버헤드를 줄이기 위해 더 큰 서비스로 다시 뭉치는 것을 고려해야 할 수도 있다.

좋은 서비스 설계안을 도출하는 유일한 방법은 이터레이션이다.

반복..!

#### 17.4.2. 데이터 격리

마이크로서비스는 경계 콘텍스트를 기준으로 데이터를 격리해야 한다.

대부분의 다른 아키텍처는 데이터를 단일 데이터베이스에 저장하지만, 마이크로서비스 아키텍처는 통합 지점으로 사용되는 공유 스키마, 데이터베이스 등 모든 종류의 커플링을 없애려고 한다.

#### 17.5. API 레이어

마이크로서비스 다이어그램을 보면 대부분 필수는 아니지만 여러 시스템 컨슈머 사이에 API 레이어가 있다.

API레이어는 다양한 용도로 활용될 수 있지만 이 아키텍처의 기본 철학에 충실하려면 API레이어를 중재자나 오케스트레이션 도구로 사용하지 말아야 한다.

모든 비즈니스 로직은 경계 콘텍스트 내부에서 일어나야 하며, 오케스트레이션 등의 다른 로직을 중재자에 넣는 것은 규칙 위반이다.

#### 17.6. 운영 재사용

앞서 마이크로서비스가 커플링보다 복제를 선호한다고 했다.

전통적인 서비스 지향 아키텍처 철학에 따르면 도메인이든 운영이든 가급적 많은 기능을 재사용하는 것이 좋다.

- 사이드카 패턴
  - 팀이 서로 커플링되면 더 유리한 모든 운영 관심사를 도맡아 처리한다.
  - 각 마이크로서비스는 신기능을 받아 사용할 수 있다.

#### 17.7. 프런트엔드

마이크로서비스는 디커플링을 선호한다.

유저 인터페이스와 백엔드 역시 분리되는 모습이 가장 좋다..!

마이크로 아키텍처의 유저 인터페이스는 보통 두 가지 스타일로 나뉜다.

- 모놀리식 프론트엔드
  - 리치 테스크톱, 모바일, 웹 애플리케이션의 형태로 구현한다.
- 마이크로 프론트엔드
  - 유저 인터페이스 레벨의 컴포넌트를 백엔드 서비스로 활용하여 유저 인터페이스를 동기적인 수준으로 세분화하고 격리한다.

#### 17.8. 통신

마이크로서비스를 구축하는 아키텍트와 개발자는 데이터 격리와 통신 모두에 영향을 미치는 절절한 세분도를 찾고자 씨름한다.

올바른 통신 스타일을 발견하는 것 또한 팀이 서비스를 디 커플링하면서 유용한 방향으로 조정하는 데 도움이 된다.

아키텍트는 동기로 할지, 비동기로 할지. 근본적인 통신 방식을 결정해야 한다.

동기 통신은 호출부가 수신부의 응답을 기다린다.. 일반적으로 마이크로서비스 아키텍처는 `프로토콜 인지 간 상호 운용성`

- 프로토콜 인자: 마이크로서비스는 운영 커플링을 방지하고자 중앙 통합 허브를 갖고 있지 앟기 때문에 각 서비스는 다른 서비스를 호출하는 방법을 알고 있어야 한다.
- 이종: 마이크로서비스는 분산 아키텍처라서 각 서비스마다 구현 기술 스택이 상이할 수 있다. 이종이란, 서비스마다 사용하는 플랫폼이 저마다 다른 폴리그랏환경을 완벽하게 지원한다는 뜻
- 상호 운용성:여러 서비스가 서로 호출한다는 뜻

#### 17.8.1. 코레오그래피와 오케스트레이션

코레오그래피는 브로커 이벤트 기반의 아키텍처와 통신 스타일이 동일하다.

즉, 이 아키텍처는 중앙의 중재자가 따로 없고 경계 콘텍스트 철학에 충실하다.

따라서 아키텍트는 서비스 간에 분리된 이벤트를 구현하는 것이 자연스럽다고 생각한다.

#### 17.8.2. 트랜잭션과 사가

마이크로서비스 아키텍트는 극도로 디커플링을 갈망하지만 여러 서비스에 걸친 트랜잭션을 어떻게 조정하는 게 좋을지 고민하게 된다.

- 트랜잭션: 여러 서비스에 걸친 트랜잭션을 조정하는 것은 극도로 어렵다. 트랜잭션은 마이크로서비스 아키텍처의 철학과 맞지 않다.

> 마이크로서비스에 트랜잭션을 걸지 마세요. 대신 세분도를 바로잡으세요!

### 17.9. 아키텍처 특성 등급

전체 비용, 성능, 단순성을 제외하고 거의 만점이다.

### 느낀점

마이크로서비스에 대한 이미지가 조금 정리된..

#### 논의사항

- 기억에 남는 부분: 마이크로서비스는 커플링을 가급적 삼가므로 이 아키텍처 스타일을 구축하는 아키텍트는 커플링보다는 차리리 중복이 낫다고 생각

커플링을 방지하기 위해서 차라리 중복이 낫다는 생각은 처음 들어보는 생각이라 신선했다..
