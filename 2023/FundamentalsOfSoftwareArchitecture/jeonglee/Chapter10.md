## 10. 레이어드 아키텍처 스타일

레이어드 아키텍처는 가장 흔한 아키텍처 스타일 중 하나이다.

대중적이면서 비용도 적게 들어 모든 애플리케이션의 사실상 표준 아키텍처이다.

시스템을 설계하는 조직은 그 조직의 소통 구조를 그대로 복제한 듯 설계할 수 밖에 없다는 콘웨이 법칙을 떠올려보면, 레이어드 아키텍처는 애플리케이션을 개발하는 아주 자연스러운 방법이다.

UI 개발자, 백엔드, 규칙 개발자, 데이터베이스 개발자 등이 어느 회사던 있기 때문에 이런 조직의 전통적인 레이어드 아키텍처와 잘 맞아 떨어지니 많은 사랑을 받게 되었다.

그러나 아키텍처 스타일은 묵시적 아키텍처 안티패턴, 우발적 아키텍처 안티패턴 등의 몇몇 아키텍처 안티패턴 범주에 속한다.  

### 10.1 토폴로지

레이어드 아키텍처에서 내부 컴포넌트는 논리적으로 수평한 레이어들로 구성되며, 각 레이어는 애플리케이션에서 주어진 역할을 수행한다.

레이어의 개수와 유형은 특별한 제한이 없지만, 일반적으로 프레젠테이션, 비즈니스, 퍼시스턴스, 데이터베이스의 4개 표준 레이어로 구성한다.

퍼시스턴스 로직이 비즈니스 레이어 컴포넌트에 내장된 경우에는 퍼시스턴스 레이어를 비즈니스 레이어에 병합시킨다.

따라서 규모가 작은 애플리케이션은 3개 크고 복잡한 애플리케이션은 5개 또는 그 이상으로 구성된다.

물리적 계층화 관점에서 다양하게 토폴로지룰 변형할 수 있다.  

각 레이어는 주어진 비즈니스 요청을 충족하는 데 필요한 업무 위주로 추상화되어 있다.

예를 들어 프레젠테이션 레이어는 고객 데이터를 조회하는 방법은 알 필요가 없고 그럴 이유도 없다.

그저 받아온 정보를 화면에 보기 좋게 보여주면 그만이다. 반대의 경우도 동일하다.

이러한 관심사의 분리 개념 덕분에 레이어드 아키텍처 스타일은 아키텍처 내부의 역할 및 책임 모델을 효과적으로 구성할 수 있다.

특정 레이어에 소속된 컴포넌트는 역할 범위가 한정되며 그 레이어에 알맞는 로직만을 처리한다.

따라서 개발자는 기술적인 부분에 집중시킬 수 있지만, 그런 장점을 대가로 전체적인 민첩성이 떨어지는 트레이드오프가 있다.

**중요**  

레이어드 아키텍처는 (도메인 분할 아키텍처의 반대인) 기술 아키텍처이다.  

즉 컴포넌트를 도메인 단위로 묶는게 아니라 아키텍처의 기술역할에 따라 묶기 때문에 비즈니스 도메인이 각각 모든 아키텍처 레이어에 분산된다.  

예를 들어 `고객`도메인은 프레젠테이션 레이어, 비즈니스 레이어, 퍼시스턴스 레이어, 데이터베이스 레이어에 모두 포함하기 때문에 이 도메인에 변경을 가하는 일은 쉽지 않다.

*도메인 주도 설계 방식과 잘 맞지 않는다.*

### 10.2 레이어 격리

레이어드 아키텍처의 각 레이어는 폐쇄또는 개방 상태이다.

**폐쇄 레이어란, 요청이 상위 레이어에서 하위 레이어로 이동하므로 중간의 어떤 레이어도 건너뛸 수 없고 현재 레이어를 거쳐야 바로 그 다음 레이어로 나아갈 수 있다는 뜻이다.**

하지만 모든 레이어를 거칠 필요가 없는 작업이라면 직접 액세스하는 편이 더 간편할 것이다.

다른 요청을 수행하려면 해당 레이어가 개방되어 있어야 하는데 과연 폐쇄와 개방 어느 것이 좋을지는 .. 레이어 격리를 이해해야 가능하다.

레이어 격리란, 어느 아키텍처 레이어에서 변경이 일어나도 다른 레이어에 있는 컴포넌트에 아무런 영향을 끼치지 않기에 레이어 간 계약은 불변임을 의미한다.

각 레이어는 서로 독립적으로 작동되므로 다른 레이어의 내부 동작로직은 거의/전혀 알지 못한다.

레이어 격리를 지원하려면 요청의 메인 흐름에 관한 레이어가 반드시 폐쇄되어 있어야 한다.

퍼시스던트 레이어에서 변경이 발생할 경우 비즈니스 레이어, 프레젠테이션 레이어 둘 다 영향을 받게 되고, 결국 컴포넌트 간의 레이어 상호 의존도가 높아져서 단단히 커플링된 애플리케이션이 될 것이다.

이런 아키텍처는 매우 취약하고 변경하기 힘들고 비용도 많이 든다.

### 10.3 레이어 추가

아키텍처 내부적으로 폐쇄 레이어를 이용해 변경을 격리할 수 있지만, 어떤 레이어는 개방을 하는 경우가 더 합리적인 경우가 있다.

예를 들어 비즈니스 레이어에 공통 비즈니스 기능이 구현된 객체를 구현하여 공유하고, 프레젠테이션 레이어에서는 이 공유 객체를 직접 사용할 수 없도록 아키텍처 결정을 했다고 한다.

이 시나리오는 프레젠테이션 레이어가 비즈니스 레이어를 액세스 할 수 있고 그 내부의 공유 객체 역시 갖다 쓸 수 있는, 지배/통제하기 어려운 아키텍처 구조이다.

이런 제약조건을 아키텍처적으로 강제하려면 공유 비즈니스 객체가 모두 포함된 새로운 서비스 레이어를 아키텍처에 추가하면 된다.

해당 레이어를 개방하여 접근을 간결하게 한다.

### 10.4 기타 고려 사항

아직 아키텍처 스타일을 완전히 정하지 못했다면 대부분의 어플리케이션에서 레이어드 아키텍처는 좋은 출발점이 될 것이다.

마이크로서비스 아키텍처를 고려 중인데 과연 마이크로서비스가 올바른 선택인지 긴가민가하고 어쨌든 개발은 시작해야 할 때도 그렇다.

하지만 재사용은 최소한, 객체 계층은 최대한 가볍게 맞추어 적절한 모듈성을 유지하는 것이 중요

레이어드 아키텍처에선 아키텍처 싱크홀 안티패턴을 조심해야 한다.

불필요한 객체 초기화 및 처리를 빈번하게 유발하고 쓸데없이 메모리를 소모하며 성능에도 부정적인 영향을 끼친다.

### 10.5 왜 이 아키텍처 스타일을 사용하는가

레이어드 아키텍처는 작고 단순한 애플리케이션이나 웹사이트에 알맞는 아키텍처 스타일이다.

특히 처음 구축을 시작할 때, 예산과 일정이 빠듯한 경우 출발점으로 괜찮은 아키텍처 선택이다.

레이어드 아키텍처 기반의 애플리케이션은 규모가 커질수록 유지 보수성, 민첩성, 시험성, 배포성 같은 아키텍처 특성이 점점 나빠진다.

따라서 레이어드 아키텍처를 사용한 대규모 애플리케이션이나 시스템은 다른 더 모듈러한 아키텍처 스타일이 더 잘 맞습니다.

### 10.6 아키텍처 특성 등급

아키텍처 특성을 각 아키텍처 스타일에 맞게 표로 나타내어져 있다.

전체 비용과 단순성은 레이어드 아키텍처의 주요 강점이다.

이 아키텍처는 모놀리식에 가깝기 때문에 분산 아키텍처 스타일에 따른 복잡도가 낮고, 구조가 단순해서 알기 쉬운데다 구축 및 유지보수 비용도 적게 든다.

### 느낀점

레어어로 구분하여 개발을 하는 방식이 레이어드 아키텍처인지 처음 알았다;;  

앞으로도 다른 방법을 배운다고 하니 기대가 된다.

#### 논의사항
