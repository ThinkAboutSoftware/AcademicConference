## 9. 기초

*아키텍처 스타일에 관한 글*

아키텍처 스타일은 유저 인터페이스와 백엔드 소스 코드를 구성하는 방법, 그리고 소스 코드가 데이터 저장소와 상호작용하는 방법에 관한 결정적으로 중요한 구조이다.

이와 달리 아키텍처 패턴은 아키텍처 스타일에서 특정한 솔루션을 마련하는 데 유용한 저수준의 설계 구조를 말한다.

아키텍처 스타일은 종종 아키텍처 패턴이라고 부르며, 다양한 아키텍처 특성을 다루는 컴포넌트 명명된 관계를 기술한다.

아키텍처 스타일의 명칭은 숙련된 아키텍트 사이에서 간명하게 지정할 수 있는 이름으로 붙여 놓았다.

만약 아키텍트가 레이어드 모놀리스식 구조에 대해서 이야기 할 경우 구조적인 측면과 어떤 종류의 아키텍처 특성이 알맞는지 살펴보고 통상적인 배포 모델과 데이터 전략 등 다양한 정보를 이해하는 것이다.

따라서 아키텍트는 기초적인 아키텍처 스타일의 명칭에 익숙해져야 한다.

### 9.1 기초 패턴

소프트웨어 아키텍처의 역사를 통틀어 끊임없이 나타나고 또 나타나는 패턴이 있는데,, 이런 패턴들은 코드, 배포, 또는 아키텍처의 다른 부분을 구성하는 시야를 넓혀준다.

#### 9.1.1 진흙잡탕

뭐 하나 뚜렷한 아키텍처 구조가 전무한 상태를 진흙잡탕이라고 표현한다.

진흙잡탕은 대충 되는 대로, 아무렇게나 막 지저분하게, 테이프를 덕지덕지 붙여 놓은 스파게티 코드 정글이다.

진흙 잡탕은 요즘에는 보통 실제 내부 구조라 할 만한 것은 하나도 없는, 데이터베이스를 직접 호출하는 이벤트 핸들러를 가진 단순한 스크립팅 애플리케이션을 가리킨다.  

이런 구조는 규모가 커지면서 처지 곤란한 상태가 되어버린다..

아키텍트는 무슨 수를 써서라도 이런 아키텍처는 피하려고 한다. 구조가 없으면 앞으로 뭔가 변경하기 까다로워 지고 배포, 확장, 성능 역시 고통스럽기 때문이다.

#### 9.1.2 유니터리 아키텍처

컴퓨터의 발전에 따라 단일 시스템에서 분산형 시스템이 등장하였다.

이제 유니터리 시스템은 임베디드 시스템과 그 밖에 매우 제약이 많은 극소수 환경을 제외하면 거의 쓰이지 않는다.

*소프트웨어 시스템은 시간이 지날 수록 성능, 확장 등의 운영 아키텍처의 특성을 유지하려면 관심사를 분리할 필요가 있다.*

#### 9.1.3 클라이언트/서버 서버

시간이 갈수록 단일 시스템에서 여러 기능을 분리할 필요성이 대두되었고 그 분리 방법은 많은 아키텍처 스타일의 기초가 되었다.

프런트엔드와 백엔드로 기술적으로 기능을 분리한 2티어또는 클라이언트/서버 아키텍처는 대표적인 기본 아키텍처 스타일이다.

이 아키텍처는 시대와 컴퓨팅 파워에 따라 여러가지 형태로 존재해왔다.

##### 데스크톱 + 데이터베이스 서버

데이터는 별도의 데이터베이스 서버로 분리하여 계산량이 많은 액션은 탄탄한 데이터베이스 서버에서 실행하고, 프레젠테이션 로직은 데스크톱에 두는 방식

##### 브라우저 + 웹 서버

현대 웹 개발 시대가 도래하면서 웹 브라우저가 웹 서버에 접속하는 형태로 분리하는 것이 일반화되었다.

이로써 클라이언트는 가벼운 브라우저로 대체 되고, 내외부 방화병 모두 더 넓은 범위로 배포가 가능해졌다.

데이터베이스는 웹 서버와 분리되어 있지만 두 서버 모두 운영 센터 내부의 동급 머신에서 운용되고 유저 인터페이스는 브라우저에서 실행되므로 여전히 이 구조를 2티어로 바라보는 아키텍트도 있다.

##### 3티어

1990년대 후반에 인기를 끈 3티어 아키텍처는 더 많은 레이어로 분리하며, 자바, 닷넷 진영에서 애플리케이션 서버같은 도구가 보급되고 기업들은 더 많은 레이어를 토폴로지에 구축하기 시작했다.

그 결과 데이터베이스 서버를 사용하는 데이터베이스 티어, 애플리케이션 서버가 관리하는 애플리케이션 티어, 그리고 HTML로 시작하여 점점 많아져 온갖 자바스크립트 코드가 가득 찬 프런트엔드 티어 이렇게 세 티어가 완성됐다.

3티어 아키텍처는 분산 아키텍처에 적합한 공통 객체 요청 브로커 아키텍처, 분산 컴포넌트 객체 모델같은 네트워크 수준의 프로토콜과 잘 맞았다.

### 9.2 모놀리식 대 분산 아키텍처

아키텍처 스타일은 크게 (전체 코드를 단일 단위로 배포하는) 모놀리식과 (원격 액세스 프로토콜을 통해 여러 단위로 배포하는)분산형, 두 종류이다.

이 세상에 완벽한 분류 체계는 없겠지만, 분산 아키텍처는 모놀리식 아키텍처 스타일에서 찾아볼 수 없는 공통적인 난제와 이슈를 갖고 있으므로 다양한 아키텍처 스타일을 분류하기 좋은 기준이다.

분산 아키텍처 스타일은 모놀리식 아키텍처 스타일에 비해 성능, 확장성, 가용성 측면에서 휠씬 강력하지만, 이런 파워도 결코 무시할 수 없는 트레이드오프가 수반된다.

이런 오류(옳다고 믿거나 가정하지만 사실 틀린 것)는 과거에서 부터 오늘날 까지도 적용되고 있다.

#### 9.2.1 오류 1: 네트워크는 믿을 수 있다

개발자, 아키텍트 모두 네트워크를 믿을 수 있다고 전제하지만 실제로는 전혀 그렇지 않다.

분산 아키텍처는 그 특성상 서비스를 오가는, 또 서비스 간에 이동하는 네트워크에 의존하므로 이것은 아주 중요한 문제이다.

그림과 같은 서비스가 서로 응답하지 못하는 경우를 생각해서 타임아웃 장치나 회로 차단기(서킷 브레이커)를 두는 것이다.

시스템이 네트워크에 더 의존할수록 시스템의 신뢰도는 잠재적으로 떨어질 가능성이 있다.

#### 9.2.2 오류 2: 레이턴시는 0이다  

메서드나 함수를 이용해 다른 컴포넌트를 로컬 호출하면 그 소요시간은 나노 초 내지 밀리초 단위로 측정되지만, 동일한 호출을 원격 액세스 프로토콜을 통해서 수행하면 서비스 액세스 시간이 밀리초 단위로 측정된다.

따라서 두 시간의 차이는 발생할 수 밖에 없고 모든 분산 아키텍처에서 레이턴시는 0이 아니다.

아키텍트는 어떤 분산 아키텍처를 구축하든지 평균 레이턴시는 반드시 알아야 한다.

이것이 분산 아키텍처가 실현 가능한지 판단하는 유일한 방법이다.

#### 9.2.3 오류 3: 대역폭은 무한하다

모놀리식 아키텍처는 비즈니스 요청을 처리하는 데 그리 큰 대역폭이 필요하지 않으므로 대역폭이 문제될 일은 별로 없다.

하지만 마이크로 서비스 분산 아키텍처에서 시스템이 자잘한 배포 단위로 쪼개지면 이 서비스들 간에 주고 받는 통신이 대역폭을 상당히 점유하여 네트워크가 느려지고 결국 레이턴시와 신뢰성에도 영향을 준다.

#### 9.2.4 오류 4: 네트워크는 안전하다

아키텍트와 개발자는 대부분 가상사설망(VPN), 신뢰할 수 있는 네트워크, 방화벽에 익숙해진 나머지 네트워크가 안전하지 않다는 사실을 망각하는 경향이 있다.  

보안은 분산 아키텍처에서 훨씬 더 어려운 문제이다. 모놀리식에서 분산아키텍처로 옮아가면서 더 넓은 영역이 악의적인 외부인의 위협과 공격에 노출된다.

#### 9.2.5 오류 5: 토폴로지는 절대 안 바뀐다

네트워크를 구성하는 모든 라우터, 허브, 스위치, 방화벽, 네트워크, 어플라이언스등 전체 네트워크 토폴로지가 불변일 거라는 가정은 섣부른 오해다..!

#### 9.2.6 오류 6: 관리자는 한 사람뿐이다

네트워크 관리자는 혼자가 아니라 여러 사람이다.

아키텍트는 언제나 한 사람의 관리자와 협의하고 소통하면 된다는 오류에 빠지곤 한다.

#### 9.2.7 오류 7: 운송비는 0이다

많은 소프트웨어 아키텍트들이 이 오류를 레이턴시와 혼동한다.  

여기서 운송비는 레이턴시가 아니라. "단순한 REST 호출"을 하는 데 소요되는 진짜 비용을 말한다.

아키텍트는 단순 REST 호출을 하거나 모놀ㄹ식 애플리케이션을 분리하는 데 필요한 충분한 인프라가 갖춰졌다고 오만한다.

#### 9.2.8 오류 8: 네트워크는 균일하다

아키텍트, 개발자는 대부분 네트워크가 균일하다.

즉, 어느 네트웤 하드웨어 업체 한 곳에서 모든 장비를 다 만들었다고 착각한다.

하지만 실제 많은 회사의 인프라는 여러 업체의 네트워크 하드웨어 제품들이 엃히고 설켜 있다.

#### 9.2.9 오류 9: 다른 분산 아키텍처 고려 사항

지금까지 열거한 8가지 오류와 더불어, 모놀리식 아키텍처에는 없지만 분산 아키텍처를 설계할 때 맞닥뜨리게 될 이슈 및 해결해야 할 난제들이 있습니다.

##### 분산 로깅

분산 아키텍처는 애플리케이션과 시스템 로그가 분산되어 있으므로 어떤 데이터가 누락된 근본 원인을 밝혀내기가 어렵다.

##### 분산 트랜잭션

모놀리식 아키텍처 세계에서 아키텍트, 개발자는 관리가 편한 트랜잭션을 당연시 한다.

하지만 분산 아키텍처는 최종 일관성이라는 개념을 바탕으로 분리된 배포 단위에서 처리된 데이터를 미리 알 수 없는 어느 시점에 모두 일관된 상태로 동기화한다.

##### 계약 관리 및 버저닝

계약 생성, 유지보수, 버저닝 역시 분산 아키텍처에서 다소 까다롭다.

계약은 클라이언트 와 서비스 모두 합의한 행위와 데이터이다.

분산 아키텍처에서는 분리된 서비스와 시스템을 제각기 다른 팀과 부서가 소유하기 때문에 계약 유지보수가 특히 어렵다..

### 느낀점

아키텍처 스타일에서 분산 부분의 용어를 많이 들어봤지만.. 여기서 조금 정리가 된 느낌이다.

스타일에 대한 정의와 실제로 적용되는 사례들을 봐서 그런지 이해가 잘 된 편이다.

#### 논의사항

