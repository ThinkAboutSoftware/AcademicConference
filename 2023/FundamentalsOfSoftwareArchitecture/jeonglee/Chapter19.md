## 19. 아키텍처 결정

아키텍트에게 기대하는 핵심 가치 중 하나는 아키텍처 결정을 내리는 것이다.

*아키텍처 결정은 애플리케이션이나 시스템의 구조에 관한 것이 대부분이지만 기술 결정 역시 (그것이 아키텍처 특성에 영향을 미칠 경우 ) 포함될 수 있다.*

### 19.1 아키텍처 결정 안티패턴

아키텍처를 결정하는 것도 기술이다.

따라서 아키텍트가 결정을 내릴 때 아키텍처 안티패턴에 빠지지 않도록 주의해야 한다.

#### 19.1.1 '네 패를 먼저 보여주지마' 안티패턴

아키텍트가 잘못된 선택을 하는 것을 두려워한 나머지 아키텍처 결정을 회피하거나 미루는 현상을 말한다.

이 안티패턴은 두 가지 방법으로 극복할 수 있다.

- 어떤 중요한 아키텍처 결정을 내리기 전, 마지막으로 책임질 수 있는 순간까지 기다리는 것
- 개발팀과 지속적으로 협력하면서 아키텍트가 결정한 내용을 원래 의도한 대로 추진하는 것

#### 19.1.2 '무한반복 회의' 안티패턴

'네 패를 먼저 보여주지마' 안티패턴을 극복하면 이어서 '무한반복 회의' 안티패턴으로 이어진다.

사람들이 어떤 결정을 왜 했는지 모르고 주구장창 회의만 계속 하는 것이다.

이 안티패턴이 발생하는 이유는 아키텍트가 자신이 내린 결정을 정당화하는데 실패했기 때문이다.

아키텍처를 정당화하려면 그 결정을 내리게 된 기술적, 비즈니스적 근거를 제시하는 것이 중요(따라서 앞에 나온 문서화도 중요하다.)

#### 19.1.3 '이메일 기반 아키텍처' 안티패턴

아키텍트가 아키텍처 결정을 하고 그 결정을 온전히 정당화한 다음은 '이메일 기반 아키텍처' 안티패턴이 등장할 차례이다.

사람들이 아키텍처 결정을 놓치거나 잊어버리고 심지어 그렇게 결정됐다는 사실조차 알지 못해 아키텍처 결정을 구현하지 못하는 상태이다.

즉, 아키텍처 결정을 효과적으로 전달하는 문제와 관련된 안티패턴이다.

### 19.2 아키텍처적으로 중요한

아키텍처 결정에 기술적인 내용이 포함되면 그것은 아키텍처 결정이 아니라, 기술 결정이라고 단정짓는 아키텍트들이 많지만 반드시 그런 것은 아니다.

아키텍트가 어떤 기술을 사용하기로 결정 했고 그 기술을 어떤 아키텍처 특성을 직접 지원하기 위해 선택한 것이라면 그것은 아키텍처 결정이 맞다..!

### 19.3 아키텍처 결정 레코드

아키텍처 결정을 가장 효과적으로 문서화하는 방법은 바로 아키텍처 결정 레코드(ADR)이다.

#### 19.3.1 기본 구조

ADR의 기본 구조는 제목, 상태, 콘텍스트, 결정, 결과, 이렇게 주요 5개 섹션으로 구성된다.

여기서 컴플라이언스와 노트라는 추가 센션을 덧붙인다.

필요시 센션을 추가하는 방법으로 기본구조를 확장하는 식으로 템플릿을 간명하게 유지할 수 있다.

다른 모든 대안의 분석 결과를 대안센션에 기록하는 것이 좋은 예이다.

#### 19.3.2 ADR 저장

이렇게 공들여 작성한 ADR을 어디에 저장해야 할까?

일부 아키텍트들은 깃 레포에 보관하거나 위키에 저장하는 방법을 선호한다.

#### 19.3.3 ADR로 문서화

소프트웨어 아키텍처의 문서화는 언제나 어려운 주제이다.

ADR은 소프트웨어 아키텍처를 효과적으로 문서화하는 수단으로 활용할 수 있다.

### 느낀점

아키텍트가 아키텍처를 선택하여 따라오는 책임을 깊게 생각해본적이 없는 것 같다.

생각보다 더 무거운 위치라는 생각..

#### 논의사항

아키텍처 결정 안티패턴이 되게 말이 재밌었는데.. 프로그래머 레벨에서 안티패턴을 저런 형식으로 만들어 본다면 뭐가 있을까요..?

하하!
