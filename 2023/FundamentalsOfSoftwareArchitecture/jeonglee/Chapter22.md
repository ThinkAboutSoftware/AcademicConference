## 22. 개발팀을 효율적으로

소프트웨어 아키텍트는 기술 아키텍처를 정립하고 아키텍처 결정을 내릴 뿐만 아니라, 개발팀이 아키텍처를 올바르게 구현하도록 안내할 책임이 있다.

팀을 생산적으로 만드는 능력은, 유능하고 성공적인 소프트웨어 아키텍트가 다른 아키텍트들과 차별화되는 강점이다.

### 22.1 팀 경계

스스로 정상 궤도에서 벗어났거나 소프트웨어 아키텍트로부터 멀어졌다고 느끼는 개발팀은 대부분 시스템의 다양한 제약조건을 제대로 알지 못하고 경험도 없기 때문에 아키텍처를 올바르게 구현하지 못한다.

따라서 소프트웨어 아키텍처가 필요하다.. 아키텍트는 개발자가 아키텍처를 구현할 수 있게 제약조건이나 어떤 틀을 만들어 개발팀과 소통하는 일을 한다.

아키텍트는 너무 빡빡하거나, 너무 느슨하거나, 얼추 딱 맞는 경계를 생성할 수 있는데 이는 팀의 능력에 직접적인 영향을 미친다.

아키텍트가 제약조건을 너무 많이 설정하거나 너무 느슨하게 설정할 경우엔 개발자들이 아키텍처를 구현하는데 어려움을 겪는다.

유능한 아키텍트는 팀의 경계를 적당하게 설정하여 올바른 도구와 라이브러리로 무장하여 아키텍처를 잘 구현할 수 있더록 적절한 지침과 제약조건을 제공한다.

### 22.2 아키텍트 성향

아키텍트의 성향은 `내 마음대로 아키텍트`, `유체이탈 아키텍트`, `유능한 아키텍트` 세 가지 정도로 나뉜다.

이 세 타입은 앞 절에서 설명한 팀 경계를 설명하면서 분류한 경계 타입과 정확하게 일치한다.

#### 22.2.1 내 마음대로 아키텍트

내 마음대로 아키텍트는 소프트웨어 개발 프로세스의 세세한 부분을 일일이 통제하려고 한다.

이런 아키텍트가 내리는 결정은 하나같이 세부적으로 저수준에 관한 내용이라서 개발팀에 과도한 제약을 초래한다.

경계가 아주 빡빡하기에 개발팀이 알아서 쓸 만한 오픈소스나 서드파티 라이브러리를 마음대로 사용하지도 못하고 컨벤션부터 의사코드까지 모든 것을 아키텍트가 정해버린다.

*개발자에서 아키텍트로 전직한 경우 많이 발생*

아키텍트는 프로젝트의 복잡성과 팀 기술 수준에 따라 내 맘대로 아키텍트라는 악역을 맏아야 할 때도 있다.

그러나 대개 내 맘대로 아키텍트는 개발팀을 혼란에 빠뜨리고, 적절하게 지도하지 못한 채 외려 방해가 될 때도 많고, 팀을 이끌어 아키텍처 구현을 리드하는 데 적합하지 않은 편이다.

#### 22.2.2 유체이탈 아키텍트

유체이탈 아키텍트는 꽤 오랫동안 코딩을 한 적이 없어서 아키텍처를 수립할 때 세부 구현 사항은 거의 나몰라라 하는 아키텍트이다.

기술 또는 비즈니스 관점에서 유체이탈 아키텍트는 그냥 머리가 꽉 막힌 사람들이므로 팀을 리드하거나 가이드하는 일을 애당초 불가능하다.

결국 개발팀이 스스로 아키텍트 역할을 맡아 아키텍트가 할 일을 대신 하게 되는데 진척도와 생선성이 떨어지는 것은 물론, 팀원들이 시스템 작동 방식을 이해하는 과정에서도 혼란에 빠지게 된다.

#### 22.2.3 유능한 아키텍트

유능한 아키텍트는 개발팀에 적절한 제약조건과 경계를 설정하고 팀원들이 서로 잘 협력할 수 있도록 독려하며 그들을 올바른 수준으로 가이드해야 한다.

당연하게 보일 수 있지만 결코 쉽지 않다.

개발팀을 잘 이끄는 유능한 리더가 되는 것은 일종의 **예술**이다.

### 22.3 얼마나 제어해야 하나?

#### 팀원 간 친밀도

팀원들이 서로 잘 아는 사이라면 이미 스스로 조직화하기 시작되므로 제어가 덜 필요하고, 그 반대일수록 팀원 간 협업을 촉진하고 팀 내 파벌을 없애기 위해 더 많은 제어가 필요하다.

#### 팀 규모

팀이 커질수록 더 많은 제어가 필요하고, 팀이 작을수록 제어가 덜 필요하다.

#### 전체적인 경험

주니어 개발자가 많은 팀은 제어와 멘토링이 더 필요하고, 시니어 개발자가 더 많은 팀은 아무래도 제어가 덜 필요하다.

#### 프로젝트 복잡도

복잡도가 높은 프로젝트를 수행하려면 아키텍트가 팀에 더 많이 관여하여 갖가지 이슈를 처리해야 할 테니 팀에 더 많은 제어를 가할 수밖에 없다.

#### 프로젝트 기간

프로젝트 기간이 더 길수록 더 많은 제어가 필요하고 짧을수록 덜 필요하다.

### 22.4 팀의 이상 징후

팀 규모는 아키텍트가 개발팀에 행사하는 제어량에 영향을 미치는 팩터 중 하나이다.

팀이 클수록 제어가 더 많이 필요하고, 팀이 작을수록 제어가 덜 필요하다.

가장 효율적인 개발팀의 규모는 다음 세 가지 팩터에 의해 결정된다.

- 프로세스 손실
- 다원적 무지
- 책임 확산

#### 프로세스 손실

기본적으로 프로젝트에 인력을 더 많이 투입할수록 프로젝트 수행하는 시간이 더 길어진다는 것을 의미한다.

그룹 포텐셜은 팀원 모두의 집합적인 노력에 의해 정의되지만 어느 팀이건 실제 생산성은 이 그룹 퍼텐셜에 훨씬 못 미친다.

유능한 아키텍트는 개발팀을 잘 관리하여 프로세스 손실을 찾는다.

만약 병합 충돌이 자주 발생한다면 프로세스 손실의 징후라고 볼 수 있다.

즉, 팀원들이 서로의 발을 밟은 채 동일한 코드 작업을 하고 있다는 방증이다.

#### 다원적 무지

팀 규모가 너무 커지면 다원적 무지 현상이 발생한다.

모든 사람들이 자신이 뭔가 너무 뻔한 것을 놓치고 있는 게 아닐까 두려운 나머지 어떤 표준에 순순히 동의하는 현상이다.

*자칫 말을 잘못 꺼냈다가 이렇게 뻔한 거도 모르냐 등등..*

유능한 아키텍트는 회의나 토론을 하더라도 상대방의 생각과 몸짓을 읽고 조정자를 자처해야 한다.

의견을 물어보고 그들의 편을 지지해야 한다.

#### 책임 확산

팀 규모가 커질수록 의사 소통이 잘 안되는 건 모두가 공감하는 팩트이다.

팀원 중 누가 무슨 일을 담당하고 있는지 혼란스럽다면 팀이 너무 커졌다는 신호이다.

유능한 아키텍트는 개발팀이 아키텍처를 잘 구현하도록 친절하게 안내하는 것은 물론, 팀이 건강하고 행복하게 공동 목표를 달성하도록 서로 협력하는 분위기를 조성해야 한다.

### 22.5 체크리스트 활용

체크리스트에 적합한 프로세스는 순서나 종속된 작업이 없는 프로세스, 그리고 에러가 발생하기 쉽거나 누락되어 다음으로 넘어가기 쉬운 단계가 있는 프로세스이다.

체크리스트를 효과적으로 작성하는 핵심 요령은, 만사를 체크리스트하려고 무리하지 말고 모든 단계를 포착하되 가능한 체크리스트는 최소화하는 게 좋다.

가장 효과적이라 생각되는 체크리스트는 개발자 코드 완료, 단위/기능 테스트, 소프트웨어 릴리스 체크리스트이다.

#### 22.5.1 개발자 코드 완성도 체크리스트

개발자 코드 완성도 체크리스트는 소프트웨어 개발자가 코드를 `완료`했다고 말할 때 사용하기 좋은 도구이다.

`완료된 것의 정의`를 할 때에도 유용하다.

개발자가 이 체크리스트의 모든 항목을 완료했다면 실제로 코딩을 완료했다고 봐도 된다.

#### 22.5.2 단위/기능 테스트 체크리스트

단위/기능 테스트 체크리스트는 가장 효과적인 체크리스트 중 하나이다.

대다수의 개발자가 테스트를 잊기 쉬운, 다소 특이한 엣지 케이스 테스트가 들어 있다.

QA팀 사람들은 어떤 테스트 케이스에서 이슈를 발견할 때마다 이 체크리스트에 추가한다.

#### 22.5.3 소프트웨어 릴리스 체크리스트

소프트웨어를 프로덕션에 릴리스하는 작업은 소프트웨어 개발 라이프 사이클에서 가장 에러가 발생하기 쉬운 부분이므로 체크리스트를 작성하면 도움이 된다.

빌드 및 배포 실패를 예방하는 데에도 탁월한 효능이 있고 소프트웨어 출시 관련 리스크도 크게 줄어든다.

### 22.6 지침 제시

소프트웨어 아키텍트는 설계 원칙을 적용하고 지침을 제공하여 팀을 효과적으로 만들 수 있다.

#### 특수한 목적

PDF 렌더링, 바코드 스캐닝등 딱히 커스틈 소프트웨어를 작성할 만한 이유가 없는 상황에서 사용되는 특수한 라이브러리

#### 일반적인 목적

자바 진영의 아파치 커먼스, 구아바처럼 언어 API를 감싼 래퍼

#### 플레임워크

퍼시스턴스, 제어 역전등에 사용하는 라이브러리

이렇게 범주화한 다음 이 설계 원칙을 중심으로 틀을 만든다.

아키텍트가 특정한 목적에 맞는 라이브러리를 지정하면 개발자는 그 라이브러리에 대해서만큼은 아키텍트의 조언을 따로 구할 필요없이 스스로 판단할 수 있다.

### 22.7 마치며

개발팀을 잘 굴러가게 만들기란 참으로 어렵다.

많은 경험과 연습이 필요하고 강력한 대인 관계 기술이 필요하다.

소프트웨어 아키텍트는 팀을 기술적으로 이끌 뿐만 아니라 아키텍처 구현을 통해 팀을 리드한다.

소프트웨어 아키텍트는 개발팀과 긴밀한 협력 관계를 유지하면서 팀 역학을 관찰하고 변경을 촉진하여 효과적으로 팀을 움직일 수 있다.

이것이 바로 기술만 가진 아키텍트와 유능한 소프트웨어 아키텍트를 구분하는 잣대이기도 하다.

### 느낀점

아키텍트로써 바라봐야한 개발팀도 있지만 실제 개발팀이 만들어지고 거기서 오는 문제들을 알아볼 수 있어서 좋았다.

내용자체가 `실리콘 밸리의 팀장들`과 비슷하다는 생각이 드는게 당연한 것 같다.

#### 논의사항

회사 규모로 보면 개발팀의 규모가 엄청 클텐데 책에서 나오는 팀 이상징후들을 어떻게 관리하는지 궁금합니다.
