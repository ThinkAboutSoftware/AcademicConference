## 14. 이벤트 기반 아키텍처 스타일

이벤트 기반 아키텍처는 확장성이 뛰어난 고성능 애플리케이션 개발에 널리 쓰이는 비동기 분산 아키텍처 스타일이다.

적응성이 매우 좋아 소규모부터 대규모까지 두루 사용할 수 있다.

이벤트 기반 아키텍처는 이벤트를 비동기 수신/처리하는 별도의 이벤트 처리 컴포넌트로 구성되며, 스탠드 얼론 아키텍처 스타일로 사용하거나 다른 아키텍처 스타일에 내장할수도 있다.

이 모델은 어떤 액션을 수행하도록 시스템에 요청하면 요청 오케스트레이터가 접수한다.

요청 오케스트레이터는 보통 유저 인터페이스이지만 API 레이어나 엔터프라이즈 서비스버스로도 구현할 수 있다.

이 컴포넌트의 임무는 다양한 요청 프로세서에 확정적으로, 동기적으로 요청을 전달하는 일이다.

요청 프로세스는 요청을 받아 데이터베이스에서 정보를 조회/수정하는 등의 작업을 수행하는 식으로 요청한다..

### 14.1 토폴로지

이벤트 기반 아키텍처의 주요 토폴로지는 중재자 토폴로지, 브로커 토폴로지이다.

중재자 토폴로지는 이벤트 처리 워크플로를 제어해야 할 경우에, 브로커 토폴로지는 신속한 응답과 동적인 이벤트 처리 제어가 필요할 때 각각 사용된다.

두 토폴로지의 아키텍처 특성과 구현 전략은 서로 다르기 때문에 주어진 상황에 맞게 선택하려면 각각의 특징을 정확하게 이해해야 한다.

### 14.2 브로커 토폴로지

브로커 토폴로지는 중앙에 이벤트 중자재가 없다는 점에서 중재자 토폴로지와 다르다.

메시지는 경량 메세지 브로커를 통해 브로드캐스팅되는 식으로 이벤트 프로세서 컴포넌트에 분산되어 흘러간다.

이 토폴로지는 비교적 이벤트 처리 흐름이 단순하고 굳이 중앙에서 이벤트를 조정할 필요가 없을 때 유용하다.

브로커 토폴로지는 네 가지 기본 아키텍처 컴포넌트

시작 이벤트, 이벤트 브로커, 이벤트 프로세서, 처리 이벤트로 구성된다.

시작 이벤트는 단순한 이벤트든, 복잡한 이벤트든 전체 이벤트 흐름을 개시하는 이벤트를 말한다.

시작 이벤트는 이벤트 브로커의 이벤트 채널로 전송되어 처리된다.

이벤트를 관리/제어하는 중재자가 브로커 토폴로지에 없으므로 단일 이벤트 프로세서는 이벤트 브로커에서 시작 이벤트를 받자마자 관련된 처리 작업을 마친 뒤 처리 이벤트를 생성하고 시스템의 나머지 부분에 자신이 한 일을 비동기로 알린다.

이 처리 이벤트는 필요시 부가적인 처리를 위해 이벤트 브로커에 비동기 전송된다.

다른 이벤트 프로세서는 처리 이벤트를 리스닝하고 있다가 이벤트가 들어오면 그에 맞는 작업을 수행한 뒤 다시 새로운 처리 이벤트를 발행함으로 자신이 한 일을 모두에게 알린다.

| 장점 | 단점 |
| --- | --- |
| 이벤트 프로세서가 디커플링됨. | 워크플로 제어. |
| 확장성이 높음 | 에러 처리 |
| 응답성이 우수함 | 복구성 |
| 성능 우수함 | 재시작 능력 |
| 내고장성 뛰어남 | 데이터 비일관성 |

### 14.3 중재자 토폴로지

중재자 토폴로지는 앞서 본 브로커 토폴로지의 단점을 일부 보완한다.

여러 이벤트 프로세서 간의 조정이 필요한 시작 이벤트에 대하여 워크플로를 관리/제어하는 이벤트 중재자가 핵심이다.

중재자 토폴로지는 시작 이벤트, 이벤트 큐, 이벤트 중재자, 이벤트 채널, 이벤트 프로세서 이렇게 5개 아키텍처 컴포넌트로 구성된다.

시작 이벤트가 전체 이벤트 프로세스를 개시하는 이벤트인 점은 브로커 토폴로지와 동일하지만, 중재자 토폴로지에서는 시작 이벤트 처리에 관한 단계 정보만 갖고 있으므로 점대점 메시징으로 각각의 이벤트 채널로 전달되는 처리 이벤트를 생성한다.

그러면 각 이벤트 프로세서는 자신의 이벤트 채널에서 이벤트를 받아 처리한 다음 중재자에게 작업을 완료했다고 응답한다.

이벤트 프로세서가 다른 프로세서에게 자신이 한 일을 알리지 않는다는 것도 브로커 토폴로지와 다른 점이다.

중재자 컴포넌트는 브로커 토폴로지와 달리 워크플로에 대해 잘 알고 있고 통제가 가능하다.

따라서 이벤트 상태를 유지하며 에러 처리, 복구, 재시작을 할 수 있다.

| 장점 | 단점 |
| --- | --- |
| 워크플로 제어 | 이벤트 프로세서가 커플링됨 |
| 에러 처리 | 확장성이 떨어짐 |
| 복구 | 성능 낮음 |
| 재시작 | 내고장성 낮음 |
| 데이터 일관성 | 워크플로 모델링 복잡함 |

브로커 토폴로지냐 중재자 토폴로지냐 결국 워클플로 제어와 에러 처리 기능이 우선인가, 아니면 고성능과 확장성이 더 중요한가의 트레이드 오프를 잘 따라서 선택할 수 밖에 없다.

*중재자 토폴로지의 성능과 확장성도 그리 나쁜편은 아니지만 아무래도 브로커 토폴로지만큼은 못 한 게 사실*

### 14.4 비동기 통신

이벤트 기반 아키텍처 스타일은 요청/응답 처리뿐만 아니라 파이어 앤드 포켓 처리 모두 비동기 통신만 사용한다는 점에서 다른 아키텍처 스타일과 차별화된다.

비동기 통신은 시스템 응답성을 전반적으로 높이는 기법으로 사용할 수 있다.

비통기 통신에는 에러 처리가 가장 큰 문제이다.

응답성은 엄청나게 개선되지만 에러를 제대로 처리하기가 쉽지 않기 때문에 이벤트 기반 시스템의 복잡도가 가중된다.

### 14.5 에러 처리

리액티브 아키텍처의 워크플로 이벤트 패턴은 비동기 워크플로에서 에러 처리 문제를 해결하는 한 가지 방법이다.

탄력성, 응답성을 보장하는 리액티브 아키텍처 패턴의 일종이다.

### 14.6 데이터 소실 방지

비동기 통신을 할 때 데이터 소실은 언제나 중요한 부분인데, 이벤트 기반 아키텍처는 이러한 데이터 소실에 많이 노출되어 있다.

### 14.7 브로드캐스팅

이벤트 기반 아키텍처는 메시지를 누가 받든 그 메시지로 무슨 일을 하든 상관없이 이벤트를 브로드캐스트할 수 있다.

### 14.8 요청-응답

이벤트 기반 아키텍처는 동기 통신을 요청-응답 메시징방식으로 수행한다.

요청-응답 메시징 내부의 각 이벤트 채널은 요청 큐, 응답 큐로 구성된다.

처음 정보를 요청하면 요청 큐에 응답이 도착하길 기다리며 차단 대기 상태가 된다.

메시지 컨슈머가 메시지를 받아 처리한 후 응답 큐에 응답을 보내면 이벤트 프로듀서는 응답 데이터가 포함된 메시지를 수신한다.

### 14.9 요청 기반이냐, 이벤트 기반이냐

워크플로의 확장성과 제어가 중요하면 체계적인 데이터 기반의 요청에 특화된 요청 기반 모델을, 복잡하고 동적인 유저 처리 등 주로 고도의 응답성과 확장성을 요하는, 유연한 액션 단위의 이벤트를 처리한다면 이벤트 기반 모델이 좋은 선택이다.

### 14.10 하이브리드 이벤트 기반 아키텍처

이벤트 기반 아키텍처와 다른 아키텍처 스타일을 함께 사용하는 하이브리드 아키텍처 기반의 애플리케이션도 있다

이벤트 기반 아키텍처를 다른 아키텍처 스타일의 일부로 활용하는 아키텍처로 마이크로서비스 아키텍처, 공간 기반 아키텍처가 대표적이다.

### 14.11 아키텍처 특성 등급

단순성이 별 하나.. 아키텍트 입장에선 난이도정도인 것 같다..

기술 분할 아키텍처로 도메인 분할이 아니다.

이벤트 프로세서의 데이터베이스 상호작용 및 요청-응답 처리를 기반으로 하므로 퀀텀 수는 1개 이상 가능하다.

성능, 확장성, 내고장성, 진화성은 5점으로 처음보는 최고점 같다..

비결정적, 동적인 이벤트 흐름때문에 단순성과 시험성은 낮은 편이다.

### 느낀점

30%정도만 이해한 기분.. 댓글 예제와 데이터 소실 방지 부분의 추상적인 기능 정도만 이해가 된 것 같다.

#### 논의사항

논의할 만한 주제를 고르기 너무 어렵네요..

비동기 통신이나 데이터 소실방지, 에러처리는 이 아키텍처에만 종속된게 아니라 개발 레벨이나 다른 아키텍처에도 응용될만한 내용인 것 같습니다.
