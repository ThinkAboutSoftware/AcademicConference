## 12. 마이크로커널 아키텍처 스타일

이미 수십 년 전에 만들어진 마이크로커널 아키텍처는 오늘날에도 많이 쓰이고 있다.

이 아키텍처 스타일은 제품 기반 애플리케이션에 적합하며, 비제품 고객 비즈니스 애플리케이션에서도 많이 쓰인다.

### 12.1 토폴로지

마이크로커널 아키텍처 스타일은 **코어 시스템**과 **플러그인 컴포넌트**라는 두 가지 아키텍처 요소로 구성된 비교적 단순한 모놀리식 아키텍처이다.

애플리케이션 로직은 독립적인 플로그인 컴포넌트와 기본 코어 시스템에 골고루 분산되어 확장성, 적응성, 애플리케이션 기능 분리, 커스텀 처리등을 수행한다.

#### 12.1.1 코어 시스템

코어 시스템은 시스템을 실행시키는 데 필요한 최소한의 기능으로 정의한다.

이클립스(IDE)가 좋은 예이다.

이클립스 코어 시스템은 파일을 열고, 텍스트를 고치고, 다시 파일을 저장하는 기본적인 텍스트 에디터에 불과하다.

플러그인을 추가하여야 비로소 쓸만한 제품이 된다.

코어 시스템은 커스터 처리가 거의/전혀 필요없는, 애플리케이션을 관통하는 정상 경로라고 정의할 수 있다.

코어 시스템의 순환 복잡도를 없애고 별도의 플러그인 컴포넌트를 장착하면 확장성, 유지보수성은 물론 시험성도 좋아진다.

코어 시스템은 규모와 복잡도에 따라 레이어드 아키텍처나 모듈러 모놀리스로 구현할 수 있다.

경우에 따라 코어 시스템은 별도 배포하는 도메인 서비스로 나누어 서비스별 도메인에 특정한 컴포넌트를 둘 수도 있다.

#### 12.1.2 플러그인 컴포넌트

플러그인 컴포넌트는 특수한 처리 로직, 부가 기능, 그리고 코어 시스템을 개선/확장하기 위한 커스텀 코드가 구현된 스탠드얼론 컴포넌트이다.

변동성이 매우 큰 코드를 분리하여 애플리케이션 내부의 유지보수성, 시험성을 높이는 것이다.

이상적인 플러그인 컴포넌트는 상호 독립적이며 의존성이 없다.

플러그인 컴포넌트와 코어 시스템은 일반적으로 점대점통신을 한다.

즉, 코어 시스템에 플러그인을 연결하는 `파이프`는 대부분 플러그인 컴포넌트의 진입점 클래스를 호출하는 메서드나 함수 코드이다.

*`c#`을 예로 인터페이스로 관리한다.*

플러그인 컴포넌트가 반드시 코어 시스템과 점대점 통신을 해야하는 것은 아니다.

각 플러그인을 스탠드얼론 서비스로 만들어 REST나 메시징 등 다른 방법으로 기능을 호출하는 방법도 있다.

### 12.2 레지스트리

코어 시스템이 어떤 플러그인을 사용할 수 있는지, 그 플러그인을 가져오려면 어떻게 해야하는지 알고 있어야 한다.

가장 일반적인 구현 방법은 플러그인 레지스트리를 경유하는 것이다.

레지스트리는 코어 시스템이 소유한 내부 맵 구조처럼 단순할 수도 있고, 레지스트리 및 디스커버리 도구가 코어 시스템이나 외부 배포된 시스템에 내장된 복잡한 형태일 수도 있다.

### 12.3 계약

플러그인 컴포넌트와 코어 시스템 간의 계약은 보통 플러그인 컴포넌트의 도메인 단위로 표준화되어 있고, 플러그인 컴포넌트가 수행하는 기능 및 입출력 데이터는 계약에 명시되어 있다.

### 12.4 실제 용례

이클립스, 젠킨스 등 많은 소프트웨어 개발/릴리스 도구가 마이크로커널 아키텍처 스타일을 사용한다.

크롬또한 마이크로커널 아키텍처를 응용한 제품으로 각종 뷰어와 플러그인이 장착가능하다.

VsCode도 마이크로 커널 아키텍처인 것 같다.

### 12.5 아키텍처 특성 등급

레이어드 아키텍처와 같이 단순성과 전체비용이 주요 강점이다.

반면 고질적인 모놀로식 배포 탓에 탄력성, 내고장성, 확장성이 문제가 될 때가 많다.

모든 요청은 코어 시스템을 통해 유입되어 독립적인 플러그인 컴포넌트로 흘러가므로 퀀텀은 언제나 1이다.

마이크로 커널 아키텍처는 도메인 분할, 기술 분할이 모두 가능한 유일한 아키텍처 스타일이다..!

기능을 독립적인 플러그인 컴포넌트로 분리할 수 있으므로 시험성, 배포성, 신뢰성은 평균보다 약간 높게 책정된다.

모듈성은 3개, 성능도 3개이다.

### 느낀점

마이크로 커널 아키텍처가 이거구나 정도로 이해한 것 같다..  

#### 논의사항
