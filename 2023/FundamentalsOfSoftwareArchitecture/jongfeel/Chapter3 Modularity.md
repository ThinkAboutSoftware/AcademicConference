## CHAPTER 3 모듈성modularity

```
논의내용)
이 챕터는 논의내용 꺼내기가 쉽지는 않네요.
그런데 흥미로운 점은 제가 클린 아키텍처에서 봤던 메인 시퀀스(Main Sequence)가 여기서도 나온다는 점입니다. 그리고 클린 아키텍처에서 설명하기로는 이게 자신이 생각하는 측정 방법이라고 소개했는데 여기서는 공식적인(?) 방법인 것 처럼 소개하고 있다는 점입니다.

결론은 추상화를 해 놓지 않으면 고통스러울 수 밖에 없다 얘기인데, 최근에 작성한 자신의 코드가 얼마나 추상화된 부분이 많은지 얘기해 보면 어떨까 합니다.
```

> 소프트웨어 아키텍처 용어의 95%는 '모듈성'의 이로움을 찬양하는 데 사용되고 있지만, 정작 모듈성을 어떻게 달성할지에 대해서는 별다른 얘기가 없다. - 글렌포드 J. 마이어스Glenford J.Myers, 1978년

플랫폼마다 제공하는 코드 재사용 메커니즘은 제각각이지만, 연관된 코드를 모듈로 묶는 방법은 모두 지원한다. 하지만 모듈성은 사실 제대로 정의하기 쉽지 않은 개념이다.

본인이 선택한 개발 플랫폼에서 모듈성과 그것을 구현한 수많은 코드를 이해하는 것은 아키텍트에게 대단히 중요한 일이다. 아키텍트는 끊임없이 에너지를 소비해서 시스템을 구조적으로 탄탄하게 유지해야 한다.

모듈성을 잘 유지하는 건 암묵적implicit 아키텍처 특성이라고 정의한 것의 좋은 예이다.

### 3.1 정의

모듈성의 사전적 정의는 '복잡한 구조를 만드는 데 쓰이는 각각의 표준화한 부품이나 독립적인 단위'이다.

아키텍트는 개발자가 코드를 어떻게 패키징하는지에 따라 아키텍처에 중요한 영향을 미치기 때문에 반드시 알아야 한다. 패키지가 커플링 되어 잇으면 그 중 하나를 다른 작업에 재사용하기가 어려워진다.

아키텍처를 논할 때 클래스, 함수처럼 코드를 묶어 놓은 덩어리를 모듈성이라는 일반 용어로 나타낸다. 이것은 논리적인 구분이지 물리적인 구분은 아니라서 이런 차이점이 중요한 경우가 있다. 모놀리식 애플리케이션은 한 덩어리로 묶어도 상관 없지만 아키텍처를 재구축할 때에는 커플링된 구조가 모놀리스를 나누는데 걸림돌이 된다.
따라서 모듈성은 특정 플랫폼에 함축되어 있거나 불가피한 물리적인 분리와 다른 개념으로 봐야 한다.

### 3.2 모듈성 측정

아키텍트가 모듈성을 이해하는 데 도움이 되는 다양한 언어 독립적인 메트릭을 선배들이 만들어 놌다.

```
그냥 의견)
선배들이 만들어 놨다는 부분에서 기분좋은 걸 느꼈는데, 나도 선배들이 만들어 놓은 길에 대한 이유와 목적을 이해하는게 즐겁기 때문이기도 하다. 
```

#### 3.2.1 응집

응집cohesion은 한 모듈의 파트(구성 요소)가 동일한 모듈 안에 얼마나 포함되어 있는지를 나타낸다.

> 응집된 모듈을 나누려고 해봐야 더 커플링되고 가독성은 떨어진다. - 래리 콘스탄틴Larry Constantine

응집도의 측정 범위를 정의했는데 좋은 것 순서대로 나열하면

- 기능적 응집functional cohesion: 기능상 꼭 필요한 모든 것이 모듈에 들어 있다
- 순차적 응집sequential cohesion: 한쪽이 데이터를 출력하면 다른 한쪽이 그것을 입력받는 형태
- 소통적 응집communication cohesion: 두 모듈이 각자 정보에 따라 작동하고 출력을 내는 형태로 통신 체인을 형성
- 절차적 응집procedural cohesion: 정해진 순서대로 실행
- 일시적 응집temporal cohesion: 시스템이 시작할 때 관련 없는 것들에 대한 초기화 작업
- 논리적 응집logical cohesion: 연관된 작업이지만 하는 일이 다른 것들. 자바의 StringUtils 패키지
- 동시적 응집coincidental cohesion: 소스 파일에 연관 없는 코드가 들어 있음

아키텍트의 재량에 따라 측정된 모듈의 응집도는 다르고, 트레이드 오프가 발생한다.

컴퓨터 과학자들은 응집의 주관성subjectiveness을 전제로, 응집도를 가늠할 수 있는 구조적 메트릭을 개발했다. '카이댐버와 케메러의 객체 지향메트릭 스위트Chidamber and Kemerer object-oriented metrics suite'는 객체지향 소프트웨어 시스템의 특정 부분을 측정하는 유명한 메트릭 세트이다.

카이댐버와 케메러가 개발한 '메서드의 응집 결여도Lack of Cohesion in Methods(LCOM)'는 모듈의 구조적 응집도를 나타낸다.
LCOM 메트릭은 클래스 내부의 부차적인 커플링을 나타내는데 `공유 필드를 통해 공유되지 않는 메서드의 총 개수`로 정의할 수 있다. LCOM 점수가 낮으면 구조적 응집이 우수하다고 판단할 수 있다.

LCOM 메트릭은 아키텍처 스타일을 전환하기 위해 코드베이스를 분석하는 아키텍트에게 매우 유용하다. 이걸 활용하면 어쩔 수 없이 커플링된 클래스, 처음부터 한 클래스가 아니었던 클래스를 발견하는 데 도움이 된다.

하지만 LCOM의 모든 메트릭이 찾아내는 것은 '구조적' 응집 결여도일 뿐, 이 메트릭만으로 어떤 조각들이 서로 잘 맞는지 논리적으로 판단할 수는 없다. '왜'보다 '어떻게'가 중요한 소프트웨어 아키텍처 제2법칙에 따른 것이기 때문이다.

#### 3.2.2 커플링

코드베이스의 커플링은 그래프 이론에 기반한 좋은 분석 도구들이 많이 있다. 에드워드 요던Edward Yourdon과 래리 콘스탄틴Larry Constantine이 지은 <Structured Design> 에는 구심afferent 커플링, 원심efferent 커플링을 비롯한 중요한 개념들이 있다. 구심 커플링은 코드 아티팩트로 유입되는 접속 수, 원심 커플링은 다른 코드 아티팩트로 유출되는 접속 수를 나타낸다.

#### 3.2.3 추상도, 불안정도, 메인 시퀀스로부터의 거리

추상도abstractness는 추상 아티팩트abstract artifact와 구상 아티팩트concrete artifact의 비율, 즉 구현 대비 추상화 정도를 나타낸다.

예로 5천라인에 달하는 코드가 전부 main() 메서드에 구현되어 있다면 1/5000으로 추상도는 0에 가깝다.

아키텍트는 추상 아티팩트의 총 개수와 구상 아티팩트의 총 개수로 추상도를 계산한다.
여기서 파생된 불안정도instability는 원심 커플링과의 비율이다. 불안정도는 코드베이스의 변동성volatility을 의미하므로 불안정도가 높은 코드 베이스는 변경 시 커플링이 높아 더 깨지기 쉽다.

#### 3.2.4 메인 스퀀스로부터의 거리

메인 시퀀스로부터의 거리distance from the main sequence는 아키텍처 구조를 평가하는 몇 가지 전체적인 메트릭 중 하나로, 불안정도와 추상도를 이용하여 계산한다.

D = | A + I - 1 |
(A는 추상도, I는 불안정도)

![image](https://user-images.githubusercontent.com/17442457/229843819-c42fb285-e5dc-4031-ac0f-d4271d98faa5.png)

이 선에 가까울 수록 클래스 균형이 잘 맞는다는 방증이 된다.
오른쪽 위로 치우친 부분은 쓸모없는 구역zone of uselessness (추상화를 많이 해서 사용하기 어려운 코드)
왼쪽 아래로 치우친 부분은 고통스런 구역zone of pain(추상화를 거의 안 하고 구현 코드만 잔뜩 넣어 취약하고 관리하기 힘든 코드)이다.

```
의견)
이 내용은 로버트 마틴의 <클린 아키텍처>에도 소개된 내용인데 여기서도 나온거 보면 '아키텍처'라고 부르는 같은 방향의 지식이라고 이해할 수 있을 것 같다.
```

이런 메트릭을 측정하는 도구를 통해 생서홈unfamiliarity, 마이그레이션, 기술 부채 평가 등의 사유로 아키텍트가 코드베이스를 분석할 때 도움이 된다.

#### 3.2.5 커네이선스

밀러 페이지-존스Meilir Page-Jones는 1996년에 <What Every Programmer Should Know About Object-Oriented Design>에서 구심/원심 커플링 메트릭을 더욱 발전시킨 커네이선스connascence 개념을 객체 지향 언어의 화두로 던졌다.
커네이선스는 변화 종속성의 뜻으로, 어느 한쪽을 바꾸면 다른 쪽도 함께 바꾸어야 전체적으로 정합성이 유지되는 상태를 뜻한다.

> 두 컴포넌트 중 한쪽이 변경될 경우 다른 쪽도 변경해야 전체 시스템의 정합성이 맞는다면 이들은 커네이선스를 갖고 있는 것이다. - 밀러 페이지-존스

**정적 커네이선스**

정적 커네이선스 static connascence는 소스 코드 레벨의 커플링으로, <Structured Design>에서 등장하는 구심/원심 커플링을 발전시킨 개념이다. 아키텍트는 구심적인든, 원심적이든 다음 종류의 정적 커네이선스를 뭔가에 커플링된 정도라고 보는 것이다.

- 명칭 커네이선스(CoN): 여러 컴포넌트의 엔티티명이 일치해야 한다.
- 타입 커네이선스(CoT): 여러 컴포넌트의 엔티티 타입이 일치해야 한다.
- 의미 커네이선스(CoM) 또는 관례 커네이선스(CoC): 여러 컴포넌트에 걸쳐 어떤 값의 의미가 일치해야 한다.
- 위치 커네이선스(CoP): 여러 컴포넌트는 값의 순서가 일치해야 한다.
- 알고리즘 커네이선스(CoA): 여러 컴포넌트는 특정 알고리즘이 일치해야 한다.

**동적 커네이선스**

동적 커네이선스dynamic connascence는 런타임 호출을 분석하는, 페이지-존스가 정의한 또 다른 유형의 커네이선스이다.

- 실행 커네이선스(CoE): 여러 컴포넌트의 실행 순서가 중요하다
- 시점 커네이선스(CoT): 여러 컴포넌트의 실행 시점이 중요하다
- 값 커네이선스(CoV): 상호 연관된 다수의 값들을 함께 변경할 때 발생한다
- 식별 커네이선스(CoI): 여러 컴포넌트가 동일한 엔티티를 참조할 때 발생한다

**커네이선스 속성**

커네이선스는 아키텍트와 개발자에게 유용한 분석 도구이다.

강도

아키텍트는 개발자가 어떤 유형의 커네이선스를 얼마나 쉽게 리팩터링할 수 있는지에 따라 커네이선스 강도strength를 결정한다. 그리고 더 나은 유형의 커네이선스를 리팩터링해서 코드베이스의 커플링 특성을 개선할 수 있다.

![image](https://user-images.githubusercontent.com/17442457/229852256-39c72ca2-410d-4e6d-8447-625485d7c650.png)

지역성

커네이선스의 지역성locality은 코드베이스의 모듈들이 서로 얼마나 가까이 있는가이다. 동일한 모듈에서 근접한 코드는 보통 더 분리된 코드보다 높은 형태의 커네이선스를 가진다. 즉, 모듈을 서로 떨어뜨렸을 때 커플링이 형편없는 형태의 커네이선스는 모듈을 서로 가까이 붙여 놓는 식으로 개선할 수 있다. 동일한 모듈에서 더 강한 형태의 커네이선스가 발견된다면 그와 동일한 커네이선스가 널리 흩어져 있는 것보다는 코드 스멜이 덜하다는 증거이다.

정도

커네이선스의 정도degree는 커네이선스가 미치는 영향의 규모(소수의 클래스 혹은 수많은 클래스에 영향을 미치는가)에 관한 것이다. 모듈이 몇 개 안된다면 동적 커네이선스가 높아도 별로 해롭지 않지만, 일반적으로 코드베이스는 점점 커지게 마련이니 사소한 문제도 점점 더 악화될 것이다.

페이지-존수는 커네이선스를 이용해 시스템의 모듈성을 개선하는 세 가지 방법을 제시한다.

- 시스템을 캡슐화한 요소들로 잘게 나누어 전체 커네이선스를 최소화한다
- 캡슐화 경계를 벗어나는 나머지 커네이선스를 모조리 최소화한다
- 캡슐화 경계 내부에서 커네이선스를 최대화한다

짐 웨이리치Jim Werich는 커네이선스 개념을 대중화하면서 두 가지 조언을 남겼다.

- 정도의 규칙Rule of Degree: 강한 형태의 커네이선스를 보다 약한 형태의 커네이선스로 전환하라
- 지역성의 규칙Rule of Locality: 소프트웨어 엘리먼트 간의 거리가 멀어질수록 보다 약한 형태의 커네이선스를 사용하라

#### 3.2.6 커플링과 커네이선스 메트릭을 통합

아키텍트 관점에서는 시기와 목표가 상이한 커플링과 커네이선스가 서로 중첩된다. 구조적 프로그래밍은 들어오고 나가는 것에만 관심이 있는 반면, 커네이선스는 여러 가지 요소가 서로 어떻게 커플링되는지에 주목한다.

**1990년대 커네이선스의 문제점**

여기에서 소개된 메트릭을 적용해서 시스템을 분석/설계할 때에는 몇 가지 문제점이 있다.

- 이런 메트릭은 아키텍처 구조보다는 저수준 코드의 세부분을, 코드 품질 및 정리 상태 위주로 관찰한다. 아키텍트 입장은 커플링 정도 보다 모듈이 어떻게 커플링되어 있는지가 더 궁금하다는 의미이다.
- 커네이선스 자체는 요즘 아키텍트가 내려야 할 근본적인 결정에 관한 문제는 다루지 않는다. 소프트웨어 아키텍처의 법칙에 따르면 모든 것이 다 트레이드오프이다.

### 3.3 모듈에서 컴포넌트로

연관된 코드 묶음을 '모듈'이라는 일반 용어로 표현하지만, 대부분의 플랫폼은 소프트웨어 아키텍트에게 핵심 구성 요소 중 하나인 '컴포넌트' 형태로 지원한다.
논리적, 물리적 분리에 관한 개념과 그에 따른 분석은 컴퓨터 과학 초창기부터 존재했지만, 아직도 컴포넌트와 분리에 관한 수많은 글과 의견들이 쏟아져 나오고 있어서 개발자와 아키텍트는 좋은 결과를 내기 위해 애를 써야 한다.