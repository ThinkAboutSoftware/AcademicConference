## CHAPTER 16 오케스트레이션 기반 서비스 지향 아키텍처 스타일

```
인상깊은 내용)
사실 마이크로서비스 아키텍처로 가는 빌드업의 스타트인 서비스 기반 아키텍처 정도면 괜찮은데 더 좋은게 있나? 했다가
갑자기 이 챕터에서 안좋은 아키텍처 사례로 훅 들어오는 것과 저자가 잘 돌려서 욕하는 부분이 참 재미있었던 챕터였습니다.

2000년대 초반 자바로 만들었던 분산 메시징 모델 기반의 서버 아키텍처가 있었는데
그걸 저격하고 쓴 챕터가 아닌가 하고 끝까지 봤지만 특정 기술이나 명칭이 언급되지 않아서
뭔가 많이 가려운 부분을 속 시원하게 긁어주지 못한 점도 참 흥미로웠던 것 같습니다.
```

얼핏 논리적으로 보이지만 궁극적으로는 재앙과도 같은 조직 철학과 결부되어 얼토당토 않은 이 아키텍처가 탄생하게 되었다.
한 조직의 아이디어가 개발 프로세스에서 가장 중요한 부분을 어떻게 망쳐놓는지 잘 나타낸 사례이다.

### 16.1 역사와 철학

1990년대 후반에 등장했지만, 컴퓨팅 리소스가 넉넉치 못했고 사용 제품들이 쓸만했다. 분산 컴퓨팅은 이제 막 수요가 늘기 시작했지만 많은 기업들은 가변적인 확장성 등의 유용한 특성을 요구했다.

이 시대의 아키텍트는 다양한 외부 여건 탓에 어쩔 수 없이 제약이 많은 분산 아키텍처를 구축했다.
아키텍트는 최대한 재사용하는 것을 목표로 삼게 되었고, 실제 모든 형태의 재사용은 이 아키텍처의 중심 철학이 되었다.

아키텍트가 기술 분할에 집착하면 어떻게 되는지 잘 보여주는 사례이다. 취지는 좋았지만 결과가 좋지 않았다.

### 16.2 토폴로지

<img width="459" alt="image" src="https://github.com/jongfeel/BookReview/assets/17442457/82ecc256-5698-4ba7-8161-1c0b6db054b6">

아키텍처 내부에 서비스 택소노미taxonomy(분류체계)를 정립하여 레이어별로 책임을 지운다는 아이디어이다.

### 16.3 택소노미

이 아키텍처의 중심 철학은 엔터프라이즈 레벨의 재사용이다. 이 목표는 텍소노미의 각 레이어를 통해 실현할 수 있다.

#### 16.3.1 비즈니스 서비스

비즈니스 서비스는 진입점 역할을 한다. 코드는 전혀 없고, 입력, 출력, 스키마 정보만 가지고 있다.
서비스는 대부분 비즈니스 유저가 정의하기 때문에 비즈니스 서비스이다.

#### 16.3.2 엔터프라이즈 서비스

엔터프라이즈 서비스는 세분화된 공유 구현체를 포함한다. 이 서비스는 오케스트레이션 엔진을 통해 묶인, 단위가 큰 비즈니스 서비스를 구성하는 요소들이다.

비즈니스는 재사용 가능한 엔터프라이즈 서비스 형태로 재사용 가능한 자산을 구축할 수 있을 거라고 믿었다. 소프트웨어 세계는 시장, 기술 변화, 엔지니어링 프랙티스, 그 밖의 다양한 팩터 때문에 안정성을 추구해도 그렇게 잘 안 된다.

#### 16.3.3 애플리케이션 서비스

애플리케이션 서비스는 한 번만 사용 가능한 단일 구현체 서비스이다. 

#### 16.3.4 인프라 서비스

인프라 서비스는 모니터링, 로깅, 인증/인가 등의 운영 관심사를 지원한다. 이런 서비스는 운영팀과 긴밀하게 협업하는 공유 인프라팀이 소유한 실질적인 구현체인 경우가 많다.

#### 16.3.5 오케스트레이션 엔진

오케스트레이션 엔진은 이 분산 아키텍처의 요체이다. 이 엔진은 비즈니스 서비스 구현체를 서로 엮어주며 트랜잭션 조정과 메시지 변환 등의 기능을 수행한다.

오케스트레이션 엔진은 비즈니스와 엔터프라이즈 서비스의 관계, 매핑하는 방법, 트랜잭션 경계는 어디까지인지 등을 정의한다. 또 통합 허브 역할도 겸하고 있어서 아키텍트가 커스텀 코드를 패키지와 레거시 소프트웨어 시스템에 통합할 수 있다.

이 매커니즘은 이 아키텍처의 핵심이므로 콘웨이의 법칙에 따라, 이 엔진을 담당한 통합 아키텍트팀이 조지에서 점점 정치 세력화되고 언젠가 관료적인 병목bureaucratic bottleneck이 될 것이다.

트랜잭셔널 로직을 오케스트레이션 도구에 위임한다는 아이디어는 그럴 듯 했으나, 트랜잭션을 정확히 어느 레벨까지 세분화 해야 하는지는 어려워졌다. 서비스 간의 적절한 트랜잭션 경계가 어디쯤인지 개발자가 알아내야 했으므로 아키텍처는 한층 복잡해졌다.

#### 16.3.6 메시지 흐름

모든 요청은 오케스트레이션 엔진을 흘러간다. 내부 호출 메시지도 역시 엔진을 경유한다.

<img width="460" alt="image" src="https://github.com/jongfeel/BookReview/assets/17442457/b7ac3440-6186-4c11-ab72-65ad9e99d586">

서비스 버스는 아키텍처 내부의 모든 호출을 중계하면서 통합 허브와 오케스트레이션 엔진, 두 가지 역할을 한다.

#### 16.4 재사용... 그리고 커플링

이 아키텍처의 주된 목표는 서비스 레벨의 재사용, 즉 재사용 가능한 비즈니스 행위를 점진적으로 구축하는 능력이다.

<img width="465" alt="image" src="https://github.com/jongfeel/BookReview/assets/17442457/1f345ed2-98f9-4f63-8b57-0700e8fa8b60">

위 그림에서 아키텍트는 보험 회사의 모든 부서에 Customer라는 개념이 포함되어 있다는 사실을 알아낸다. 서비스 지향 아키텍처 관점에서 고객 관련된 부분은 재사용 가능한 서비스로 묶어서 참조하도록 만드는 것이 전략이 된다.

<img width="463" alt="image" src="https://github.com/jongfeel/BookReview/assets/17442457/5dd7f816-a862-41fa-9c16-aa9b1ed539c7">

그래서 위 그림처럼 고객의 모든 행위를 하나의 Customer 서비스로 분리해서 재사용 목표를 달성하게 된다.

그리고 문제점이 드러나는데

재사용 위주로 시스템을 구축하게 되면 컴포넌트 간의 커플링이 심하게 발생한다. 즉 Customer 서비스를 변경하면 다른 모든 서비스에 영향을 미칠 수 밖에 없으므로 엄청난 리스크가 발생한다. 그러면 변경에 대해 커플링이 발생한다는 사실을 무시할 수 없으므로 점진적 변화를 추구하기 어렵게 된다. 결국 배포를 하면서 전체 테스트를 해야 하고 엔지니어링 효율 측면에서 난관에 봉착하게 된다.

또 다른 부작용을 일으키는데, Customer 서비스는 고객에 관한 상세 정보를 담아야 한다. 하지만 서비스 별로 필요한 고객 정보는 다를 수 있는데 장애 보험팀은 관심사가 아닌 자동차 보험에서 필요한 운전 면허증의 세부 정보를 불필요하게 가지고 있어야 한다.

분리와 재사용 철학의 관점에서는 일리가 있어 보였지만 문제점이 많이 드러나는 방식이다.

#### 16.5 아키텍처 특성 등급

이 아키텍처가 인기가 있을 시절은 애자일 소프트웨어 프랙티스는 이제 막 시작된 상태였기에 아키텍처 평가 기준은 이 시기를 생각해 봤을 때 덜 중요하다.

서비스 지향 아키텍처는 가장 기술적으로 분할된 범용 아키텍처이다. 이 구조의 단점이 마이크로서비스 아키텍처의 탄생을 이끌게 되었다.

분산 아키텍처임에도 불구하고 아키텍처 퀀텀은 1개인데

- 단일 데이터베이스 또는 2~3개의 데이터베이스를 사용하여 상이한 관심사를 포괄하는 아키텍처 커플링 지점을 형성한다
- 오케스트레이션 엔진이 거대한 커플링 지점 역할을 한다.

그래서 모놀리식과 분산 아키텍처 모두의 단점을 갖고 있다.

<img width="474" alt="image" src="https://github.com/jongfeel/BookReview/assets/17442457/d0bed31d-0d19-4933-85a6-bf131f709744">

배포성, 시험성은 별점이 낮은데, 이 아키텍처가 태동할 시대에는 그런 특성들이 제대로 지원되지 않았고, 중요한 목표도 아니었기 때문이다.

탄력성, 확장성 같은 특성을 일부 지원하지만 구현하기는 상당히 까다롭다. 개발 벤더가 애플리케이션 서버 등 다른 기술 전반에 걸쳐 세션 복제를 구축했고 그렇게 확장 가능한 시스템을 만들고자 노력을 했기 때문이다. 분산 아키텍처라 성능은 주요 관심사로 주목받지 못했고, 각 비즈니스 요청이 아키텍처 여러 부분에 흩어져 있어서 실제로 성능은 형편없었다.

이 아키텍처는 분산 트랜잭션이 실세계에서 얼마나 구현이 어려운지, 기술 분할의 실제 한계가 무엇인지 가르쳐준 중요한 이정표였다.