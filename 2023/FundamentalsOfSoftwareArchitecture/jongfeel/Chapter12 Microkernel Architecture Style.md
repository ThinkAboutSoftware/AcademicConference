## CHAPTER 12 마이크로커널 아키텍처 스타일

```
논의내용)
논의 내용 외에 내용 정리하면서 의견을 많이 달았었는데,
저는 유니티를 많이 쓰다 보니 유니티가 가지고 있는 asset이라는 것이
플러그인 컴포넌트라는 것으로 이해될 수 있고
그게 아키텍처 스타일이 될 수도 있구나를 받아들였던 것 같습니다.
모놀리식으로는 이 아키텍처가 최선이라고 생각하는데
최근에 트렌드를 보면 책에서 언급한 IDE의 예제도
결국엔 웹 환경으로 전환이 되지 않을까 하는 생각이 더 큽니다.
왜냐하면 이미 가벼운 텍스트 에디터 기반 IDE는 웹으로 가능한 걸 보면
유니티도 나중에 웹 에디터가 나오지 않을까 하는 생각으로 발전이 되더라고요.

혹시 모놀리식 아키텍처에서 조금 더 발전적으로 생각을 해보신 분이 있다면 얘기해 보면 좋을 것 같습니다.
```

수십 년 전에 만들어져서 지금도 쓰이고 있는 아키텍처이며 플러그인 아키텍처plug-in architecture라고도 한다.
단일 모놀리식 배포 단위로 패키징해서 다운로드 및 설치가 가능하며, 고객 사이트에서 서드파티 제품으로 설치되는 제품 기반product-based 애플리케이션에 적합하며, 비제품nonproduct 고객 비즈니스 애플리케이션에도 사용된다.

### 12.1 토폴로지

코어 시스템core system과 플러그인 컴포넌트plug-in component라는 두 가지 아키텍처 요소로 구성된 단순한 모놀리식 아키텍처이다.

<img width="480" alt="image" src="https://user-images.githubusercontent.com/17442457/235701780-bd810d86-4d9e-4341-9bc0-c3a540871187.png">

#### 12.1.1 코어 시스템

코어 시스템은 시스템을 실행시키는데 필요한 최소한의 기능으로 정의한다. 이클립스 IDE가 좋은 예 중에 하나이다.
이클립스에서 코어 시스템은 파일 열기/닫기/저장, 텍스트 에디터 등의 기본적인 기능만 있고, 플러그인을 추가해야 쓸만한 제품이 된다. 코어 시스템은 커스텀 처리가 필요 없는 정상 경로happy path라고 정의할 수 있다.

코어 시스템은 규모나 복잡도에 따라 레이어드 아키텍처나 모듈러 모놀리스로 구현할 수 있다. 경우에 따라 코어 시스템을 별도 배포하는 도메인 서비스로 나눠서 서비스별 도메인에 특정한 플러그인 컴포넌트를 둘 수도 있다.

<img width="490" alt="image" src="https://user-images.githubusercontent.com/17442457/235703345-d9a7db0f-9b29-44c6-81ad-c9b5bd5eccd7.png">

#### 12.1.2 플러그인 컴포넌트

변동성이 큰 코드를 유지보수성이나 시험성을 높이기 위해 컴포넌트로 만드는 것이다.
그러므로 이상적인 컴포넌트의 경우는 상호 독립적이며 의존성이 없다.

```
의견)
유니티로 치면 코어 시스템은 유니티 에디터이고 플러그인 컴포넌트는 유니티 애셋 패키지라고 볼 수 있을 것 같다.
유니티도 결국 스탠드 얼론 형태에 가깝고 레이어드나 파이프 라인 아키텍처라고 보기에는 어렵기 때문에
유니티 에디터는 이 아키텍처 스타일을 따른다고 설명할 수 있을 것 같다.
단!
실제 scene에 object로 배치했을 때의 의존성의 방향에 대해서는 개발자의 노력이 필요한 부분이 있다.
```

코어 시스템에 플러그인을 연결하는 '파이프'는 플러그인 컴포넌트의 진입점 클래스를 호출하는 메서드나 함수 코드이다.
플러그인 컴포넌트는 컴파일 기반 혹은 런타임 기반으로 만들 수 있다. 런타임 플러그인의 경우는 런타임에 코어 시스템이나 다른 플러그인을 재배포하지 않고도 바로 추가/삭제가 가능하다.
자바 SIGiOpenService Gateway Initiative나 Penrose, Jigsaw가 있고
닷넷은 Prism등의 프레임워크를 통해 관리한다.

```
의견)
여기까지 설명을 봤을 때는 로버트 마틴의 클린 아키텍처 구조를 설명하는 부분과 매우 유사하다.
즉, 클린 아키텍처에서는 마이크로커널 아키텍처라는 이름을 사용하지는 않았지만
각 플랫폼별 라이브러리 이름을 언급하고 있는 방향이 매우 유사하다. 
특히 자바, 닷넷, 루비를 언급하는 순서도 같다!
```

각 플러그인 컴포넌트는 코드베이스나 IDE 프로젝트 내부의 개별 네임스페이스 또는 패키지명으로 구현하면 더 알기 쉽게 파악할 수 있다.

플러그인 컴포넌트가 반드시 코어 시스템과 점대점 통신을 해야 하는 것은 아니다. 각 플러그인을 스탠드얼론(또는 컨테이너에 구현한 마이크로서비스)로 만들어 REST나 메시징 등 다른 방법으로 기능을 호출하는 방법도 있다.
이 방법은 확장성을 개선하는 방법일 수 있지만, 코어 시스템이 모놀리식이므로 단일 아키텍처 퀀텀으로 보는게 맞다. 즉, 모든 요청이 코어 시스템을 거쳐 각 플러그인 서비스로 흘러가는 구조이기 때문이다.

<img width="475" alt="image" src="https://user-images.githubusercontent.com/17442457/235707870-efb4b8a9-543b-43d4-9073-0d0f2b34cbaf.png">

그래도 플러그인 컴포넌트를 개별 서비스로 원격 액세스 하는 방법은

- 전체 컴포넌트의 커플리이 낮아져 확장성과 처리량이 개선되고
- OSGi, 직소, 프리즘 등의 프레임워크 없이 런타임 변경이 가능하며
- 플러그인과 비동기 통신도 가능하게 구성할 수 있으므로, 경우에 따라 전체 유저 반응성을 끌어올릴 수 있다.

하지만 이런 장점에도 불구하고 단점도 존재하는데

- 모놀리식이 아닌 분산 아키텍처로 가면 좋은데 코어 시스템이 모놀리식이다 보니 서드파티 온프레미스 제품은 구현/배포가 쉽지 않고 복잡도와 비용이 높아져 배포 토폴로지가 난해하게 된다.
- 플러그인이 무응답이거나 작동되지 않는 경우도 고려해야 아므로

역시 트레이드오프가 발생한다.

플러그인 컴포넌트는 코어 시스템의 데이터베이스에 접속할 일이 없다. 구조 자체가 디커플링 되어 있으므로 데이터베이스를 변경하면 코어 시스템에만 영향을 끼치고 플러그인 컴포넌트에는 영향을 끼치지 않으므로 각자 자기만 액세스 가능한 데이터 저장소를 따로 가질 수도 있다.

<img width="474" alt="image" src="https://user-images.githubusercontent.com/17442457/235709783-ae9ff457-7e10-4c6b-889b-11b1eca6cd1f.png">

### 12.2 레지스트리

코어 시스템은 어떤 플러그인을 사용할 수 있는지, 그 플러그인을 가져오려면 어떻게 해야 하는지 알고 있어야 한다.

```
의견)
레지스트리까지 나온 거면 확실히 유니티와 애셋의 관계를 정말 잘 표현한 것이라고 다시 확신하게 된다.
솔직히 npm 레지스트리와 너무 닮아 있다.
지금 생각해 보니까 node 기반으로 개발한 개발자는 npm을 먼저 떠올렸을 수도 있을 것 같다.
예제 코드를 java 형태가 아니라 보통 많이 쓰는 json 형태로 보여줬으면 더 이해가 쉬웠을 것 같다.
```

### 12.3 계약

코어 시스템과 플러그인 컴포넌트와는 계약 관계가 있고 도메인 단위로 표준화 되어 있으며 수행하는 기능 및 입출력 데이터는 계약에 명시되어 있다.
일반적으로 코어 시스템이 각 플러그인별 코드를 필요로 하지 않도록 플러그인 계약과 내부에서 정한 표준 계약 간의 어댑터를 만든다.

```
의견)
생각해 보니 json 형태의 패키지 정보가 담겨 있는 건 메타 정보만 표현한 것이고
실제로 읽어 들여서 임포트 하는 과정까지 거치려면 계약에 맞게 코드가 작성되어야 하고
그 이후에 로드를 하는 방식으로 하는 게 맞다고 여겨진다.
```

### 12.4 실제 용례

이클립스 IDE, PMD, jira, jenkins등 많은 소프트웨어 개발/릴리스 도구는 마이크로커널 아키텍처를 사용해서 개발했다.
크롬, 파이어폭스 역시 마이크로커널 아키텍처를 응용한 제품으로 플러그인 설치를 하면 코어 시스템에 해당하는 기본 브라우저에는 없는 부가 기능을 덧붙일 수 있다.

```
의견)
크롬에서 플러그인을 설치하는 걸 아키텍처 스타일이라고 생각해 본 적은 없는데 
이 책을 통해 아키텍처 스타일 분류를 해볼 수 있다 까지는 이해가 된 것 같다.
``` 

이 아키텍처는 대규모 비즈니스 애플리케이션에도 적용할 수 있다.
관할 구역별 보험금 청구 규칙을 별도의 스탠드얼론 플러그인 컴포넌트에 보관한다. 그러면 다른 시스템 파트에 영향을 주지 않고 특정 관할 구역의 규칙을 추가, 삭제, 변경할 수 있다. 이후 관할 구역을 새로 추가하거나 기존 관할 구역을 삭제해도 다른 시스템 파트에는 영향이 없다.

세무 신소 소프트웨어도 좋은 예이다. 한 사람이 납부해야 할 세액 계산에 필요한 정부가 있는 세무 양식이 있는데 이 양식은 줄마다 단일 수치를 계산하기 위해 많은 다른 양식과 워크시트를 필요로 한다. 여기서 각각의 부가 양식과 워크시트는 플러그인 컴포넌트로 개발하고 세무 양식에 따라 집계를 하는 코어 시스템을 만들면 좋은 방법일 수 있다.

### 12.5 아키텍처 특성 등급

<img width="479" alt="image" src="https://user-images.githubusercontent.com/17442457/235714599-235b99a5-9e04-47c6-9896-b9c251282d1a.png">

단순성과 전체 비용은 주요 강점으로 볼 수 있다. 고질적인 모놀리식 배포 탓에 탄력성, 내고장성, 확장성이 문제가 될 때가 많다. 모든 요청은 코어 시스템을 통해 플러그인 컴포넌트로 흘러가므로 퀀텀은 언제나 1이다. 여기까지가 레이어드 아키텍터와의 유사성이다.

마이크로커널 아키텍처는 도메인 분할, 기술 분할이 모두 가능한 유일한 아키텍처 스타일이다. 마이크로커널 아키텍처는 대부분 기술 분할할 수 있지만 도메인 분할 역시 강력한 도메인 대 아키텍처 동형성domain-to-architecture isomorphism을 통해 실현된다.

기능을 독립적인 플러그인 컴포넌트로 분리할 수 있으므로 시험성, 배포성, 신뢰성은 평균보다 높게 볼 수 있다.

모듈성은 3점이지만 높게 책정할 수 있다. 이 아키텍처 스타일에서는 플러그인 컴포넌트가 별도로 기능을 추가, 삭제, 변경할 수 있고 애플리케이션을 개선/확장하는 작업이 비교적 용이해서 변경에 신속하게 대응이 가능하다.

이 스타일은 아키텍처 싱크홀과 같은 안티패턴 떄문에 고생할 일이 없고 불필요한 기능은 해제해서 처리 흐름을 간소화할 수 있다.