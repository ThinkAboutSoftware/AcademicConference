## CHAPTER 17 마이크로서비스 아키텍처 스타일

```
인상깊은 내용)
마이크로서비스 아키텍처가 끝판왕인줄 알았으나... 사실 이 아키텍처도 나름의 트레이드오프가 있다는 걸 알았다.
그런데도 개발자들은 왜 이게 최신 유행이고 좋은 아키텍처라고 믿고 구현하고 싶어하는 것인지 잘 모르겠다.

지금 회사 서비스는 도메인 별 마이크로서비스를 구현하고 있는데
체크해 봐야 할 내용들이 있어서 살펴 보려 한다.

데이터 격리
운영 재사용을 위한 사이드카 패턴
프로토콜 인지 이종 간 상호 운용성protocol-aware heterogeneous interoperability
도메인/아키텍처 동형성domain/architecture isomorphism
트랜잭션과 사가

등이다.
```

마이크로서비스는 최근 엄청난 탄력을 받고 있는, 아주 평판이 좋은 아키텍처 스타일이다.

### 17.1 역사

마이크로서비스는 사용 초기부터 이름이 붙여졌고 2014년 3월 마틴 파울러와 제임스 루이스가 쓴 'Microservices'라는 유명한 블로그 게시글로 널리 퍼지게 되었다.

마이크로서비스는 소프트웨어 프로젝트의 논리적 설계 프로세스를 강조한 도메인 주도 설계domain-driven design(DDD) 사상의 영향을 많이 받았다. 디커플링 스타일을 나타낸 경계 콘텍스트bounded context 개념은 마이크로서비스에 결정적인 영향을 미쳤다. 경계 콘텍스트 내부에는 코드, 데이터 스키마 같은 내부 요소들이 함께 연결되어 작동되지만, 경계 콘텍스트 외부(데이터 베이스, 클래스 정의에 있는 것들은 전혀 커플링 되지 않는다.

재사용은 유익하지만 커플링이 문제가 된다. 고도의 디커플링이 아키텍트의 목표라면 재사용보다 중복을 우선할 것이다.
마이크로서비스의 주요 목표는 경계 콘텍스트의 논리적 개념을 물리적으로 모델링하는 고도의 디커플링이다.

### 17.2 토폴로지

![image](https://github.com/jongfeel/BookReview/assets/17442457/52a49965-32bb-4aa8-ab16-d1fbeb6626b9)

마이크로서비스는 단일 목적만 가지기 때문에 오케스트레이션 기반의 서비스 지향 아키텍처와 같은 다른 분산 아키텍처보다 서비스 규모가 훨씬 작다.

### 17.3 분산

마이크로서비스는 분산 아키텍처를 형성한다. 서비스는 자체 프로세스로 실행되며 가상 머신과 컨테이너로 빠르게 진화하였다. 서비스를 이 정도로 디커플링하면 애플리케이션을 호스트하는 멀티테넌트 인프라 아키텍처에서 자주 발생하는 문제들을 간단히 해결할 수 있다.

공유하면서 불거지는 문제들은 각 서비스를 자체 프로세스로 분리하면 자연스럽게 해소된다. 클라우드 리소스와 컨테이너 기술을 활용해 도메인 레벨, 운영 레벨 모두 디커플링의 이점을 누릴 수 있게 됐다.

네트워크 호출에 대한 시간과 엔드포인트마다 보안 검증 절차를 거치면 시간이 소요되므로 시스템을 설계하는 아키텍트는 성능과 서비스 세분도에 대해 고려해야 한다. 또 분산 아키텍처이므로 서비스 경계를 넘나드는 트랜잭션을 사용하지 않도록 해야 한다.

이 아키텍처는 서비스를 얼마나 세분화할 것인가를 잘 결정하는 것이 성공의 관건이다.

### 17.4 경계 콘텍스트

마이크로서비스의 근본 철학은 경계 콘텍스트bounded context 개념이다. 서비스마다 도메인이나 워크플로를 모델링 하는 개념으로 커플링을 가급적 배제하고 차라리 중복이 나은 방법이라고 여긴다.

마이크로서비스는 도메인 분할 아키텍처의 개념을 극도로 우려낸 결과물이다. 여러면에서 마이크로서비스는 도메인 주도 설계의 논리적인 개념을 물리적으로 구현한 것이다.

#### 17.4.1 세분도

> '마이크로서비스'라는 용어는 명칭label이지, 명세description가 아니다.
마틴 파울러

서비스 경계service boundary는 도메인이나 워크플로를 캡처하는 것이 목표이다. 
아래 몇 가지 가이드라인이 있다.

**목적**

가장 확실한 경계는 본래 의도인 도메인이다. 각 마이크로서비슨느 기능적으로 매우 응집되어 있고 하나의 핵심 기능을 제공하는 것이 가장 이상적인 모습이다.

**트랜잭션**

여러 엔티티가 함께 개입하여 작동되는 트랜잭션은 아키텍트에게 좋은 서비스 경계 후부이다.

**코레오그래피**

도메인 격리는 되어 있지만, 광범위한 통신을 해야 제대로 작동되는 서비스 세트를 구욱할 경우 통신 오버헤드를 줄이기 위해 큰 서비스로 다시 뭉치는 것을 고려해야 할 수 있다.

좋은 서비스 설계안을 도출하는 유일한 방법은 이터페이션이다. 여러가지 옵션을 반복해서 적용하다 보면 좋은 방향으로 설계를 다듬어 갈 수 있다.

#### 17.4.2 데이터 격리

마이크로서비스는 경계 콘텍스트 개념에 따라 데이터를 격리해야 한다. 통합 지점으로 사용하는 공유 스키마, 데이터베이스 등 모든 종류의 커플링을 없애는 방향으로 한다.

아키텍트는 서비스 세분도를 살필 때 반드시 고려해야 하는 팩터이다. 아키텍처 전체에 데이터 데이터를 분산시킬 수 있을지 결정해야 하고, 도메인을 어떤 팩트에 대한 진실 공급원source of truth으로 식별하여 그 값을 가져올 수 있거나 데이터베이스 복제나 캐시 기술로 정보를 분산시키는 구체적인 방안을 만들어야 한다.

```
체크)
좋은 코드 나쁜 코드에서도 진실의 원천source of truth라는 말이 나왔는데
여기서도 진실 공급원source of truth라는 용어가 나왔다.
문맥에 따라서 해석과 번역의 차이는 있겠지만
source of truth라는 용어는 변하지 않는 데이터라는 걸 표현하는 중요한 단어로 보인다.
```

이렇게 하면 여러 서비스 개발 팀이 단일 데이터베이스의 속박에서 벗어나서 서비스마다 단가, 스토리지 종류, 그 밖의 여러 요소들을 고려해서 적합한 도구를 선택할 수 있게 된다. 또 다른 팀의 영향을 주지 않고 서비스별로 적합한 데이터베이스를 선택할 수 있고 구현 세부 사항에 의존성이 없는 것도 이점이다.

### 17.5 API 레이어

API 레이어는 프록시를 경유하여 간접화하거나 네이밍 서비스naming service 같은 운영 장치에 물려서 유용한 작업을 수행하기 좋은 위치에 있다.

마이크로서비스 아키텍처 기본 철학에 충실하려면 API 레이어를 중재자나 오케스트레이션 도구로 사용하면 안된다. 비즈니스 로직은 경계 콘텍스트 내부에서 일어나야 하므로, 오케스트레이션 등 다른 로직을 중재자에 넣는 것은 규칙 위반이 된다. 이 차이는 기술 분할과 도메인 분할의 차이점을 보여주는 방식이다. 중재자는 기술 분할 아키텍처에서 고려하지만, 마이크로서비스는 도메인에 따라 분할된다는 확실한 경계를 인지해야 한다.

### 17.6 운영 재사용

커플링 보다는 복제를 선호한다면, 모니터링, 로깅, 회로 차단기 등의 운영 관심사는 커플링이 더 유리한 부분은 재사용 하는게 좋을 수 있으나 마이크로서비스 아키텍트는 도메인과 운영 두 가지 관심사를 분리해야 한다.

마이크로서비스 구축 이후 공통적인 요소가 있고 그 유사성을 활용하면 유리한 부분이 있음을 알게 된다.
문제를 해결하는 방법으로 사이드카 패턴sidecar pattern이 있다.

![image](https://github.com/jongfeel/BookReview/assets/17442457/7e2b4004-b16d-4ac4-a300-d2fcf5c35367)

공통 운영 관심사를 각 서비스마다 별도의 컴포넌트로 두고, 해당 팀이나 공유 인프라팀이 소유할 수 있도록 한다.
사이드카 컴포넌트는 팀이 서로 커플링되면 더 유리한 모든 운영 관심사를 도맡아 처리한다.

각 서비스에는 공통 사이드카가 포함돼 있으므로 서비스 메시service mesh를 구축하면 로깅, 모니터링 등의 관심사를 아키텍처 전체적으로 일원화하여 제어할 수 있다. 공통 사이드카 컴포넌트는 모든 마이크로서비스에 대해 일관된 운영 인터페이스를 제공한다.
각 사이드카는 서비스 플레인에 연결되어 자신의 서비스에 일관된 인터페이스를 제공한다.

![image](https://github.com/jongfeel/BookReview/assets/17442457/ba074915-f987-4eea-be40-6f930afa58ce)

서비스 메시 자체는 개발자가 서비스를 전체적으로 액세스할 수 있는 콘솔 역할을 한다. 전체 메시에서 각 서비스는 하나의 노드이고, 서비스 메시는 각 팀이 모니터링, 레벨, 로깅, 그 밖의 공통 운영 관심사 등 운영과 커플링된 부분을 글로벌하게 제어하는 콘솔이다.

![image](https://github.com/jongfeel/BookReview/assets/17442457/ef794aac-cf1e-4ed0-8395-3f396b10e38e)

마이크로서비스 아키텍처에 탄력성을 부여하는 수단으로 서비스 디스커버리service discovery를 사용한다. 요청과 빈도수 모니터링을 통해 서비스 인스턴스를 늘려 확장성/탄력성을 줄 수 있다.

### 17.7 프런트엔드

마이크로서비스 아키텍처의 유저 인터페이스는 두 가지로 나눠볼 수 있다.

유저 요청을 처리하기 위해 단일 유저 인터페이스가 API 레이어를 통해 호출하는 모놀리식 프런트엔드가 하나 있고

![image](https://github.com/jongfeel/BookReview/assets/17442457/63172646-4c20-41a1-95c7-2f5e5f633ddc)

마이크로프런트엔드microfrontend 가 있다.

![image](https://github.com/jongfeel/BookReview/assets/17442457/1d3654e5-01ea-45d7-8e78-0e9c2efc3cc4)

마이크로프런트엔드는 유저 인터페이스 레벨의 컴포넌트를 백엔드 서비스로 활용하여 유저 인터페이스를 동기적인 수준으로 세분화하고 격리한다. 유저 인터페이스에서 백엔드 까지 서비스 경계를 분리해서 전체 도메인을 단일 팀 내부에 통합시킨다.

이 패턴은 리액트react 같은 컴포넌트 기반 웹 프레임워크를 사용하거나 다른 프레임워크를 사용하는 것으로 구현할 수 있다.

### 17.8 통신

올바른 통신 스타일을 발견하는 것 또한 팀이 서비스를 디커플링하면서 유용한 방향으로 조정하는 데 도움이 된다.

일반적으로 마이크로서비스 아키텍처는 '프로토콜 인지 이종 간 상호 운용성protocol-aware heterogeneous interoperability'을 활용한다.

**프로토콜 인지protocol-aware**

운영 커플링 방지를 위해 각 서비스는 서로 서비스를 호출하는 방법을 알고 있어야 한다. 즉, 어떤 프로토콜을 사용할지 알아야(또는 발견해야) 한다.

**이종heterogeneous**

분산 아키텍처이므로 각 서비스별 구현 기술 스택이 다를 수 있다. 이종의 의미는 서비스마다 사용하는 플랫폼이 폴리글랏polyglot 환경을 완벽하게 지원한다는 뜻이다.

**상호 운용성interoperability**

여러 서비스가 네트워크를 통해 서로 호출하면서 정보를 주고 받고 협력해야 한다.

> 강화된 이종성(enforced heterogeneity)
마이크로서비스 세계의 목표는 문제의 범위를 최대한 좁혀 올바른 확장 기술을 선택하는 것이다. 모든 서비스가 일괄로 대용량 데이터베이스를 필요로 하지 않으므로, 서비스별로 고려해야 한다. 고도의 디커플링을 추구하는 것이 마이크로서비스의 근본 사상이다.

#### 17.8.1 코레오그래피와 오케스트레이션

코레오그래피choreography는 브로커 이벤트 기반의 아키텍처와 통신 스타일이 동일하다. 따라서 서비스간 분리된 이벤트를 구현하는게 자연스럽게 진행된다.

도메인/아키텍처 동형성domain/architecture isomorphism은 특정한 문제에 어떤 아키텍처 스타일이 얼마나 적합한지 평가할 때 잘 살펴봐야 할 핵심 특징이다. 이 용어는 아키텍처의 형상shape이 특정 아키텍처 스타일에 어떻게 매핑되는지 기술한다.

마이크로서비스는 디커플링을 추구하므로 마이크로서비스의 형상은 브로커 이벤트 기반 아키텍처를 닮았고 이 두 패턴은 서로 공생symbiotic 관계이다.

코레오그래피에서는 중재자 없이 자신의 필요에 따라 서비스를 호출한다.

![image](https://github.com/jongfeel/BookReview/assets/17442457/0e40ee0f-e8c5-4cc7-b2d6-31a9db145d74)

그림에서 위시리스트를 가져오는데 필요한 정보가 CustomerWIshList 서비스에 있지 않으므로 CustomerDemographics 서비스를 호출해 정보를 더 보충하여 결과를 얻어낸다.

또 중재자가 따로 없으므로 여러 서비스를 조정해야 하는 경우는 아래 그림 처럼 스스로 로컬 중재자를 만들 수도 있다.

![image](https://github.com/jongfeel/BookReview/assets/17442457/f8c0f5b8-69f2-4beb-9fa9-105d79ab44fa)

고객의 전체 정보를 조회하고 호출을 조정하는 서비스를 하나 더 둔다. 유저는 중재자를 호출하고 중재자는 필요한 다른 서비스를 호출하는 식이다.

코레오그래피는 디커플링의 아키텍처 스타일 철학을 따라 이점을 가져오는 방식이지만,
에러 처리, 조정 같은 공통의 문제는 코레오그래피에서 더 복잡해진다.

아래 그림에서 OrderPlacement 서비스는 자신의 도메인 책임과 다른 서비스를 전체적으로 조정하는 중재자 역할도 한다.
이런 패턴을 프런트 컨트롤러 패턴front controller pattern이라고 한다.
중재자 역할을 하는 서비스가 있으면 복잡도가 증가하는 단점이 있다.

![image](https://github.com/jongfeel/BookReview/assets/17442457/77ec6d68-d197-4457-a2dc-58a1d390fefe)

복잡한 비즈니스 프로세스는 아래 그림처럼 오케스트레이션을 사용하는 방법도 있다.

![image](https://github.com/jongfeel/BookReview/assets/17442457/e62880e2-bd91-4577-a4ce-1ed11a0d08dc)

중재자를 두면 서비스간 커플링은 발생하지만 어느 한 서비스가 조정 작업만 전담하므로 다른 서비스에 영향을 주지는 않는다. 사실 도메인/워크플로는 내재적으로 커플링 되는 경우가 많다. 여기서 해야 할 일은 두 마리 토끼를 모두 쫓는 방향으로 커플링을 가장 잘 나타낼 수 있는 방법을 찾아내는 것이다.

#### 17.8.2 트랜잭션과 사가

데이터베이스도 동일한 수준의 디커플링이 요구되므로 원자성atomicity 문제도 고려해야 한다.

서비스 경계를 넘나드는 트랜잭션은 마이크로서비스 아키텍처의 핵심 디커플링 원칙에 위배된다. 트랜잭션으로 서비스를 엮어야 할 필요가 생긴 것이라면 설계를 지나치게 세분화한 것이다. 따라서 트랜잭션 경계는 서비스 세분도를 가늠할 수 있는 일반적인 지표 중 하나이다.

> TIP Don’t do transactions in microservices - fix granularity(세분도) instead!

예외로 서비스 경계가 명확히 구분되어 있지만 한 트랜잭션으로 묶어야 할 때가 생기면, 트레이드오프를 감수하고 트랜잭션 오케스트레이션을 처리하는 패턴도 있다.

마이크로서비스에서 많이 사용하는 분산 트랜잭션 패턴으로 사가 패턴saga pattern이 있다.

![image](https://github.com/jongfeel/BookReview/assets/17442457/4a342cef-1b69-459c-876d-eb077e37f540)

서비스는 여러 서비스의 중재자 역할도 하고 트랜잭션도 조정한다. 각 서비스별 트랜잭션에 대해 성공/실패 결과에 따라 그 흐름을 조정한다. 정상적인 트랜잭션이 일어났다면 서비스의 값과 데이터베이스는 동기화가 될 것이다.

만약 서비스 트랜잭션 하나가 실패하면 중재자는 전체 트랜잭션 파트가 모두 성공하지 못하게 해야 한다.

![image](https://github.com/jongfeel/BookReview/assets/17442457/16d32b71-6cd7-4c32-b271-05a58b80333b)

위 그림처럼 2, 3번 까지 성공하고 4번 트랜잭션에서 실패하면 5번 실패 응답을 받고 6번 실패 메시지를 통해 다른 서비스에 undo 요청을 보내야 한다. 이런 종류의 트랜잭션 조정을 보상 트랜잭션 프레임워크compensating transaction framework라고 한다. 이 패턴은 중재자가 모든 트랜잭션이 성공했다고 알리기 전까지 중재자에게 받았던 트랜잭션 요청을 보류 상태로 둔다. 하지만 여기서 비동기 요청 처리와 보류 상태에서 새로운 요청이 들어오면 설계가 복잡해진다. 또 네트워크 레벨에서도 트래픽이 많이 발생한다.

트랜잭션 마다 do/undo 로직을 개발하는 식으로 할 수 있지만, 중재자의 조정은 덜 해도 undo는 do 보다 엄청나게 복잡해져서 설계, 구현, 디버깅 작업량 역시 2배 이상 증가하게 된다.

여러 서비스에 트랜잭션을 걸어주는 것이 불가능하지 않지만 그렇다면 마이크로서비스 패턴을 선택할 이유가 없다.

> TIP A few transactions across services is sometimes necessary; if it’s the dominant feature of the architecture, mistakes were made!

### 17.9 아키텍처 특성 등급

![image](https://github.com/jongfeel/BookReview/assets/17442457/a2d47ac5-1741-416d-a721-509e5012ba3f)

특징
자동화 배포, 시험성을 포함한 현대 엔지니어링 프랙티스를 훌륭하게 지원하는 아키텍처이다.

서비스간 통신을 과용하면 내고장성, 신뢰성 위협을 받는다. 일반적인 경향을 나타내는 것일 뿐, 서비스 디스커버리를 통한 확장 및 리던던시redundancy(중복성)를 이용해 문제를 해결할 수 있다.

확장성, 탄력성, 진화성이 뛰어나다.
확장성이 우수한 시스템은 이 아키텍처 스타일을 활용한 것이다.
자동화 및 운영과의 통합에 많이 의존하므로 탄력성을 줄 수 있다.
고도의 디커플링을 선호하므로 점진적으로 변화하는 비즈니스 프랙티스를 훌륭하게 지원한다.

잦은 네트워크 호출로 인해 성능 오버헤드가 높고 엔드 포인트마다 보안 체크를 해야 한다.
이를 개선하기 위해 데이터 캐시, 데이터 복제 기술을 사용한다.
커플링이 적을수록 통신 속도가 증가하고 병목이 줄기 때문에 오케스트레이션 보다는 코레오그래피를 더 많이 사용한다.

도메인 중심 아키텍처이므로 각 서비스의 경계와 도메인이 일치해야 한다.
잘 만들면 많은 이점을 누릴 수 있지만, 규칙을 지능적으로 깨뜨릴 수 있으려면 반드시 규칙에 대해 잘 이해하고 있어야 한다.

### 17.10 더 읽을거리

아래 세 책을 추천

- 샘 뉴먼의 < 마이크로서비스 아키텍처 구축 >
  - http://aladin.kr/p/Oo8U3 

![image](https://github.com/jongfeel/BookReview/assets/17442457/2a7b8870-eaff-404f-a68d-0f3c12f10ec4)

- 마크 리처즈의 < Microservices vs. Service-Oriented Architecture >
  - https://www.oreilly.com/library/view/microservices-vs-service-oriented/9781491975657/
- 마크 리처즈의 < Microservices AntiPatterns and Pitfalls >
  - https://www.oreilly.com/library/view/microservices-antipatterns-and/9781492042716/

```
마크 리처즈는 < 소프트웨어 아키텍처 101 >의 공동 저자이기도 하다
또 O'reilly의 두 책은 번역서는 커녕 외서 목록에도 없는 O'reilly 내에서만 검색해서 볼 수 있는 책이다.
```

