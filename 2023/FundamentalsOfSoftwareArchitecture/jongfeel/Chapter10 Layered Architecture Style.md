## CHAPTER 10 레이어드 아키텍처 스타일

```
논의내용)
책의 전반부에 많이 언급했는데, 여기서 다시 정리한 느낌으로 레이어드 아키텍처에 대해 더 잘 알게 된 것 같습니다.
저도 아직 트래픽이 엄청 많은 대용량 서비스를 경험하지는 않아서 B2B나 일반적인 경우에는 레이어드 아키텍처 스타일로도 해결이 안된 적은 없었기 때문에 이 스타일의 특징인 단순성에서는 저도 맞다고 생각합니다. 제가 생각한 견해 외에 레이어드 아키텍처 스타일이 그래도 장점인 부분이 있다고 생각하는 다른 부분이 있는지 얘기해 보면 좋겠습니다.
```

시스템을 설계하는 조직은 그 조직의 소통 구조를 그대로 복제한 듯 설계할 수밖에 없다는 콘웨의의 법칙대로 레이어드 아키텍처는 애플리케이션을 개발하는 아주 자연스러운 방법이다. 그러나 레이어드 아키텍처 스타일은 묵시적 아키텍처architecture by implication 안티패턴, 우발적 아키텍처accidental architecture 안티패턴 등의 몇몇 아키텍처 안티패턴의 범주에 속한다.

아키텍트가 어떤 아키텍처 스타일을 사용하는 게 좋을지 확신이 없거나 애자일 개발팀이 '일단 코딩을 시작'해보기로 했다면 좋은 선택지가 될 가능성이 높다.

### 10.1 토폴로지

<img width="479" alt="image" src="https://user-images.githubusercontent.com/17442457/235458288-592df5e0-212e-417a-aa91-bf24b32909e0.png">

내부 컴포넌트는 논리적으로 수평한 레이어들로 구성되며, 각 레이어는 애플리케이션에서 주어진 역할을 수행한다. 레이어의 개수와 유형은 특별한 제한이 없지만 일반적으로 4계층 표준 레이어로 구성한다. 퍼시스턴스 로직이 비지니스 레이어 컴포넌트에 내장된 경우에는 레이어가 병합되기도 한다. 규모가 작은 애플리케이션은 3개, 크고 복잡한 비즈니스 애플리케이션은 5개 또는 그 이상의 레이어로 구성된다.

<img width="471" alt="image" src="https://user-images.githubusercontent.com/17442457/235458629-365749b3-24a7-49b5-94a5-b22501c5360c.png">

물리적 계층화(배포) 관점에서의 다양한 토폴로지 변형이다. 많은 온프레미스on-premises 제품들이 이런 방식으로 개발되어 고객에게 인도된다.

각 레이어는 내부에서 특정한 역할과 임무를 수행한다. 프레젠테이션 레이어는 모든 유저 인터페이스와 브라우저 통신 로직을, 비즈니스 레이어는 요청을 받아 알맞은 비즈니스 규칙을 실행하는 일을 한다.

이런 관심사의 분리separation of concerns 개념으로 레이어드 아키텍처 스타일은 아키텍처 내부의 역할 및 책임 모델을 효과적으로 구성할 수 있다. 개발자 본인의 기술 역량을 도메인의 기술적인 부분에 집중시킬 수 있지만, 그런 장점을 대가로 전체적인 민첩성(변화에 신속하게 반응하는 능력)이 떨어지는 트레이드오프가 있다.

레이어드 아키텍처는 기술 분할된 아키텍처이다. 컴포넌트를 도메인 단위로 묶는 것이 아닌 아키텍처의 기술 역할에 따라 묶기 때문에 비즈니스 도메인이 각각 모든 아키텍처 레이어에 분산 된다.

### 10.2 레이어 격리

각 레이어는 폐쇄closed 또는 개방open 상태이다. 폐쇄 레이어closed layer는 상위 레이어에서 하위 레이어로 요청이 이동하므로 중간의 어떤 레이어도 건너뛸 수 없고 현재 레이어를 거쳐야 그 다음 레이어로 갈 수 있다.

<img width="506" alt="image" src="https://user-images.githubusercontent.com/17442457/235459578-8aec2a6c-cfe0-4249-82ae-1f08b0140921.png">

만약 요청이 다른 레이어를 건너 뛴다면 중간 레이어는 개방이 되어 있어야 한다. 즉, 프레젠테이션 레이어에서 바로 데이터베이스 레이어로 직접 액세스하는 경우일 때, 이 개념을 이해하려면 레이어 격리layers of isolation를 알아야 한다.

레이어 격리는 어느 아키텍처 레이어에서 변경이 일어나도 다른 레이어에 있는 컴포넌트에 아무런 영향을 끼치지 않기에 레이어 간 계약은 불변임을 의미한다.

레이어를 격리하면 아키텍처의 모든 레이어를  다른 레이어에 영향을 주지 않고 교체할 수 있다. 단 잘 정의된 계약과 비즈니스 위임 패턴business deleagte pattern을 사용한다는 가정이 있어야 한다.

### 10.3 레이어 추가

어떤 레이어의 경우는 개방하는 것이 더 합리적인 경우가 있다. 비즈니스 레이어에 공통 비즈니스 기능이 구현된 객체를 구현하여 공유하고, 프레젠테이션 레이어에서는 이 공유 객체를 직접 사용할 수 없도록 아키텍처 결정을 했다면 프레젠테이션 레이어가 비즈니스 레이어를 액세스 할 수 있고 그 내부의 공유 객체 역시 갖다 쓸 수 있는 통제하기 어려운 아키텍처 구조가 된다.

<img width="481" alt="image" src="https://user-images.githubusercontent.com/17442457/235460616-9b8950a1-b534-4a36-81d0-01527f89892f.png">

이런 제약조건을 아키텍처적으로 강제하려면 공유 비즈니스 객체가 모두 포함된 새로운 서비스 레이어를 아키텍처에 추가한다. 비즈니스 레이어는 폐쇠되어 있으므로 프레젠테이션 레이어가 공유 비즈니스 객체를 직접 액세스할 수 없다. 새로 추가된 서비스 레이어는 개방 레이어로 설계한다면 비즈니스 레이어가 퍼시스텐스 레이어를 액세스 할 때 뚫고 갈 수 있게 된다.

<img width="484" alt="image" src="https://user-images.githubusercontent.com/17442457/235461117-f0394ea8-8ebe-4f4c-a751-8d0837cad63c.png">

개방/폐쇄 레이어 개념을 잘 활용하면 아키텍처 레이어 간 관계와 요청 흐름을 정의할 때 유용하다. 하지만 아키텍처의 레이어가 개발/폐쇄 되어 있는지 문서화하고 소통하지 않으면 커플링이 심한 아키텍처가 될 수 있다. 

### 10.4 기타 고려 사항

재사용은 최소한으로, 객체 계층은 최대한 가볍게 맞춰 적절한 모듈성을 유지하는 것이 중요하다. 그래야 이후 다른 아키텍처 스타일로 변경해도 큰 어려움이 없게 된다.

아키텍처 싱크홀architecutre sinkhole 안티패턴을 조심해야 하는데, 요청이 한 레이어에서 다른 레이어로 이동할 떄 각 레이어가 아무런 처리 없이 그냥 통과하는 안티패턴이다. 사실 단순 조회 요청의 경우 비즈니스 레이어는 거의 할 일이 없기 때문에 불필요한 객체 초기화와 처리가 일어나고 쓸데없는 메모리를 소모하기도해서 성능에 부정적인 영향을 끼친다.

이 안티패턴이 하나도 없기는 어려우므로 전체 요청에서 비율을 따져보는 것이 중요하다. 8:2 법칙을 적용해서 전체 요청의 20% 정도가 싱크홀이면 괜찮을수 있지만 80% 이상이 싱크홀이라면 이 도메인에 레이어드 아키텍처는 적합한 아키텍처 스타일이 아니라는 증거가 된다. 혹은 아키텍처의 모든 레이어를 개발하는 방법도 있지만 변경관리의 어려움이 가중되는 트레이드오프가 있다는 걸 분명하게 인식해야 한다. 

### 10.5 왜 이 아키텍처 스타일을 사용하는가

작고 단순한 애플리케이션이나 웹사이트에 알맞은 아키텍처 스타일이다.
예산과 일정이 빠듯한 경우 출발점으로 괜찮은 선택이다.
개발자, 아키텍트 모두 익숙하고 복잡하지 않으며 비용도 가장 저렴한 아키텍처 스타일이라 간편하게 개발할 수 있다.
아키텍트가 아직 요구사항 분석 단계이고 어떤 아키텍처 스타일이 최선인지 불확실한 경우에도 나쁘지 않은 선택이다.

다만 애플리케이션 규모가 커질수록 유지 보수성, 민첩성, 시험성, 배포성 같은 아키텍처 특성이 점점 나빠진다.
따라서 대규모 애플리케이션은 다른 아키텍처 스타일을 고려하는게 좋다.

### 10.6 아키텍처 특성 등급

<img width="483" alt="image" src="https://user-images.githubusercontent.com/17442457/235462482-73463fe7-8e57-4a51-93f5-32f0c260e8ad.png">

시험성에 별점이 2개인 이유는 컴포넌트(또는 전체 레이어)를 모킹mocking 또는 스터빙stubbing할 수 있어 전체 테스트 공수는 덜 들기 때문이다.

분산 아키텍처에서의 네트워크 트래픽, 대역폭, 레이턴시 문제는 덜 하므로 신뢰성은 보통(별점 3점)이지만, 모놀리식 배포 속성상 시험성과 배포 리스크 측면에서 점수가 낮다.

이 아키텍처는 모놀리식 배포와 아키텍처 측면에서 모듈성이 부족하므로 탄력성과 확장성은 점수가 낮다.

성능은 병렬 처리가 거의 안 되고, 폐쇄적인 레이어 구조와 싱크홀 아키텍처 안티패턴 때문에 고성능 시스템에 어울리지 않는다. 캐시, 멀티스레딩 등의 기술로 해결은 가능하지만, 이 아키텍처 스타일 본연의 자연스러운 특성은 아니다. 이걸 실현하려면 아키텍트와 개발자가 아주 부지런해야 한다.

어느 파트에서 메모리 부족이 발생하면 애플리케이션 전체가 영향을 받고 충돌이 발생한다. 따라서 MTTRMean-Time-To-Recovery(평균 수리 시간) 때문에 2분 ~ 15분 이상 시동 시간이 소요되며 그 만큼 전체 가용성도 영향을 받는다.