## CHAPTER 13 서비스 기반 아키텍처 스타일

```
인상깊은 내용)
사실 분산 아키텍처 특성 중에는 마이크로서비스 아키텍처가 제일 좋고
그 아키텍처로 도달하기 위한 첫 빌드업(?)이라고 생각했는데
작은 서비스에 꼭 마이크로서비스 아키텍처를 고수해야 하는 것이 아니라면
서비스 기반 아키텍처도 나름 쓸만한 아키텍처라는 생각이 들었습니다.
별점 1점도 없고 5점도 없는 중간 이상의 밸런스가 있는 인상깊은 아키텍처였습니다.
```

서비스 기반 아키텍처service-based architecture는 마이크로서비스 아키텍처 스타일의 일종으로 가장 실용적인 스타일 중 하나이다. 분산 아키텍처 특성을 가지면서도 덜 복잡하고 비용이 많이 들지 않는다.

### 13.1 토폴로지

따로 배포된 유저 인터페이스와 원격 서비스, 그리고 모놀리스 데이터베이스로 이루어진 대규모 분산 레이어 구조이다.

<img width="468" alt="image" src="https://github.com/jongfeel/BookReview/assets/17442457/69941cfe-543d-4e4b-8abc-6b18db759fbc">

서비스는 큰 단위로 분리해 별도로 배포하는 '애플리케이션의 일부(도메인 서비스)'이다. 배포 방식은 모놀리스와 동일하므로 컨테이너와가 필수는 아니다. 여러 서비스가 데이터베이스를 공유하므로 서비스 개수는 4~12개 사이, 평균 7개이다.

각 서비스는 단일 인스턴스로 배포하지만 확장성, 내고장성, 처리량 요구사항에 따라 인스턴스를 여럿 둘 수도 있다. 이렇게 하면 유저 인터페이스로 유입된 요청이 가용한 서비스 인스턴스로 갈 수 있도록 부하 분산 기능이 필요하다.

프로토콜은 일반적으로 REST를 많이 쓰지만, 메시징, 원격 프로시저 호출remote procedure call(RPC), SOAP도 사용 가능하다. 유저 인터페이스는 프록시나 게이트웨이로 구성된 API 레이어를 통해 서비스에 접속할 수 있지만, 대개 서비스 로케이터 패턴service locator pattern에 따라 유저 인터페이스, API 게이트웨이, 프록시에 내장된 유저 인터페이스를 직접 액세스 한다.

중앙 공유 데이터베이스 사용이 특징이므로, 데이터베이스 자체 변경은 이슈가 될 수 있다.

### 13.2 토폴로지 변형

유저 인터페이스는 다시 여러 유저 인터페이스 도메인으로 나눌 수 있고, 각 도메인 서비스에 맞게 나눌 수도 있다.

<img width="473" alt="image" src="https://github.com/jongfeel/BookReview/assets/17442457/6629ab11-ce81-4bd6-80d0-7bec17078ac4">

데이터베이스 역시 개별 데이터베이스로 분리할 수 있고, 각 도메인 서비스 전용 데이터베이스들로 쪼갤 수도 있다. 이렇게 하려면 각 데이터베이스에 있는 도메인 데이터를 다른 도메인의 서비스가 필요로 하지 않도록 설계해야 한다. 이렇게 할 때 도메인 서비스간 상호 통신을 방지하고 데이터베이스 간의 중복 데이터를 방지할 수 있다.

<img width="471" alt="image" src="https://github.com/jongfeel/BookReview/assets/17442457/51b37994-776f-4870-9e7f-e043732501fe">

리버스 프록시reverse proxy 또는 게이트웨이로 구성된 API 레이어를 유저 인터페이스와 서비스 사이에 구성할 수도 있다. 도메인 서비스의 기능을 외부 시스템에 표출하거나 공통 관심사를 통합해서 유저 인터페이스 밖으로 떼어낼 경우에 유용한 방법이다.

<img width="478" alt="image" src="https://github.com/jongfeel/BookReview/assets/17442457/0f0177ef-6380-489b-b2de-fbeeb9d030d5">

### 13.3 서비스 설계 및 세분도

도메인 서비스의 단위가 크기 때문에 API 퍼사드 레이어, 비즈니스 레이어, 퍼시스턴스 레이어로 구성된 레이어드 아키텍처 스타일로 설계하는 것이 일반적이다. 모듈러 모놀리스 아키텍처 스타일처럼 서브 도메인을 이용해서 각 도메인 서비스를 분할하는 방법도 많이 쓰인다.

<img width="474" alt="image" src="https://github.com/jongfeel/BookReview/assets/17442457/ef0fb77a-a5c5-4fe4-9246-02b9cfac6270">

도메인 서비스는 유저 인터페이스에서 비즈니스 기능을 호출하기 위해 접속할 일종의 API 액세스 퍼사드access facade를 필요로 한다. API 액세스 퍼사드는 유저 인터페이스를 통해 유입된 비즈니스 요청을 오케스트레이트orchstrate 하는 역할을 한다. 내부 클래스 수준의 오케스트레이션과 외부 서비스의 오케스트레이션이라는 차이점이 서비스 기반 아키텍처와 마이크로서비스의 중요한 차이점이다.

단일 도메인 서비스는 데이터 무결성을 위해 commit/rollback의 ACID(원자성, 일관성, 격리성, 지속성) 데이터베이스 트랜잭션을 사용한다. 마이크로서비스처럼 분산도가 높은 아키텍처는 BASE 분산 트랜잭션(기본적 가용성base availability, 소프트 상태soft state, 최종 일관성eventual consistency) 기법을 사용한다. 최종 일관성에 기반을 두므로 ACID 트랜잭션 레벨의 데이터 무결성은 지원하지 않는다. 따라서 서비스가 잘게 나누어진 아키텍처에서는 비즈니스 프로세스를 오케스트레이트 하려면 신경써야 할 문제들이 많다.

도메인 서비스는 단위가 커서 데이터 무결성과 일관성 측면에서는 유리하지만 트레이드오프가 있다. 마이크로서비스 아키텍처는 작은 서비스 하나만 변경 영향도가 있고 한 가지 역할만 수행하므로 다른 기능이 망가질 일은 없다. 반면에 서비스 기반 아키텍처는 변경에 대해 전체 영향을 받게 되고 이후에 코드가 점점 더 많이 배포될 수록 문제가 생길 가능성이 더 커진다.

### 13.4 데이터베이스 분할

단일 모놀리식 데이터베이스를 공유하는 방식이므로 커플링이 발생하고, 테이블 스키마를 올바르게 변경하지 않을 경우 모든 서비스에 영향을 미치므로 데이터베이스 변경은 노력과 조정이 필요한 값비싼 작업이다.

데이터베이스 테이블 스키마를 나타낸 공유 클래스 파일shared class file(엔티티 객체entity object)은 전체 도메인 서비스가 함께 사용하는 커스텀 공유 라이브러리에 둔다. SQL 코드도 이 라이브러리에 있으므로 엔티티 객체가 공유하는 단일 라이브러리를 생성하는 프랙티스는 가장 비효율적인 구현 방법이다.

<img width="472" alt="image" src="https://github.com/jongfeel/BookReview/assets/17442457/c8521e2b-536d-4828-88b7-d0e62678f488">

데이터베이스 변경 영향도와 리스크를 낮추는 방법은, 데이터베이스를 논리적으로 분할하고 연합 공유 라이브러리federated shared library를 통해 명시한다. 이렇게 구성하면 특정 논리 도메인에 속한 테이블을 변경해도 해당 엔티티 객체가 포함된 해당 공유 라이브러리를 사용하는 서비스만 영향을 받는다.

<img width="480" alt="image" src="https://github.com/jongfeel/BookReview/assets/17442457/7a0782a2-17bc-41a4-8170-1e9bbb9a9760">

모든 서비스는 공통 도메인과 도메인에 해당하는 공유 라이브러리 common_entities_lib를 함께 사용한다. 모든 서비스의 공통 테이블을 변경하려면 공유 데이터베이스를 액세스 하는 전체 서비스를 미리 조율해야 한다. 테이블 변경 영향도를 낮추려면 공통 엔티티 객체를 버전 관리 시스템에서 lock을 하고 수정 권한을 오직 데이터베이스 팀에게만 부여하는 것이다.

> TIP, 서비스 기반 아키텍처에서는 데이터베이스 변경을 통제하기 위해 데이터 도메인을 올바르게 정의/관리하고 데이터베이스는 가급적 논리적으로 잘게 나누는 것이 좋다.

### 13.5 아키텍처 예시

전자제품 재활용 시스템의 예.
각 서비스별 프로세스

- 견적quoting: 중고 제품에 대해 얼마까지 보상받을 수 있는지 확인
- 수취receiving: 회사에 제품을 보내고 회사는 실물을 받음
- 감정assessment: 제품의 작동 상태를 평가
- 회계accounting: 약속한 보상가 지불
- 제품 상태item status: 고객은 언제라도 웹사이트에서 진행 상황 확인
- 재활용recycling: 제품은 해체 후 재활용되거나 재판매됨
- 리포팅reporting: 성과에 따른 임시/정기 재무 리포트 체크

높은 처리량이 필요한 견적, 제품 상태 서비스만 확장하면 되므로 확장성을 충족시킬 수 있고, 나머지 서비스는 단일 서비스 인스턴스로도 충분하다.

<img width="482" alt="image" src="https://github.com/jongfeel/BookReview/assets/17442457/0c4a767d-4447-4b19-8f72-bdf3af289423">

유저 인터페이스와 애플리케이션이 각 도메인과 잘 연합되어 있으므로 유저 인터페이스의 내고장성, 확장성, 보안이 실현된다. 데이터베이스는 외부 고객 처리용과 내부로 물리적인 분할을 하고 별도의 네트워크 영역에 두는 것이 데이터 보안상 바람직하다. 데이터베이스에 따라서 내부 테이블을 미러링하고 테이블을 동기화하는 방법도 있다.

감정 서비스의 경우는 제품 별로 규칙이 계속 추가/변경 되므로 단일 도메인 서비스로 격리하면 민첩성, 시험성, 배포성을 높일 수 있다. 

### 13.6 아키텍처 특성 등급

<img width="474" alt="image" src="https://github.com/jongfeel/BookReview/assets/17442457/0e314462-59fd-4f89-bb97-ffde7c715d98">

도메인 분할 아키텍처가 특징이므로, 도메인 별로 변경이 일어나도 해당 서비스와 유저 인터페이스만 영향을 받는다.

서비스가 4 ~ 12개라도 동일한 데이터베이스나 유저 인터페이스를 공유할 경우 전체 시스템의 퀀텀은 1이 된다. 하지만 유저 인터페이스와 데이터베이스는 연합될 수 있으므로 시스템 내부에 여러 퀀텀이 생긴다. 고객 대면 애플리케이션에서 1,  내부 작업에 1 해서 총 시스템의 퀀텀이 2가 될 수 있다. 또 내부 작업 안에서는 별도 서비스와 두 개별 유저 인터페이스가 있지만 동일한 데이터베이스를 공유하므로 애플리케이션 부분에서 퀀텀은 1이다.

<img width="468" alt="image" src="https://github.com/jongfeel/BookReview/assets/17442457/e85bef10-9284-44e9-b448-779fca74c1fe">

서비스 기반 아키텍처에서는 별점 5는 없지만 별점이 높은 중요한 영역들이 많다.

- 민첩성: 여러 도메인 서비스로 나뉘어 있으므로 신속한 변경이 가능
- 시험성: 각 도메인 범위가 한정되어 있으므로 테스트 커버리지test coverage가 향상된다
- 배포성: 서비스가 나뉘어 있으므로 전체적으로 모놀리스 보다는 덜 위험하게 더 자주 배포가 가능하다.

서비스 기반 아키텍처의 서비스는 자기 완비형이고 데이터베이스와 코드를 공유하므로 서비스간 통신이 없어 내고장성 별점이 4점이다.

확장성은 서비스를 나누는 단위는 크므로 3점이고, 그에 따른 탄력성은 별점 2이다.

### 13.7 언제 이 아키텍처 스타일을 사용하는가

아키텍처 스타일의 유연성 덕분에 가장 실용적인 아키텍처일 수 있다.

서비스 기반 아키텍처는 도메인 주도 설계와 궁합이 잘 맞는다.

분산 아키텍처에서는 전통적인 ACID 트랜잭션이 아닌 최종 일관성에 의존하는 방식으로 트랜잭션을 관리/조율한다.
서비스 기반 아키텍처의 도메인 서비스는 분산 아키텍처에 비해 ACID 트랜잭션이 더 잘 보존된다. 둘 이상의 도메인 서비스를 오케스트레이션 하는 경우에는 트랜잭션이 사가와 BASE 트랜잭션에 의존해야 한다. 대부분 트랜잭션은 도메인 서비스에 한정되므로 모놀리식 애플리케이션에서 찾아볼 수 있는 전통적인 커밋/롤백 트랜잭션 기능은 그대로 가능하다.

서비스 기반 아키텍처는 아키텍처 모듈성을 괜찮은 수준으로 달성할 수 있다.
오케스트레이션은 트랜잭션의 워크플로를 제어/관리하는 중재자 서비스를 따로 두고 여러 서비스를 조율하는 기법인 반면
코레오그래피는 각 서비스가 중앙의 중재자 없이 서로가 알아서 소통하는 방식이다.
서비스가 잘게 쪼개지면 비즈니스 트랜잭션을 완성하기 위해 서비스를 서로 단단히 묶어주는 오케스트레이션과 코레오그래피가 필요하다.