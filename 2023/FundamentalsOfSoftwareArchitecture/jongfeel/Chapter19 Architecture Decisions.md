## CHAPTER 19 아키텍처 결정

```
논의 내용)을 뽑을 수 없었습니다 ㅜㅜ
그래서 인상깊은 내용으로 대체했어요.

안티패턴의 제목들이 딱딱하지 않고 재밌게 만들었다는 점에서 좋았고
우리나라에서는 일어날 것 같지 않은 이메일 기반 아키텍처는
큰 조직에서 원격으로 일하는 회사에서는 정말 일어날법한 일이라고 보여진다.
특히 메일 수신자를 귀찮게 하지 말아야 하고
자세한 내용은 링크를 통한 문서로 정리하라고 한 점을 봤을 때는
허락보다 용서가 쉽다 급의 추진력을 만들어야 일이 진행되지 않겠냐? 로 느껴졌다.
```

아키텍처 결정을 하려면 충분한 정보를 수집하고 결정을 정당화, 문서화한 다음 이해관계자들과 효과적으로 소통해야 한다.

### 19.1 아키텍처 결정 안티패턴

프로그래머 앤드류 케이니그Adnrew Koenig는 안티패턴을 처음에는 좋은 생각처럼 보이지만 이내 곧 곤경에 빠뜨리는 애물단지라고 정의한다. 세 가지 안티패턴 '네 패를 먼저 보여주지마Covering Your Assets', '무한반복 회의Groundhot Day', 이메일 기반 아키텍처email-driven architecture' 들은 보통 누적되어 발전한다.

정확하고 효과적인 아키텍처 결정을 하려면 아키텍트는 이 세 안티패턴 모두 극복해야 한다.

#### 19.1.1 '네 패를 먼저 보여주지마' 안티패턴

아키텍트가 잘못된 선택을 하는 것을 두려워한 나머지 아키텍처 결정을 회피하거나 미루는 현상을 말한다.

이 안티패턴은 두 가지 방법으로 극복 가능하다.

첫째,
어떤 중요한 아키텍처 결정을 내리기 전, 마지막으로 책임질 수 있는 순간last responsible moment까지 기다리는 것이다.
개발팀을 붙잡아 두거나 분석 마비analysis paralysis 안티패턴에 빠질 정도로 오래 기다리지는 않음을 의미한다.

둘때,
개발팀과 지속적으로 협력하면서 아키텍트가 결정한 내용을 원래 의도한 대로 추진한다.
세부적인 기술은 아키텍트가 다 알 수 없으므로 개발팀의 협력이 필요하다.
이렇게 해야 나중에 문제가 생겨도 아키텍트가 아키텍처 결정을 변경하면서 재빠르게 대응이 가능하다.

#### 19.1.2 '무한반복 회의' 안티패턴

사람들이 어떤 결정을 왜 했는지 모르고 주구장창 회의만 계속한다.
이 명칭은 빌 머리Bill Murray가 출연한 '사랑의 블랙홀Groundhog Day'이라는 영화에서 유래한 것으로, 실제 원제인 '성촉절' 2월 2일이 영화에서 끊임없이 반복된다.

이 패턴이 발생하는 이유는 아키텍트가 자신이 내린 결정을 정당화하는데 실패했기 때문이다. 아키텍처 결정을 정당화하려면 그 결정을 내리게 된 기술적, 비즈니스적 근거를 제시하는 것이 좋다. 그렇게 해야 아키텍처 결정을 다른 무엇보다 우선해야 하는지 한 번 더 돌아볼 수 있다. 만약 그럴 가치가 없다면 좋은 아키텍처 결정이 아니므로 다시 생각해 보는 것이 좋다.

일반적인 비즈니스적 근거로 비용, 출시 시기, 유저 만족도, 전략적 포지셔닝 등이 있다. 무엇이 비즈니스 이해관계자에게 중요한지 생각해 봐야 한다.

#### 19.1.3 '이메일 기반 아키텍처' 안티패턴

아키텍처 결정을 놓치거나 잊어버리고 그런 결정을 했다는 사실을 알지 못해서 아키텍처 결정을 구현하지 못하는 상태를 뜻한다. 즉, 아키텍처 결정을 효과적으로 전달하는 문제와 관련된 안티패턴이다. 

아키텍처 결정을 효과적으로 전달하려면

첫째,
이메일 본문에 아키텍처 결정을 포함시키지 않는다. 아키텍처 결정이 변경되거나 다른 결정으로 대체될 경우 이메일에는 결정의 본질과 맥락 정도만 언급하고 세부 정보는 다른 기록 시스템을 통해 링크를 제공한다.

둘째,
아키텍처 결정에 정말 관심있는 사람들에게만 통지한다. 역시 결정의 맥락만 언급하고 결정 자체를 언급하지 않는다. 아키텍트가 내린 아키텍처 결정이 수신자에게 직접적인 영향이 없다면 굳이 귀찮게 할 필요가 없다. 아키텍처 결정에 관한 세부 내용은 다른 페이지의 링크로 제공하면 모든 정보를 일원화하여 관리할 수 있는 체계가 완성된다.

### 19.2 아키텍처적으로 중요한

아키텍트가 어떤 기술을 사용하기로 결정했고 그 기술을 어떤 아키텍처 특성을 직접 지원하기 위해 선택한 것이라면 아키텍처 결정을 했다고 보는 것이 맞다.

< Release It 릴리스 잇 > 의 저자인 마이클 나이가드Michael Nygard는 아키텍트가 어떤 아키텍처 결정을 하는지 '아키텍처적으로 중요한arthitecturally significat'이라는 용어를 만들어서 설명하려고 했다.

아키텍처적으로 중요한 결정이란, 구조, 비기능 특성, 의존성, 인터페이스, 구현 기술에 영향을 미치는 결정이 있다.

- 구조structure는 사용 중인 아키텍처의 패턴이나 스타일에 영향을 미치는 결정들이다.
- 비기능 특성nofunctional characteristic은 개발 또는 유지보수중인 애플리케이션이나 시스템에 중요한 아키텍처 특성들이다.
- 의존성dependency은 전체 확장성, 모듈성, 민첩성, 시험성, 안정성 등에 영향을 미치는 시스템 내부의 컴포넌트와 서비스 간의 커플링 지점이다.
- 인터페이스interface는 게이트웨이, 통합 허브, 서비스 버스, API 프록시를 통해 서비스와 컴포넌트에 액세스하고 조정하는 수단을 말한다.
- 구현 기술construction technique은 아키텍처의 많은 부분에 영향을 미치는 플랫폼, 프레임워크, 도구, 프로세스에 관한 결정이다.

### 19.3 아키텍처 결정 레코드

아키텍처 결정을 가장 효과적으로 문서화하는 방법은 아키텍처 결정 레코드Architecture Decision Record(ADR)이다. 마이클 나이가드의 블로 게시글에서 처음 소개됐고 이후 쏘우트웍스 기술 레이더ThoughWorks Technology Radar에서 '채택됨adopt'으로 표시했다. ADR은 아키텍처 결정이 기술된 짧은 텍스트 파일이다.

ADR 관리 도구도 있는데 < 테스트 주도 개발로 배우는 객체 지향 설계와 실천 > 의 냇 프라이스Nat Pryce는 ADR-tools라는 전용 오픈 소스 도구를 개발했다. 이 도구는 채번 스키마numbering schemes, 위치, 대체 로직superseded lgic등 ADR 관리 CLI를 제공한다.

#### 19.3.1 기본 구조

제목Title, 상태Status, 콘텍스트Context, 결정Decision, 결과Cnosequences 이렇게 5개의 섹션으로 구성된다.
여기에 컴플라이언스Compliance와 노트Notes라는 추가 섹션을 덧붙인다.

**제목**

ADR 제목title은 일련 번호화 함께 아키텍처 결정을 짤막한 문구로 표현한다. 아키텍처 결정의 성격과 콘텍스트의 모호함을 해소할 수 있을 정도로, 짧고 간결하게 기술한다.
예)
42. 주문 서비스와 결제 서비스 간의 비동기 메시징 사용

**상태**

ADR 상태status는 제안됨Proposed, 수락됨Accepted, 대체된Superseded로 표시한다.
대체됨은 어떤 결정이 내려졌고, 왜 그런 결정을 했는지, 새로운 결정은 무엇이고 어쩌다 변경을 하게 됐는지 등에 관한 이력을 보관하는 강력한 수단이다.
예)
42. 주문 서비스와 결제 서비스 간의 비동기 메시징 사용
상태: 68로 대체됨
68. 주문 서비스와 결제 서비스 간의 REST 사용
상태: 수락됨, 42를 대체함.

> ADR과 의견 요청(RFC)
아키텍트가 ADR 초안을 보내 다른 사람의 의견을 구할 때는 의견 요청Request for Comments(RFC)라는 새로운 상태로 바꾸고 검토 완료 마감일을 지정하는 것이 좋다. 이렇게 해야 결론 없이 논의만 무성한 분석 마비 안티패턴을 방지할 수 있다.

ADR 상태 섹션은 상사나 다른 수석 아키텍트와 대화를 하도록 만들기 때문에 중요한 측면도 있다. 비용, 전체 팀 영향도, 보안 이 세 가지 기준은 이런 대화를 시작하기에 좋은 주제이다. 지출 한도에 대한 합의가 이루어지고 문서화를 잘 해두면 ADR을 생성하는 모든 아키텍트는 스스로 승인할 수 있는 결정과 아닌 결정을 구별할 수 있을 것이다.

**콘텍스트**

ADR 콘텍스트context 섹션은 불가항력적인 요소를 특정한다. 즉, '어떤 사정 때문에 그렇게 결정할 수밖에 없었나?' 이다. 특수 상황이나 문제점을 기록하고 다른 대안에 대해서도 기록한다. 대안에 대한 상세 분석 문서가 필요할 경우 ADR에 대안alternatives 섹션을 추가한다.
예)
'현재 주문의 총 결제 금액을 주문 서비스가 처리하려면 반드시 결제 서비스에 정보를 전달해야 하는데, 이는 REST 또는 비동기 메시징을 통해 수행할 수 있다'

아키텍트는 콘텍스트를 기술함으로써 곧 아키텍처를 기술하는 것이라고 볼 수 있다.

**결정**

ADR 결정decision 섹션에는 아키텍처 결정과그렇게 결정하게 된 사유를 전부 밝힌다.
예)
'서비스 간의 비동기 메시징이 최선의 선택이라고 생각한다' (X) 
'서비스 간에는 비동기 메시징을 사용할 것이다' (O)

이렇게 해야 결정을 설명하는 문장으로 설득력이 있다.

결정 섹션의 가장 큰 강점은 아키텍트가 방법how 보다 이유why에 더 무게를 실을 수 있다는 것이다.
결정을 내린 이유와 함께 사연을 알고 나면 맥락을 잘 이해하고 다른 문제가 생기지 않게 리팩터링을 통해 실수를 예방할 수 있다.

**결과**

ADR 결과consequences 역시 아주 강력한 섹션이다. 이 섹션에는 아키텍처 결정의 전체적인 영향도를 기술한다. 아키텍처 결정이 어떤 영향을 미치는지 구체적으로 기술함으로써 아키텍트는 결정의 장점보다 그 영향이 더 중요한지 되돌아보게 된다.

이 섹션은 아키텍처 결정에 관한 트레이드오프는 물론, 분석 결과도 문서화할 수 있으므로 유용하다.
결과 섹션에서 트레이드오프 분석 등 아키텍처 결정의 콘텍스트에 대한 전체 그림을 그려볼 수 있어서 이슈를 예방할 수 있다.

**컴플라이언스**

ADR의 컴플라이언스compliance 섹션은 표준은 아니지만 권장 사항이다. 이 섹션은 아키텍트가 아키텍처 결정을 어떻게 측정/관리하는 게 좋을지 생각하게 만들어 준다.

예)
n-tier 아키텍처에서 '비즈니스 레이어에서 비즈니스 객체가 사용하는 모든 공유 객체는 공유 서비스 레이어에 두고 공유 기능을 분리하여 구현한다'에 대한 결정은 자바 아크유닛ARchUnit이나 C# 넷아크테스트NetArchTest를 사용해서 측정/관리를 자동화 할 수 있다. 이 섹션에는 어떤 테스트를 하고 그 테스트를 어디서 찾을 수 있는지, 테스트는 언제 어떻게 실행되는지도 지정한다.

**노트**

노트note 섹션 역시 표준 섹션은 아니지만 추가하는 것이 좋다. 다음과 같은 ADR 메타데이터가 포함되기 때문이다.

- 원저자, 승인일, 승인자, 대체일, 최종 수정일, 수정자, 최종 수정 내역

ADR을 git에 저장할 때도 지원하지 않는 부가적인 메타 정보가 있으면 유리하다. 

#### 19.3.2 ADR 저장

저장 위치와 상관 없이 아키텍처 결정은 자체 파일이나 위키 페이지를 가지고 있어야 한다.
일부 아키텍트는 ADR을 소스 코드와 함께 git repository에 보관하는 것을 선호하지만 주의할 점이 있다.

첫째,
일부 이해관계자는 git repository에 액세스할 수 없는 경우가 있다.
둘째,
git repository를 벗어난 콘텍스트가 있는 ADR은 git에 저장하는 건 적절하지 않다. - 통합 아키텍처나 엔터프라이즈 아키텍처 결정, 모든 애플리케이션에 공통적인 결정 등

그러므로 ADR은 위키 또는 다른 문서 렌더링 소프트웨에에서 쉽게 접근 간으한 공유 파일 서버의 공유 디렉터리에 저장하는 것이 좋다.

#### 19.3.3 ADR로 문서화

일부 아키텍처 도식화 표준은 사이먼 브라운Simon Brown의 C4 모델, 오픈 그룹의 아키메이트ArchiMate 가 있긴 하지만 이렇다 할 소프트웨어 아키텍처 문서화 표준은 없다.

ADR은 소프트웨어 아키텍처를 효과적으로 문서화 하는 수단으로 활용할 수 있다. 무엇보다 중요한 섹션은 결정 섹션으로 아키텍처 결정을 내린 사유가 기술된 것 만으로 가치가 있다. 왜냐하면 트레이드오프 분석과 같이 결정을 내리게 된 사정을 결과 섹션에 기술함으로써 아키텍처 문서화의 마지막 퍼즐 조각이 맞춰지는 것이라 볼 수 있다. 

#### 19.3.4 ADR로 표준화

아키텍트 본인이 정당화할 수 없는 표준을 정해 적용하는 것은 타당하지 않다. 표준이 필요한 이유를 개발자가 더 잘 납득할 수 있게 해야 그들이 표준을 따를 (그래서 반기를 들지 않을) 가능성이 높아진다. ADR 결과 섹션은 어떤 표준이 타당하며 반드시 지켜져야 하는지를 아키텍트 스스로 검증하기에 적합한 기회이다. 아키텍트는 자신이 작성 중인 표준의 의미와 결과가 무엇인지 심사숙고해야 한다.

#### 19.3.5 예시

아키텍트는 어떤 시스템에서 확정한 아키텍처 결정들이 아무리 뻔하더라도 그 사유를 밝히고 문서화해야 한다.

GGG 경매 시스템의 아키텍처 결정 사례를 ADR로 만든 것에 대한 예제이다.

```
ADR 76. 입찰 서비스 간 펍/섭 메시징

상태
수락됨

콘텍스트
BidCapture 서비스는 온라인 입찰자 또는 경매인을 통한 라이브 입찰자로부터 입찰을 받아 BidStreamer 서비스, BidTracker 서비스에 전달해야 한다.
입찰은 비동기 점대점(p2p), 비동기 펍섭(pub/sub), 온라인 경메 API를 통한 REST 방식으로 전달할 수 있다.

결정
BidCapture, BidStreamer, BidTraker 세 서비스는 비동기 펍/섭 메시지를 주고 받기로 결정할 예정이다.
BidStreamer 서비스는 BidCapter 서비스가 받은 순서 그대로 입찰을 수신해야 한다.
메시징과 큐는 스트림의 입찰 순서를 자동으로 보장한다.
비동기 펍/섭 메시징을 사용하면 입찰 프로세스의 성능이 개선되고 입찰 정보를 확장할 수 있다.

결과
메시징 큐의 고가용성이 필요하고 클러스터 구성을 해야 할 것이다.
내부 입찰 이벤트는 API 레이어에서 수행되는 보아 체크를 우회할 것이다.
업데이트: 2020년 4월 14일 ARB 회의에서 검토한 결과, ARB는 위와 같은 트레이드오프를 수용하기로 판단했으며, 세 서비스 간 입찰 이벤트에 추가적으로 보안 체크는 필요하지 않다고 결론지었다.

컴플라이언스
주기적으로 수동 코드 검삭 및 설계 리뷰를 실시하여 BidCapture, BidStreamer, BidTracker 세 서비스 간에 비동기 펍/섭 메시징이 제대로 이뤄지고 있는지 확인할 예정이다.
```