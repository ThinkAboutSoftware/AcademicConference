## CHAPTER 22 개발팀을 효율적으로

```
논의주제)
저는 체크리스트와 함께 호손 효과라는 것도 흥미롭게 접했습니다.
확실히 매번 하는 작업이지만 익숙하기도 하고 굳이 설명을 해야 하나 라는 생각이 들 정도의 작업이 있긴 합니다.

체크리스트 까지는 아니더라도 작업 가이드 정도를 따라서 체크해보신 분과
그 가이드 문서를 수정해서 최신 상태로 유지한 경험이 있는지 얘기해보면 좋겠습니다.
```

소프트웨어 아키텍트는 기술 아키텍처를 정립하고 아키텍처 결정을 내릴 뿐만 아니라, 개발팀이 아키텍처를 올바르게 구현하도록 안내할 책임이 있다. 이 일을 잘하는 아키텍트는 개발팀과 긴밀하게 협력하여 문제를 해결하고 성공적인 해법을 찾아낸다. 팀을 생산적으로 만드는 능력은, 유능하고 성공적인 소프트웨어 아키텍트가 다른 아키텍트들과 차별화되는 강점이다.

### 22.1 팀 경계

소프트웨어 아키텍트로 부터 멀어졌다고 느끼는 개발팀은 시스템의 다양한 제약조건을 제대로 알지 못하고 경험도 없기 때문에 아키텍처를 올바르게 구현하지 못한다.

소프트웨어 아키텍트는 개발자가 아키텍처를 구현할 수 있게 제약조건이나 어떤 틀을 만들어 개발팀과 소통한다. 아키텍트의 경계는 너무 빡빡하거나 느슨하면 아키텍처를 구현하는 팀의 능력에 직접적인 영향을 미친다.

<img width="436" alt="image" src="https://github.com/jongfeel/BookReview/assets/17442457/c6a384dd-e4fe-49a4-bf17-4904923ec0ed">

제약 조건이 많아 빡빡한 틀을 만들면 개발자는 시스템을 구현하는 도구, 라이브러리, 프랙티스를 사용하지 못하게 된다.
반대로 제약을 너무 느슨하게 적용해서 중요한 아키텍처 결정을 모두 개발팀에 위임하는 경우도 있다. 개발팀 본인들이 스스로 아키텍트의 역할을 맡아 직접 개념 증명proof of concept(PoC)을 하고, 설계 결정을 놓고 서로 싸우며 혼란과 불만을 느낀 채 비생산적으로 일하게 된다.

### 22.2 아키텍트 성향

팀 경계 별 아키텍트는 다음과 같다.

- 내 맘대로 아키텍트: 빡빡한 경계
- 유체이탈 아키텍트: 느슨한 경계
- 유능한 아키텍트: 적합한 경계

#### 22.2.1 내 맘대로 아키텍트

<img width="455" alt="image" src="https://github.com/jongfeel/BookReview/assets/17442457/54d3edf3-c251-4ca6-98d5-36151b05fbdf">

내 맘대로 아키텍트control freak architect는 개발의 세세한 부분을 일일이 통제하려고 한다. 이런 결정은 세부적으로 저수준에 관한 내용이라서 개발팀에 과도한 제약을 초래한다.

내 맘대로 아키텍트가 있으면 개발자는 프로그래밍 스킬을 빼앗겼다는 생각에 좌절감에 빠지고 더 이상 아키텍트를 존경하지 않게 된다.

특히, 개발자에서 아키텍트로 전향한 사람들이 이런 아키텍트가 되기 쉽다. 아키텍트는 컴포넌트의 구성 요소와 그 상호 작용을 결정하는 일을 해야 하는데, 아키텍트가 된 개발자는 직접 클래스 설계와 패턴을 만들려고 하는 유혹에 빠지기 쉽다.

아키텍트는 프로젝트의 복잡성과 팀 기술 수준에 따라 내 맘대로 아키텍트라는 악역을 맡아야 할 때도 있다. 하지만 대개 개발팀을 혼란에 빠뜨리고, 방해만 될 뿐 팀을 이끌어 아키텍처 구현을 리드하는데 적합하지 않다.

#### 22.2.2 유체이탈 아키텍트

<img width="460" alt="image" src="https://github.com/jongfeel/BookReview/assets/17442457/ece7973f-0279-4e03-839b-dddb23d34ccf">

유체이탈 아키텍트armchair architect는 오랫동안 코딩을 한 적이 없어서 세부 구현 사항은 나몰라라 하는 아키텍트이다. 이런 아키텍트는 초안이 완성되면 개발팀과 연락이 끊기고 다른 프로젝트로 홀연히 사라지곤 한다.

개발자는 코딩을 하는 사람으로 거짓으로 꾸며내기가 어렵다.
아키텍트는 선과 상자를 그리는데 얼마나 상세하게 그려야 하는지 의문을 가져보면 불편한 진실을 알 수가 있다. 
바로 아키텍트가 가짜 아키텍처를 만들기가 너무 쉽다는 사실이다!

아래 유체이탈 아키텍트가 그린 그림은 너무 고수준 다이어그램이다.

<img width="456" alt="image" src="https://github.com/jongfeel/BookReview/assets/17442457/006f44a8-4aae-4b44-be81-da1f0b5f3603">

유체이탈 아키텍트는 개발팀을 느슨한 경계로 설정하므로 결국 개발팀이 아키텍트 역할을 맡아 그 일을 대신하게 된다. 그렇게 되면 진척도와 생산성이 떨어지는 것은 물론, 시스템 작동 방식을 이해하는 과정에서도 혼란에 빠진다.

유체이탈 아키텍트의 가장 분명한 징후는 개발팀과 얘기할 시간을 갖지 않거나 아예 만나서 얘기를 하지 않으려는 자세이다.
유체이탈 아키텍트의 다른 징후들로

- 비즈니스 영역, 비즈니스 문제, 기술을 온전히 이해하지 못한다
- 소프트웨어 개발 실무 경력이 부족하다
- 아키텍처 솔루션 구현에 함축된 의미를 전혀 신경 쓰지 않는다.

이런 아키텍트가 되지 않으려면 프로젝트에서 쓰이는 기술에 더 많이 관여하고 비즈니스 문제/영역을 잘 이해하려고 노력해야 한다.

#### 22.2.3 유능한 아키텍트

유능한 소프트웨어 아키텍트effective software architect는 개발팀에 적절한 제약조건과 경계를 설정하고 팀원들이 서로 잘 협력할 수 있도록 독려하며 그들을 올바른 수준으로 가이드한다. 또 팀이 용도에 맞는 도구와 기술을 보유하고 있는지 확인하고 개발자들이 목표를 달성하는 데 걸림돌이 될 만한 요소를 제거한다.

뻔한 얘기처럼 들리지만 개발팀을 잘 이끄는 유능한 리더가 되는 것은 일종의 예술이다. 유능한 소프트웨어 아키텍트는 개발팀과 긴밀하게 협력하면서 그들의 존경심을 이끌어 낸다.

### 22.3 얼마나 제어해야 하나?

로이 오셰로브Roy Osherrove는 탄력적 리더십elastic leadership이라는 개념을 널리 보급했다. 유능한 소프트웨어 아키텍트가 되는 것은 아래 나열한 다섯 가지 팩터와 관련이 있으며 한 번에 관리 가능한 팀의 수도 이 다섯 가지 팩터가 결정한다.

**팀원 간 친밀도**

팀원들이 서로 잘 아는 사이라면 스스로 조직화하기self-organizing 시작하므로 제어가 덜 필요하다.
반대라면 팀원 간 협업을 촉진하고 팀 내 파벌을 없애기 위해 더 많은 제어가 필요하다.

**팀 규모**

12명이상이면 큰 팀, 4명 이하면 작은 팀으로 본다.
팀이 커지면 더 많은 제어가 필요하고, 팀이 작으면 제어가 덜 필요하다.

**전체적인 경험**

주니어 개발자가 많은 팀은 제어와 멘토링이 더 필요하고,
시니어 개발자가 더 많은 팀은 제어가 덜 필요하다. 시니어 팀에서 아키텍트는 멘토가 아닌 사실상 조정자facilitator의 역할을 한다.

**프로젝트 복잡도**

복잡도가 높은 프로젝트를 수행하려면 아키텍트가 팀에 더 많이 관여하여 많은 제어를 할 수 밖에 없다.
단순한 프로젝트는 그 자체로 간단하니 별로 제어할 필요가 없다.

**프로젝트 기간**

짧으면 2개월
보통이면 6개월
길면 2년 정도로 볼 수 있다.
기간이 길면 더 많은 제어가 필요하고 짧으면 덜 필요하다.

2개월 짜리 단기 프로젝트에서 개발팀은 일정이 빼듯하다는 걸 알고 있기 때문에 차라리 유체이탈 아키텍트처럼 행동하는 것이 낫다.
2년 짜리 프로젝트라면 개발팀의 긴장은 없을 것이다. 따라서 제때 프로젝트를 진행시키고 복잡한 작업을 먼저 치고 나가려면 아키텍트가 더 많은 제어를 해야 한다.

시스템이 진화할수록 제어 수준도 달라지므로 프로젝트 진행 내내 이 팩터들을 지속적으로 분석하여 개발팀을 어느 정도까지 제어할지 결정하는 게 좋다.

각 팩터별 점수는 20점이고
음(-)의 값이면 유체이탈 아키텍트(제어와 관여를 덜 함)
양(+)의 값이면 내 맘대로 아키텍트(제어와 관여를 더 많이 함)을 의미한다.

<img width="452" alt="image" src="https://github.com/jongfeel/BookReview/assets/17442457/38827724-548a-439c-bd88-850cb2388fdc">

이런 척도는 팀을 제어할 상대량을 파악하는 용도로는 요긴할 수 있다.

프로젝트 시나리오 1의 결과로 총 누적값은 -60점으로 아키텍트는 개발팀을 방해하지 않고 알아서 하도록 내버려두는 게 좋다는 결론이다.

<img width="464" alt="image" src="https://github.com/jongfeel/BookReview/assets/17442457/4d3b5ebf-2cbb-4aca-b2e9-f0d7c92ece8e">

시나리오 1의 경우 유능한 소프트웨어 아키텍트는 처음에는 조정자 역할을 하며 팀원들과 그들의 업무에 깊이 개입하지 않는다. 아키텍트는 대부분의 시간 동안 팀원들 질문에 답변하고 팀이 정상 궤도에 있는지 체크하면서, 숙련된 팀원 각자가 본인이 제일 잘 아는 일을 수행해서 소프트웨어가 빨리 개발되도록 맡긴다.

프로젝트 규모가 크고 팀원들은 서로 잘 아는 사이지만 주니어 개발자가 대부분이다. 기간도 6개월이라 누적값을 계산해 보면 -20점이다. 따라서 아키텍트가 팀원들의 업무에 관여하여 멘토, 코치 역할을 어느 정도 수행하는 편이 더 효과적이다.

<img width="459" alt="image" src="https://github.com/jongfeel/BookReview/assets/17442457/ad9326ee-9243-4289-a3ac-4ed73ffe102e">

<img width="447" alt="image" src="https://github.com/jongfeel/BookReview/assets/17442457/d1f48f7e-8d9a-42de-a38b-2cb77b26acaa">

소프트웨어 아키텍트가 팀을 제어하고 팀원들의 업무에 관여하는 정도는 팩터마다 다르다.
아키텍트는 팀에 어떤 종류의 제어를 할 것인지, 개발팀이 어떤 틀 안에서 작업을 수행하도록 만들지 고민해야 한다.

### 22.4 팀의 이상 징후

팀 규모는 아키텍트가 개발팀에 행사하는 제어량에 영향을 미치는 팩터 중 하나이다. 가장 효율적인 개발팀의 규모는 다음 세 가지 팩터에 의해 결정된다.

- 프로세스 손실process loss
- 다원적 무지pluralistic ignorance
- 책임 확산diffusion of responsibility

**Process loss**

프로세스 손실process loss는 프레드 브룩스가 < 맨먼스 미신 > 에서 처음 고안한 용어이다. 기본적으로 프로젝트에 인력을 더 많이 투입할수록 프로젝트를 수행하는 시간이 더 길어진다는 것이다. 그룹 퍼텐셜group potention은 팀원 모두의 집합적인 노력에 의해 정의되지만 실제 생산성은 이 그룹 퍼텐셜에 훨씬 못 미친다. 이 차이가 팀의 프로세스 손실이다.

<img width="434" alt="image" src="https://github.com/jongfeel/BookReview/assets/17442457/d9677c5a-d56a-4102-894d-55ae22c24db8">

유능한 소프트웨어 아키텍트는 개발팀을 잘 관찰하여 프로세스 손실을 찾는다. 이걸 방지하려면 팀 내부에 병렬 작업이 가능한 부분을 찾고 팀원들이 각자 별도의 서비스나 애플리케이션 영역에서 작업할 수 있는 환경을 제공해야 한다. 또 새 팀원이 합류해도 병렬 작업 흐름을 생성할 부분이 없으면 부정적인 영향이 있을 것이라는 점을 프로젝트 관리자에게 설명해야 한다.

**Pluralistic ignorance**

다원적 무지는 모든 사람들이 자신이 너무 뻔한 것을 놓치고 있는 게 아닐까 두려운 나머지 어떤 표준에 순순히 동의하는 현상이다. 한 팀원이 팀이 결정한 서비스 메시징에 대해 개인적으로 동의하지 않았지만 마지못해 동의했는데, 결국 그 팀원의 생각이 옳았음이 밝혀지는 사례가 있다.

다원적 무지는 한스 크리스티안 안데르센의 유명한 덴마크 동화 '황제의 새옷'에도 등장한다. 옷을 볼 자격이 없는 사람들한테는 보이지 않는다고 믿고 황제는 나체로 돌아다니는데, 아무도 왕에게 지적을 못하지만 결국 한 아이가 아무 옷도 입지 않았다고 외칠 때 까지 황제의 바보짓이 계속된다.

유능한 소프트웨어 아키텍트는 어떤 성격의 협업 회의나 토론을 하더라도 상대방의 표정과 몸짓을 끊임없이 관찰하며 다원적 무지가 일어날 것 같으면 조정자를 자처한다. 그 동안 논의된 해결책에 대해 사람들의 의견을 듣고 그들 편에서 지지해 줘야 한다.

```
의견)
관찰을 잘 해서 올바른 방향으로 이끌어 주는 것. 이게 정말 필요한 자세라고 생각한다.
협의해서 결정하고 지시하는 것 까지는 평범한 사람까지는 할 수 있는 능력이지만
관찰해서 해결책을 찾고 방향을 제시하는 건 정말 능력있는 사람만이 할 수 있다고 본다.
```

**Diffusion of responsibility**

책임 확산은 적절한 팀 규모를 나타낸다. 팀원 중 누가 무슨 일을 담당하는지 혼란스럽다면 팀이 너무 커졌다는 신호이다.

<img width="452" alt="image" src="https://github.com/jongfeel/BookReview/assets/17442457/d43a22cc-17f2-47a1-8d35-684ada3bbb93">

한가한 시골길에 세워둔 차의 운전자에게는 괜찮냐고 물어보겠지만
차가 붐비는 고속도로 갓길에서는 누군가 이미 도움을 요청했을 것이라 짐작하는 것이다. 하지만 대부분 갓길에 차를 세운 운전자는 도움을 아직 받지 못한 곤란한 상태일 가능성이 높다.

유능한 아키텍트는 개발팀이 아키텍처를 잘 구현하도록 친절하게 안내하는 것은 물론, 팀이 건강하고 행복하게 공동 목표를 달성하도록 서로 협력하는 분위기를 조성한다. 이 세 가지 징후를 발견하여 개발팀 스스로 바로잡을 수 있게 도와주면 팀을 매끄럽게 꾸려갈 수 있다.

### 22.5 체크리스트의 활용

노련한 베테랑 조종사도 매 비행마다 체크 리스트를 사용한다.

아툴 가완디Atul Gawande 박사는 < 체크! 체크리스트 > 라는 명저에서 외과 수술 체크리스트의 강력함을 이야기한다. 이 책에서 체크리스트를 사용한 병원의 포도상구균 감염률은 거의 0이었지만, 그렇지 않은 병원의 감염률은 꾸준히 상승했다고 한다.

체크리스트는 효과가 있는데도 소프트웨어 개발 업계는 체크리스트를 활용하지 않는다. 다시 미묘한 차이가 있는데

첫째,
소프트웨어 개발자는 항공기를 조종하거나 심장 수술을 하는 사람들이 아니기 때문이다. 팀을 효율적으로 운영하려면 체크리스트를 활용할 때와 하지 말아야 할 때를 잘 구분해야 한다.

아래와 같이 데이터베이스 테이블을 새로 만드는 경우는 체크리스트라고 볼 수 없다.

![image](https://github.com/jongfeel/BookReview/assets/17442457/b6aa707f-1eb6-4068-8db0-fd0f59c00f00)

일련의 절차와 단계가 체크리스트에 포함되서는 안된다. 앞 절차가 실행되야 그 다음 작업을 할 수 있는 종속적인 작업들은 체크리스트에서 걸러내야 한다.

체크리스트에 적합한 프로세스는 순서나 종속된 작업이 없는 프로세스, 에러가 발생하기 쉽거나 누락되어 다음으로 넘어가기 쉬운 단계가 있는 프로세스이다. 이걸 아키텍트가 개발팀의 능률을 높인다는 목적으로 프로젝트의 모든 걸 체크리스트로 만드는 건 수확 체감의 법칙law of diminishing returns으로 이어지게 만든다.

아키텍트의 올바른 역할은 내부의 필요한 단계를 포착하고, 그 단계를 체크리스트로 만드는 걸 최소화하는 것이다. 대부분의 개발자는 아키텍트가 만들어 놓은 체크리스트는 거들떠도 안보기 떄문에 자동화해서 체크할 수 있는 건 체크리스트에서 제외해야 한다.

> TIP. 체크리스트에 뻔한 내용을 적는 걸 두려워하면 안된다. 뻔한 것도 대부분 넘어가거나 놓치기 때문이다.

경험상 효과적이라고 생각하는 체크리스트는

- 개발자 코드 완료
- 단위/기능 테스트
- 소프트웨어 릴리스

등이다.

---

<h3 align="center">호손 효과</h3>

체크리스트가 의미가 있으려면 바빠서 보여주기식으로 넘어가는 것이 아닌 실제 개발자가 체크리스트를 사용하도록 만드는 것이다.

체크리스트를 사용하는 것의 중요성과 체크리스트가 팀을 어떻게 변화시킬 수 있는지 팀원들을 이해시키는 것이다. 아툴 가완디의 < 체크! 체크리스트 >를 읽어보라고 권해서 체크리스트의 강력함과 당위성, 사용해야 하는 이유를 납득하게 해야 한다.

다른 대안이 없다면 호손 효과Hawthorne effect를 일으켜볼 수 있다. 호손 효과는 사람들이 자신이 관찰 대상이 되거나 모니터링되고 있다는 사실을 알고 나면 행동을 바꾸고 올바른 일을 하는 것을 의미한다. 실제 동작하지 않는 CCTV가 좋은 예다.

호손 효과는 체크리스트 사용을 관리하는 용도로 쓰인다.  아키텍트는 가끔씩 체크리스트가 정확한지 무작위 추출 검사인 스폿 체크spot check만 하면 된다. 호손 효과가 일어나면, 실제 완료되지 않은 태스크를 완료된 것으로 표시하거나 그냥 넘어가버릴 가능성이 줄어들 것이다.

---

#### 22.5.1 개발자 코드 완성도 체크리스트

개발자가 코드를 '완료'했다고 말할 때 사용하기 좋은 도구가 개발자 코드 완성도 체크리스트이다. '완료된 것의 정의definition of done'를 정할 때도 유용하다. 체크리스트에는 다음과 같은 내용이 포함된다.

- 자동화 도구에 포함되어 있지 않은 코딩 및 포매팅 표준
- 자주 간과되는 항목(예: 로그 속에 파묻힌 예외)
- 프로젝트에 특정한 표준
- 특별한 팀 지침이나 절차

![image](https://github.com/jongfeel/BookReview/assets/17442457/76f55fc5-1bb3-4010-9b79-491064600d3d)

퇴근 무렵이나 이터레이션 종료 쯤에 당연한 건데도 의외로 놓치는 개발자가 많다.
2, 3, 6, 7번의 경우 현재 프로젝트에만 특정지은 작업들이다. 체크리스트 말고 자동화할 수 있는 방법이 있는지 찾아볼 수 있다. 이런 부분을 찾아낼 수 있다면 체크리스트 분량과 노이즈를 줄여 효과적인 체크리스트를 만들 수 있다.

#### 22.5.2 단위/기능 테스트 체크리스트

이 체크리스트에는 개발자가 테스트를 잊기 쉬운, 특이한 엣지 케이스 테스트가 들어 있다. QA팀에서는 어떤 테스트 케이스에서 이슈를 발견할 때마다 이 체크리스트에 추가한다.

분량은 많은 편이지만 가능한 한 완전 코딩을 보장해서 개발자가 체크리스트 점검을 마치면 기본적으로 코드를 프로덕션 배포가 가능한 상태로 만드는 것이 목표이다.

- 텍스트 필드의 특수 문자와 숫자 필드
- 최솟값/최댓값 범위
- 흔치 않고 극단적인 테스트 케이스
- 누락된 필드

여기서도 자동화 테스트로 확인 가능한 항목은 개발자 코드 완성도 체크리스트와 마찬가지로 체크리스트에서 제거한다.

또 이 체크리스트는 일반적인 또는 특정한 테스트 시나리오가 소프트웨어 개발 프로세스에 포함됐는지 확인할 수 있는 수단으로, 별도의 팀이 이런 활동을 수행하는 환경이라 해도 이 체크리스트는 개발자와 테스터의 간극을 좁히는 데 효과적이다.

완전한 테스트를 수행하는 개발팀이 많을수록 테스트팀도 작업이 용이해지고 체크리스트에 없는 특정 비즈니스 시나리오에 집중할 수 있다.

#### 22.5.3 소프트웨어 릴리스 체크리스트

릴리스는 소프트웨어 개발 라이프 사이클에서 가장 에러가 발생하기 쉬운 부분이므로 체크리스트를 작성하면 큰 도움이 된다. 빌드 및 배포 실패를 예방하는 데에도 탁월한 효능이 있고 소프트웨어 출시 관련 리스크도 크게 줄어든다.

배포가 실패하거나 이슈가 발생할 때 마다 새로운 에러와 사건을 해결하면서 체크리스트가 계속 바뀌게 되는 특징이 있다.

일반적으로 다음과 같은 내용이 포함된다.

- 서버 또는 외부 구성 서버의 설정 변경
- 프로젝트에 추가된 서드파티 라이브러리(JAR, DLL 등)
- 데이터베이스 업데이트 및 해당 데이터베이스의 마이그레이션 스크립트

아키텍트는 빌드/배포가 실패하면 근본 원인을 분석하고 그 내용을 소프트웨어 릴리스 체크리스트에 바로 추가하고 향후 같은 문제가 생긱지 않게 관리한다. 

### 22.6 지침 제시

소프트웨어 아키텍트는 설계 원칙을 적용하고 지침을 제공해서 팀을 효과적으로 만들 수 있다. 설계 원칙을 효과적으로 전달하는 것은 팀을 성공적으로 이끄는 핵심 요소이다.

유능한 소프트웨어 아키텍트는 다음 질문에 개발자가 먼저 답하도록 유도함으로써 개발팀에 지침을 제시한다.

- 제안한 라이브러리와 기존 시스템의 내부 기능 사이에 중첩되는 부분이 있는지
- 제안한 라이브러리를 반드시 사용해야 하는 당위성은 무엇인지

첫 질문은 새 라이브러리를 다시 살펴보게 해서 기능 중복이 초래되지 않게 체크할 수 있다.
두 번째 질문은 왜 필요한지 개발자가 자문하도록 유도한다. 아키텍트는 기술적 타당성과 비즈니스 타당성 둘 다 요구하므로 개발팀 내에서 비즈니스 정당화의 필요성에 대한 인식을 제고하는 강력한 기술이다.

---

<h3 align="center">비즈니스 정당화의 영향</h3>

마크는 큰 프로젝트를 진행했던 수석 아키텍트였는데, 스칼라 프로그래밍을 쓰게 해달라는 팀원의 요청을 받고, 핵심 팀원 두 사람이 다른 팀으로 옮기겠다는 얘기까지 나왔을 때 내린 결정은 다음과 같다.

프로젝트에서 스칼라는 써도 되지만, 교육 비용과 코드 재작성 작업을 감당해도 좋을 만한 비즈니스 정당화하는 직접 제공해야 한다고 얘기해 줬다. 스칼라 매니아는 좋아했지만 다음 날 결과는 좀 달랐다.

스칼라 매니아는 겸손하게 "감사합니다" 라는 말을 한 후에, 스칼라를 쓰는 기술적 사유는 얼마든지 있지만, 기술 이점 중 비용, 예산, 일정 등 프로젝트에서 필요한 아키텍처 특성 측면에서 비즈니스 가치가 있는 것은 없었다는 걸 깨달았다는 얘기를 했다.

이후 스칼라 매니아는 팀에서 최고 기여자로 변화했는데, 그가 프로젝트에서 원하는 것을 비즈니스적으로 정당화해야 한다는 사실을 깨달았기 떄문이었다. 이후 더 나은 소프트웨어 개발자가 되었고, 나가겠다고 했던 핵심 개발자 두 명 역시 계속 남아 있게 되었다.

---

```
의견)
만약 마크팀에 있는 스칼라 매니아 팀원 같은 사람이 실제 있다면
더할 나위 없이 좋을 것 같다는 생각이다.
하지만 내가 본 우리나라 개발자들의 특징은
회사에서 자기가 쓰는 기술이 커리어에 영향을 주지 않게 하려고 팀 이동이나 이직을 하고,
반대로 내 커리어에 영향을 줄 수 있는 기술을 회사가 쓰게 만드려고 하는 경향이 아주 강하다.
10년 이상 일을 하고 시니어 레벨을 넘어서면 의미가 없을 거라고 얘기해줘도
10년 후의 미래 까지 20년을 먼저 살았던 사람의 말을 듣고 바꾸는 걸 본 적이 없었기 때문에
어쩔 수 없는 현상이지 않나 라는게 내 생각이다.
```

아래 그림은 레이어드 스택을 제어하는 구조를 시각화한 예이다.

![image](https://github.com/jongfeel/BookReview/assets/17442457/560a6fd9-9333-47e1-9ae2-195f09e1621e)

이 그림에서 아키텍트는 서드파티 라이브러리의 각 범주에 어떤 내용이 포함되는지, 개발자는 무엇을 할 수 있고 무엇을 할 수 없는지(설계 원칙)를 예시한다.

**특수한 목적Special purpose**

PDF 랜더링, 바코드 스캐닝과 같이 커스텀 소프트웨어를 작성할 만한 이유가 없는 특수한 라이브러리

**일반적인 목적General purpose**

자바의 아파치 커먼스Apache Commons, 구아바Guava와 같이 언어 API를 감싼 래퍼

**프레임워크**

퍼시스턴스(하이버네이트), 제어 역전Inversion of control(스프링) 등에 사용하는 라이브러리.
이런 라이브러리는 애플리케이션의 전체 레이어나 구조를 형성하며 어디에나 널리 퍼져 있다.

이렇게 범주화한 다음에 이 설계 원칙을 줌심으로 틀을 만든다. 아키텍트가 특정한 목적에 맞는 라이브러리를 지정하면 개발자는 아키텍트의 조언을 따로 구할 필요없이 스스로 판단할 수 있다. 개발자가 알아서 중복 분석을 한 후 정당화할 수 있지만, 라이브러리는 아키텍트의 승인이 필요한 범주이다.

마지막으로 프레임워크 라이브러리는 아키텍트가 결정한다. 이런 종류의 라이브러리는 개발팀이 분석할 대상이 아니며, 아키텍트가 책임져야 할 부분이다.

### 22.7 마치며

탄력적 리더십, 체크리스트 활용, 설계 원칙을 효과적으로 전달해서 지침을 제공하는 간단한 기법들을 언급했다.

이런 활동을 아키텍트가 아닌 PM이나 개발 관리자에게 맡기는 경우도 있는데 올바른 방법은 아니다.
아키텍트는 팀을 기술적으로 이끌 뿐 아니라 아키텍처 구현을 통해 팀을 리드하기도 하기 때문이다. 소프트웨어 아키텍트는 개발팀과 긴밀한 협력관계를 유지하면서 팀 역학을 관찰하고 변경을 촉진하여 효과적으로 팀을 움직일 수 있다. 이것이 기술만 가진 아키텍트와 유능한 소프트웨어 아키텍트를 구분하는 잣대이기도 하다.