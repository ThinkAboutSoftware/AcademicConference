## CHAPTER 11 파이프라인 아키텍처 스타일

```
논의내용)
저는 github actions의 yml 스크립트 짜는 것과 상당히 유사한게 아닌가 하는 생각을 많이 했습니다. 내용이 상당히 짧고 간결한 챕터인데, 제가 생각한 예제 말고 다른 예제를 생각한 게 있다면 공유해 보면 좋겠습니다.
```

파이프라인 아키텍처pipeline architecture(파이프와 필터pipes and filters 아키텍처라고도 함) 개발자와 아키텍트가 기능을 개별 파트로 분리하기로 결정하는 순간 부터 이 패턴이 수반된다. Bash, Zsh 같은 유닉스 터미널 쉘 언어의 기초 원리이기도 하다.

함수형 언어 개발자는 언어 구조와 이 아키텍처 요소가 유사하다고 생각할 수 있다. 맵리듀스 프로그래밍 모델을 응용한 많은 도구가 이 토폴로지를 따른다. 

### 11.1 토폴로지

파이프라인 아키텍처는 다수의 파이프와 필터로 구성된다.

<img width="471" alt="image" src="https://user-images.githubusercontent.com/17442457/235693771-cd68e64f-e4c5-42df-8588-4648c55e9928.png">

#### 11.1.1 파이프

파이프는 한 소스에서 입력을 받아 다른 소스로 출력을 내는, 필터 간 통신 채널이다.
보통 성능상의 이유로 단방향, 점대점 방식으로 구성한다.

#### 11.1.2 필터

필터는 자기 완비형이고self-contained, 다른 필터와 독립적이며, 일반적으로 무상태성stateless이다. 여러 task에 대해서는 여러 필터를 이어 붙여 처리하는 식으로 한다. 필터의 종류는 아래 4가지가 있다.

- 프로듀서producer: 프로세스의 시작점. 나가는 트래픽만 있으므로 소스source라고도 한다.
- 변환기transfomer: 입력을 받아 데이터 일부 또는 전체를 변환 후 아웃바운드 파이프로 전달한다. 함수형 프로그래밍에서는 맵map으로 부른다.
- 테스터tester: 입력을 받아 하나 이상의 기준에 대해 테스트를 하고 결과를 재생산한다. 함수형 프로그래밍에서는 리듀스reduce라고 부른다.
- 컨슈머consumer:  파이프라인 흐름의 종착역이다. 최종 결과를 데이터베이스나 UI에 표시한다.

### 11.2 예제

전자 데이터 교환electronic data interchange(EDI) 도구는 파이프와 필터로 한 종류의 문서를 다른 종류의 문서로 변환한다.
ETLExtract, Transform, Load(추출, 변환, 적재) 도구 역시 다른 데이터베이스나 데이터소스로 데이터를 변환하여 흘릴 때 파이프라인 아키텍처를 활용한다.

다양한 서비스의 텔레메트리telemetry(원격 계측) 정보를 아파치 카프카에 스트리밍 하는 예제

<img width="484" alt="image" src="https://user-images.githubusercontent.com/17442457/235697985-0dba6d32-b0c2-462b-820b-2ddc1ab7f25e.png">

이 예제는 파이프라인 아키텍처의 확장성을 고려해볼 수 있는데, 새로 수집된 메트릭을 데이터베이스에 전달할 경우 가동 시간 필터 다음에 테스트 필터를 하나 더 추가하는 식으로 구성한다.

### 11.3 아키텍처 특성 등급

<img width="471" alt="image" src="https://user-images.githubusercontent.com/17442457/235698513-fdc5abaf-e5cd-4e64-9131-7d2071de191a.png">

애플리케이션 로직을 필터 타입에 따라 나누는 기술 분할 아키텍처이다. 보통 모놀리식 형태로 구현/배포하므로 아키텍처 퀀텀은 언제나 1이다.

주요 강점으로 모듈성과 결부된 전체 비용 및 단순성이다. 모놀리식에 가까우므로 복잡도가 없고, 단순해서 알기 쉬우므로 구축 및 유지보수 비용도 비교적 적게 든다. 다양한 필터와 변환기의 관심사가 분리되므로 모듈성을 확보할 수 있고 필터를 교체/수정해도 다른 필터에는 영향을 미치지 않는다.

배포성, 시험성은 레이어드 아키텍처 보다는 조금 낫지만, 모놀리스라서 절차, 리스크, 배포 빈도, 테스트 완성도의 영향은 받는다.

네트워크 트래픽, 대역폭 부족, 레이턴시로 신뢰성은 중간인 3점이다.

탄력성과 확장성은 모놀리식 배포이므로 1점으로 낮다. 확장을 하려면 멀티스레딩 내부 메시징을 비롯해 병렬 처리 프랙티스와 기법을 동원해야 한다. 

모놀리식 배포와 더불어 부족한 아키텍처 모듈성으로 인해 내고장성도 별로이다. OOMout-of-memory이 발생하면 전체적으로 영향을 받고 충돌이 발생한다. MTTR 역시 모놀리식이므로 적게는 2분, 많게는 15분 이상 시동 시간이 소요된다.