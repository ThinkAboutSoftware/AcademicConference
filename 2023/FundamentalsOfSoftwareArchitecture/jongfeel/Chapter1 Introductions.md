## CHAPTER 1 서론

```
논의주제)
소프트웨어 아키텍트의 기대치에 대해서 8개의 내용을 언급했는데 커뮤니케이션과 정치 처제도 하나씩 얘기할 정도로 흥미로운 내용이 있는 것 같습니다.

다들 흥미롭거나 중요하다고 생각하는 항목을 하나씩 얘기해 보면 좋을 것 같습니다.

저는 다섯번째 항목인 `다양한 기술과 경험에 노출된다`가 제일 공감이 많이 되는 부분이었습니다. 저 역시 한 가지 기술만 가지고 여태까지 일을 해 온게 아니다 보니 너무 맞는 말이라고 생각했었습니다.
```

소프트웨어 아키텍트는 다른 직업에 비해 커리어패스carrer path가 분명하지 않음.

1.
소프트웨어 아키텍트라는 직업 자체에 대한 명확한 정의가 아직도 없다.
마틴 파울러Martin Flwler 역시 백서whitepaper 'Who Needs an Architect?(누가 아키텍트를 필요로 하는가?)에서 명언 한 구절을 인용했을 뿐이다.

> 아키텍처는 중요한 것들에 관한 것이다. 그게 무엇이든 말이다. - 랄프 존슨Ralph Johnson

2.
소프트웨어 아키텍트의 역할은 방대한 분야를 포괄하며 업무 범위도 계속 넓어지고 있다.

![image](https://user-images.githubusercontent.com/17442457/228521081-4ecee8bd-3786-4c3e-af8b-5d092e38d048.png)

3.
소프트웨어 개발 생태계는 빠르게 발전하는 분야이고 소프트웨어 아키텍처는 끊임없이 변한다.
위키피디아에서 정의한 내용인 '일단 구축한 이후에 변경하려면 비용이 드는 근본적인 구조를 선택하는 일' 이라고 나와 있지만 이것 역시 철 지난 문장이다.
소프트웨어 아키텍처는 그 정의를 포함한 본질 자체가 동적이다.

4.
소프트웨어 아키텍처에 관한 자료는 대부분 역사적인 연관성을 강조한다.
소프트웨어 아키텍처의 역사는 과거 아키텍트들이 시도했으나 해로운 부수 효과만 식별하게 된 것들로 난잡하게 얽혀 있다.

그렇다면 소프트웨어 아키텍처 기초에 관한 책이 무슨 소용일까?
소프트웨어 아키텍트는 끊임없이 변하는 생태계 안에서 뭔가 결정을 내리는 사람들이다. 그렇게 결정한 기반을 비롯해 모든 것이 다 변하므로 과거 아키텍처에 관한 글에서 강조한 핵심 원칙들도 다시 검토해봐야 한다. 과거에는 데브옵스라는 개념이 없었기 때문에 그에 따른 영향은 고려하지 않았다.

아키텍처란 예술과 마찬가지로 콘텍스트로서만 이해할 수 있다. 즉, 아키텍트가 내린 결정은 대부분 그들이 그렇게 결정한 당시 환경에 기인한 것이다. 20세기 초반의 아키텍처 주요 목표는 효율적인 리소스 공유인데, 그 당시에는 OS, 서버, DB 등의 인프라 가격이 비쌌기 때문이다. 현재는 오픈소스 기반에 데브옵스를 통해 엔지니어링 프랙티스가 향상 됐으므로 달라진 관점의 아키텍처(마이크로서비스)를 구현할 수 있게 되었다.

모든 아키텍처는 그 콘텍스트의 결과물이라는 사실을 기억해야 한다.

### 1.1 소프트웨어 아키텍처란?

소프트웨어 아키텍처를 바라 보는 한 가지 방법으로

아키텍처 특성architecture characteristic
아키텍처 결정architecture decision
설계 원칙design principle
시스템의 구조structure

로 구성된다.

시스템의 구조는 시스템이 구현된 아키텍처 스타일의 종류를 말한다. (마이크로서비스, 레이어드, 마이크로커널)
마이크로서비스 아키텍처라고만 얘기한 것은 시스템의 구조만 언급했을 뿐, 시스템의 아키텍처를 이야기한 것이 아니다. 나머지 부분들인 특성, 결정, 설계 원칙도 알아야 한다.

아키텍처 특성은 소프트웨어 아키텍처를 다른 관점으로 바라본 것으로 시스템의 기능과 직교orthogonal 시스템의 성공 기준을 결정한다. 시스템이 올바르게 동작하기 위해서는 반드시 필요한 것들이다.

가용성, 신뢰성, 시험성, 확장성, 보안, 민첩성, 내고장성, 탄력성, 복구성, 성능, 배포성, 학습성

아키텍처 결정은 시스템 구축에 필요한 규칙들을 정한 것이다. 레이어드 아키텍처라면 의존성 관계에 대해 결정하는 것이라고 이해할 수 있다. 아키텍처 결정은 시스템의 제약조건constraint을 형성하며, 개발자가 해도 되는 것과 하지 말아야 할 것을 알려준다.
시스템의 한 부분에서 아키텍처 결정을 구현할 수 없다면 그 결정은 변형variance이라는 것을 통해 깨뜨릴 수 있다.

설계 원칙은 가이드라인guideline이다. 예로 마이크로서비스 아키텍처의 성능 향상을 위해 서비스간 통신은 비동기 메시징을 활용해야 한다고 기술하는 것이 설계 원칙이다.

### 1.2 아키텍트에 대한 기대치

소프트웨어 아키텍트에게 바라는 핵심적인 요구사항은 다음 여덟가지로 정리할 수 있다.
유능한 소프트웨어 아키텍트가 되려면 사람들이 자신에게 바라는 요구사항을 충분히 이해하고 실천하려는 마음가짐을 가져야 한다.

#### 1.2.1 아키텍처 결정을 내린다

아키텍트는 아키텍처와 설계 원칙을 결정하고 팀, 부서뿐만 아니라 회사 전체의 기술 결정을 가이드하는 사람이다.

키워드는 '가이드'인데, 아키텍트는 기술 선택을 가이드 하는 사람이지, 정해주는specifiy 사람이 아니다.
예로, 프론트엔드를 리액트로 개발하기로 한 건 결정을 한 것이다. 아키텍트는 프론트엔드 프레임워크를 사용하도록 기술 지도를 하고 여러 리액티브 기반의 웹 프레임워크 중 하나를 선정할 수 있도록 가이드 해야 한다.

```
의견)
나도 멘토링할 때 이런 부분에 대해서 언급을 많이 해주고 있다. 기술을 먼저 결정하기 보다는 만드려고 하는 소프트웨어의 기능 정의를 잘 내리고 필요한 프레임워크를 선택하는게 맞는 방향이라고 얘기해준다.
```

기술 선택을 가이드하는 일은 어려운데
아키텍트 자신이 내린 결정이 개발팀 스스로 옳은 기술 결정을 하도록 가이드하는 데 도움이 되는지,
아니면 개발팀을 위해 기술을 대신 선택해주는 게 더 나을지 자문해봐야 한다.

#### 1.2.2 아키텍처를 지속적으로 분석한다

아키텍트는 끊임없이 아키텍처와 현재 기술 환경을 분석하고 이를 개선하기 위한 해결 방안을 제시한다.

3년 전에 정의한 아키텍처가 지금도 현실성이 있는지 평가하는 역동성에 대한 요구사항이다. 대부분 아키텍처 구조는 쇠락하는 양상을 보이며, 아키텍처 특성에 영향을 미치는 코드를 개발자가 작성하거나 설계를 변경할 때 이런 증상이 나타난다.

아키텍트는 기술 변화와 문제 영역을 종합적으로 분석하여 아키텍처의 건전성을 추구해야 한다.

#### 1.2.3 최신 트렌드를 계속 따라간다

아키텍트는 항상 최신 기술과 업계 트렌드를 따라가야 한다.

아키텍트가 결정한 것들은 대개 오래 지속되고 바꾸기도 어렵다. 핵심 트렌드를 이해하고 계속 좇아갈 수 있어야 미래를 대비하고 올바른 결정을 내릴 수 있다.

#### 1.2.4 아키텍처 결정의 컴플라이언스를 보장한다

아키텍트는 아키텍처 결정과 설계 원칙의 컴플라이언스를 보장해야 한다.

컴플라이언스 보장이란, 아키텍트가 정의하고 문서화하여 전달한 아키텍처 결정과 설계 원칙들을 개발팀이 제대로 준수하고 있는지 지속적으로 확인한다는 뜻이다. 레이어드 아키텍처에서 중간 단계를 건너 뛰고 직접 통신 (UI에서 데이터베이스로) 하겠다고 하는 개발자가 있을 수 있는데, 아키텍트가 그렇게 결정한 데에는 '변경을 다스리겠다'는 중요한 의도가 깔려 있다. 개발자가 아키텍처 결정을 준수하도록 하지 않으면 위반 사례가 등장하고 그러면 아키텍처 특성을 준수할 수 없게 되면 시스템이 기대한 동작을 하지 않게 된다.

#### 1.2.5 다양한 기술과 경험에 노출된다

아키텍트는 다양한 기술, 프레임워크, 플랫폼, 환경에 노출되어야 한다.

요즘 환경은 복합적인 경우가 많으므로 시스템이나 서비스가 어떤 언어와 플랫폼, 기술로 개발되었든지 다양한 시스템과 서비스를 연동하는 방법은 알고 있어야 한다.

그러려면 아키텍트 자신이 가장 익숙한 영역comfort zone을 점점 넓혀가는 것이 가장 좋다. 한가지 기술이나 플랫폼에만 올인하는 것은 안일한 태도이다. 유능한 아키텍트는 여러 가지 언어, 플랫폼, 기술을 경험할 기회를 적극적으로 모색하면서 기술의 깊이보다는 폭에 초점을 둔다. 예로 한 가지 캐시 제품에 정통한 전문가가 되기 보다는 10가지 캐시 제품을 어느 정도 다루고 각각의 장단점을 아는 게 더 중요하다.

```
의견)
개인적으로 아키텍트에 대한 기대치 중에는 커뮤니케이션을 제외하고 기술적인 부분으로는 여기 설명한 부분이 제일 와닿는 부분이다. 나 역시도 한가지 기술 한가지 방법으로만 소프트웨어를 개발하는 걸 좋게 생각하지 않으므로 '고개를 들고 세상이 어떻게 바뀌는지 바라보자' 라는 말을 많이 한다.
특히 '한가지 기술이나 플랫폼에만 올인하는 것은 안일한 태도이다.' 라는 비판적인 문장은 나 역시 그러지 않길 바라는 마음도 있지만 좋은 개발자 그리고 아키텍트로서 중요한 깨달음인 것 같다.
```

#### 1.2.6 비즈니스 도메인 지식을 보유한다

아키텍트는 어느 수준 이상의 비즈니스 도메인 전문가여야 한다.

비즈니스 도메인 지식이 없으면 비즈니스의 문제점, 목표, 요구사항을 이해하기 어렵고 따라서 비즈니스 요구사항을 수용할 만한 효율적인 아키텍처를 설계하기도 어렵다. 기본 업무 지식도 없는 아키텍트기 업무 담당자들과 소통하는 건 거의 불가능하고 곧 신뢰를 잃게 될 것이다.

성공적인 아키텍트는 폭넓은 실무hands-on 기술 지식과 더불어 특정 도메인에 깊이 있는 지식을 보여한 사람들이다. C레벨 임원이나 업무 담당자들과 효과적으로 소통할 수 있다면 소프트웨어 아키텍트로서 무슨 일을 하는지 분명히 알고 보여줄 수 있고, 정확하고 효율적인 아키텍처를 구축할 능력을 지니고 있다는 강한 신뢰감을 느끼게 할 수 있다.

```
의견)
도메인 지식 역시 중요한 부분이다. 대부분 뛰어난 개발자라면 개발하는데 도메인 지식이 필요하다는 걸 알 게 되므로 자연스럽게 습득한다고 본다. 이게 안되는 사람은 자기가 알고 있는 것만 업무에 적용하려고 하는 무능한 사람일 가능성이 높다.
```

#### 1.2.7 대인 관계 기술이 뛰어나다

아키텍트는 팀워크, 조정facilitation, 리더십을 포함한 대인 관계 기술이 뛰어나야 한다.

아키텍트는 기술적으로 이끌기만 하는 사람이 아니라, 개발팀을 리드해서 아키텍처를 구현하는 사람이므로 아키텍트라는 직책 또는 역할과 상관없이, 리더십 스킬은 소프트웨어 아키텍트로서 성공하기 위해 필수 요구사항의 최소한 절반 이상은 차지한다.

강력한 리더십과 대인 관계 스킬은 자신을 다른 아키텍트와 차별화하는 유리한 강점이다. 기술적으로는 뛰어나지만 팀 리딩, 코칭, 개발자 멘토링을 겸하는 아키텍처 결정과 설계 원칙, 배경 사항을 효과적으로 전달할 능력이 결여된 소프트웨어 아키텍처는 자리에 계속 앉아있기 어렵다.

```
의견)
내 경험상 대인 관계 기술이 부족하거나 리더십이 부족한 사람은 아키텍트보다는 쭉 기술쪽 개발 작업일을 하기 원하는 사람들이었다.
```

#### 1.2.8 정치를 이해하고 처세를 잘한다

아키텍트는 기업 내부의 정치적 분위기를 이해하고 적절하게 잘 처신할 줄 알아야 한다.

정치를 논하는 건 이상하게 들리지만 협상 기술은 중요하다. 예로 개발자가 전략 패턴을 구사한다고 해도 누가 신경을 쓰지 않기 때문에 인정받기 위해 그런 결정을 내릴 필요가 없다.

아키텍트가 내린 모든 결정은 사람들의 반발에 부딪히게 된다. 아키텍처 결정을 실천하려면 당연히 시간과 비용이 필요하므로 여러 이해 담당자들에게 뭇매를 맞게 될 수 밖에 없다. 거기에 자기들의 방식이 낫다고 주장하는 개발자들의 공격도 피할 수 없다. 그래서 정치를 잘 하면서 대부분의 결정을 사람들이 수용하도록 기본적인 협상 기술을 발휘해야 한다. 아키텍트 수준에 이르면 모든 결정을 정당화하게 반대 세력에 맞서 싸울 준비를 갖춰야 한다.

```
의견)
챕터 1.2를 읽고 느낀 소감은 아키텍트한테는 연봉을 많이 줘야 한다고 생각하고, 정말 훌륭한 사람이어야 할 것 같다는 생각이 절로 든다. 그리고 나는 훌륭한 사람이 되는 것에는 관심 있지만 연봉에 관심은 없다
```

### 1.3 아키텍처의 교차점 그리고...

과거에는 아키텍처에 탄력적 확장elastic scale 기능을 구현하려면 고통스러운 과정이 수반됐지만, 마이크로서비스는 아키텍트와 데브옵스 간에 소통을 하면서 훨씬 수월하게 처리할 수 있다.

#### 1.3.1 엔지니어링 프랙티스

과거 소프트웨어 아키텍처는 소프트웨어를 제작하는 개발 프로세스와 분리돼 있었다. 폭포수나 애자일 등 소프트웨어를 구축하는 인기 있는 방법론은 소프트웨어 아키텍처에 그리 큰 영향을 끼치지 못했다.

엔지니어링 프랙티스engineering practice와 소프트웨어 개발 '프로세스process'는 구분해야 한다.
소프트웨어 엔지니어링 프랙티스는 프로세스와 문관하게 가시적으로 반복 가능한 혜택을 주는 실천론이다. 지속적 통합continous integration은 특정 프로세스에 의존하지 않는 검증된 엔지니어링 프랙티스이다.
프로세스는 팀을 어떻게 구성하고 관리할지, 회의는 어떻게 하고 워크플로 조직은 어떻게 운영할지 등 사람을 조직하고 상호작용하는 총체적인 기법이다.

엔지니어링 프랙티스에 집중하는 것은 중요하다.

1.
소프트웨어 개발 분야는 보다 성숙한 다른 엔지니어링 체계에 있는 많은 특성들이 빠져 있다. 중요한 구조를 변경할 때 다른 엔지니어는 정확한 결과를 예측할 수 있지만 소프트웨어는 상대적으로 그렇지 못하다.

2.
소프트웨어 개발의 약점 중 하나는 추정estimation이다. 얼마나 오래 걸리고, 얼마나 많은 리소스가 필요하고, 얼마나 많은 비용이 들어갈지 내다봐야 한다. '아렬지지 않은 미지의 것들unknown unknowns' 때문에 어렵다.
프로젝트에 알려지지 않은 미지의 것들을 설계할 수 없으므로 '빅 디자인 업 프런트Big Design Up ront(일단 설계부터 확실하게!)' 방식으로 진해하기 어렵다.

> 모든 아키텍처는 알려지지 않은 미지의 것들 때문에 자꾸 되풀이되는데, 애자일은 단지 이것을 인지해서 더 빨리 수행하는 것이다.

프로세스는 아키텍처와 거의 분리되어 있지만 소프트웨어 아키텍처의 속성상 반복적인 프로세스가 잘 맞는다. 폭포수 모델로 마이크로서비스 같은 시스템을 구축하려면 사사건건 마찰을 빚을 수 밖에 없을 것이다.

아키텍트는 프로젝트 기술 리더를 겸하는 경우도 많기에 엔지니어링 프랙티스를 결정한다. 아키텍처를 선정하기 전에 문제 영역을 살펴보는 거처럼 아키텍트는 아키텍처 스타일과 엔지니어링 프랙티스가 공생 관계망symbiotic mesh을 형성하도록 해야 한다.

익스트림 프로그래밍에서 시작된 사고 방식은 지속적 전달까지 발전했고, 최근에는 엔지니어링 프랙티스가 진보한 덕분에 아키텍처에서 새로운 능력을 펼칠 수 있게 되었다.

아키텍트는 어떤 기준에 맞게 시스템을 설계할 수 있지만, 그 설계는 구현과 소프트웨어 개발 생태계의 어쩔 수 없는 변화를 모두 거치면서 살아남아야 한다.

<Building Evolutionary Architectures>는 시간이 지나 변경이 일어나도 아키텍처 특성을 수호protect(그리고 관장govern)하기 위해 진화 연산evolutionary comuting에서 유래된 피트니스 함수fitness funtion라는 개념을 소개한다. 알고리즘을 특정 용도로 설계할 때 반드시 결과를 측정하여 최적해optional solution에 가까워졌는지 멀어졌는지 확인해야 한다. 그 측정 수단이 피트니스 함수이다.

아키텍처 피트니스 함수는 어떤 아키텍처 특성의 객관저인 완전성을 평가하는 수단이다. 메트릭metric(지표), 단위 테스트unit test, 모니터monitor, 카오스 엔지니어링chaos engineering 등 다양한 매커니즘이 이 평가에 포함된다.

#### 1.3.2 운영/데브옵스

마이크로서비스 아키텍처 스타일을 정립한 아키텍트들은 운영 관심사는 운영으로 처리해야 더 매끄럽다는 사실을 깨달았다. 아키텍처와 운영 간에 연결고리를 맺어 설계를 단순화하고, 운영자가 잘 처리할 수 있는 부분은 운영에 맡기게 됐다. 그 과정에서 아키텍트와 운영자는 리소스를 남용하면 뜻밖의 난관에 빠지게 된다는 사실을 깨닫고 서로 의기투합하여 마이크로서비스를 만들었다.

#### 1.3.3 프로세스

소프트웨어 아키텍처는 소프트웨어 개발 프로세스에 거의 직교적이라는 공리가 있다. 소프트웨어를 구축하는 방법(프로세스)은 소프트웨어 아키텍처(구조)에 별다른 영향을 끼치지 않는다.
애자일 프로젝트를 하는 아키텍트는 반복적인 개발을 통해 의사 결정에 필요한 피드백을 더 빨리 받아보리라 기대할 수 있고 피드백에 의존하는 실험과 다른 지식에 더욱 적극적으로 참여할 수 있다.

재구성restructuring은 애자일 방법론의 진면목을 볼 수 있는 중요한 아키텍처 분야 중 하나이다. 처음에는 쉽고 빨리 착수 가능한 모놀리식 아키텍처로 시작했지만, 이제는 더 현대적인 아키텍처로 이동해야 한다고 생각하는 것이다.

#### 1.3.4 데이터

외부 데이터 스토리지가 큰 비중을 차지하지만, 많은 소프트웨어 아키텍처 도서는 중요한 영역을 너무 가볍게 다루는 경향이 있다. 코드와 데이터는 공생 관계여서 상대방이 없으면 무용지물이다.

데이터베이스 관리자는 아키텍트와 협업하여 복잡한 시스템의 데이터 아키텍처를 구축하며, 관계 및 재사용이 애플리케이션의 포트폴리오에 어떤 영향을 미치는지 분석한다.

```
의견)
클린 아키텍처에서 '데이터베이스는 세부사항이다'라고 외치는 로버트 C. 마틴을 저격한 것인가??
```

### 1.4 소프트웨어 아키텍처 법칙

> 소프트웨어 아키텍처의 모든 것은 다 트레이드오프다. - 소프트웨어 아키텍처 제1법칙

그 어느 것도 소프트웨어 아키텍트에게 깔끔하게 딱 떨어지는 것은 하나도 없다. 모든 결정은 여러가지 상충되는 팩터들을 전부 다 고려해야 한다.

> 아키텍트가 트레이드오프 아닌 뭔가를 발견했다고 생각했다면 그것은 그가 아직 트레이드오프를 발견하지 못했다는 증거일 가능성이 높다. - 제1정리

원칙, 특성 등을 포함한 구조적 요소들을 초월한 용어로 소프트웨어 아키텍처를 정의한다.

> '어떻게'보다 '왜'가 더 중요하다 - 소프트웨어 아키텍처 제2법칙

아키텍처 솔루션을 만드는 워크샵에서 학생들이 문제를 '어떻게' 해결했는지를 포착했을 뿐, 그 팀이 '왜' 그런 선택을 하게 됐는지는 알 수 없었다. 아키텍트는 자신이 전혀 모르는 기존 시스템을 들여다보면서 아키텍처의 구조적인 작동 원리는 알아낼 수 있지만, 왜 다른 것 대신 그런 선택을 하게 됐는지 설명하기는 어렵다.