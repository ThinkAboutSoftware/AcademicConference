# 8장

- 논의주제
    - 책에 나오는 코드 재사용의 구체적인 방법들 중에서, 실제로 겪은 가장 최고의 경험과 최악이 있다면, 공유하고, 책에 나온 관점에서 어떻게 수정해볼 수 있을지 생각해보면 좋을 것 같다.
- 요약
    - 여러 마이크로 서비스의 코드 재사용의 구체적인 방법과 그 트레이드오프에 대해서 논의한다
- 키워드
    - 코드 재사용(code reuse)
        - 코드 복제
        - 공유 라이브러리
            - 디펜던시 관리 vs 변경 관리
            - 버저닝 전략
        - 공유 서비스
            - 변경 리스크
            - 성능
            - 확장성(트래픽 대비)
            - 내고장성(장애상황 대비)
        - 사이드카
- 내 생각
    - 코드 복제의 경우는 매우 원시적인 방법처럼 보일지 모르지만, 어찌보면, 가장 빠르게 문제를 해결할 수 있는 방법일 수도 있다고 생각한다. 이후에도 나오겠지만, 공유라이브러리, 공유 서비스 등을 도입했을 때, 고려해야하는 수많은 트레이드오프를 생각하면, 가장 원시적이지만, 가장 간단하게 처리할 수 있는 방법일 수 있다. 그래서, 원시적 방법이므로, 배척하기보다는 상황에 맞게 쓸 수 있으면 좋을 것 같다
    - 코드 복제의 개인적인 경험은 2가지 정도 있는데,
        - 첫 번째는, common으로 사용하는 Utility성 코드를 코드 복제로 사용해 본 적이 있다. 사내에서 사용하는 java spring skeleton project에 이미 구현된 common package 가 있었고, 이걸 클론해서 개발하게 되면, 자연스레 이 common package 를 사용하게 되었다. 책에 나온대로, 애초에 전사 단위에서 맞춘 Utility성 코드들이었기 때문에, 클론한 이후에 한 번도 수정한 적이 없었고, 나름 나쁘지 않은 전략이라고 볼 수 있었다
        - 두 번째는, SNS message schema 를 관리하는 별도의 repo를 두고, schema 를 각 MS 별로 모두 협의가 되면, 이 repo의 코드를 복사, 붙여넣기 하는 방식으로 했었다. EDA 환경에서 Event 를 정의하고, 협의하고, 이를 적용하기까지 MS가 많으면 많을수록, 이 과정이 복잡한데, 나름의 합리적인 방법을 풀었다고 생각한다. 다만, 수정이 잦을 때,(이벤트 추가/수정 등) 이 부분이 병목이 되기도 하였고, 복사 붙여넣기를 사람이 수기로 하면서, 잘못 붙여넣기를 하는 경우도 있긴 했었다(물론 코드리뷰에서 발견 되었지만) 책에서는 서비스 마다 코드가 중복되기 때문에, 코드 바꿀 일이 있을 때, 서비스 전체에 반영해야 하는 어려움이 있다고 했는데, 이미 협의된 프로세스였기 때문에, 병목이긴 했지만, 문제라고 생각하진 않았었다
    - 공유 라이브러리의 경우는 사내에서 한번 겪어보았는데, 특정 topic에 SNS event를 publish 하는 client library 였다. 간단한 기능이었고, 수정이 거의 없었기 때문에, 책에서 말하는 디펜던시나, 변경관리의 문제가 크진 않았었다. 다만, 한 번 버전이 업데이트된 적이 있었는데, 이때 버전을 업데이트해야 하는 절차 자체가 라이브러리 업데이트 이후, 기능 테스트까지 진행하면서, 번거로웠던 기억이 있다. 하지만, 책에서 말한대로, 변경 빈도가 낮다는 전제하에서, 컴파일 타임에 서비스에 바인딩 되어서, 미리 문제를 확인할 수 있는 것은 큰 장점인 것 같고, 단점으로 제시하는 디펜던시 관리나 변경관리는 큰 문제는 아니었다(아마도, 이를 딥하게 쓰는 회사에서는 제때 라이브러리 업데이트를 하지 않았다면, 큰 문제가 되었을 수도 있을것 같다)
    - 공유 서비스의 경우는 사내 인증 서버 연동을 통해서 경험해보았다. 아마 인증서버를 공유서비스로 구현한 사유는 사내에 파이썬 개발환경, 자바 개발환경의 서버가 공존하고 있는 MSA 환경을 고려한 것이지 않을까 생각된다. 책에서 문제를 제기하는 성능, 확장성은 로그인의 횟수가 트래픽에 큰 영향을 줄 정도로 큰 작업은 아니다 보니, 운영하면서 큰 문제는 아니었던 것 같다. 다만 내고장성의 경우는 서버가 어떤 문제로 죽었을 때, 로그인을 못하는 문제가 발생한 적은 있어서, 개인적으로는 이 부분이 가장 큰 문제이지 않을까 생각된다. 이런 공유서비스는 반드시 하위호환성을 고려해서 API 를 설계해야하는데, 이를 위해서는 반드시 API 버저닝이 필요하다. 책에서는 이 버저닝으로 API path를 변경하는 게 문제라고 말했는데, 실제 운영할 때, 클라이언트 입장에서는 api path 만 변경 하면 되고, 새 API에서 비즈니스로직의 문제가 있더라도, 개발서버에서 미리 확인이 되기 때문에 큰 문제는 아니었던 것 같다
    - 사이드카 패턴은 istio 사용을 통해서 경험을 해보았다. k8s 환경에서 많은 MS들의 Pod 간의 네트워크 트래픽 제어를 위해서 사용하고 있고, MS 수가 많다보니, 공통의 네트워크 정책을 적용하기 위해서 도입한 것으로 알고 있다. Istio의 트래픽 라우팅을 많이 사용하고 있는데, 팀별 오너십의 관점에서 사용되는 것으로 볼 수 있을 것 같다
    - 코드 재사용 문제는 꼭 마이크로 서비스가 아니더라도, 항상 있는 문제 같다. 책에서 말하는 재사용의 오남용 위험성은 나도 매우 동의하는 바이다. 특히 변경이 잦고, 변경 시에 매우 크리티컬한 문제가 발생할 수 있는 경우에는 코드의 격리가 제대로 되지 않은 문제 때문에, 오히려 코드 재사용이 문제가 되는 경우가 더 많았었다. 마이크로 서비스에서도 마찬가지로 무작정 중복이라서 추출하지 말고, 상황을 잘 고려해서 가장 적절한 전략이 무엇일지 고민하고 적용하는게 좋다고 생각한다
        - 중복은 나쁜 것이라고 치부하고, 무조건 적인 추출 및 추상화를 하기보다는, 설계 의도를 더 많이 고민하는게 좋을 것 같다.
    - 8.6에 나오는 그림 8-16의 고객 도메인 MS 의 사례가 현재 내가 일하고 있는 회사의 팀에서 맡고 있는 도메인의 상황과 비슷하다. 외부 중개사와 연동하는 MS 라는 딱지를 붙이다 보니, 관련된 모든 기능들의 추가 혹은 수정이 잦고, 무분별하게 코드 중복을 처리하다보니, 유지보수하기 매우 어렵게 되어 있는 상황이다
    - 8.7의 경우 데이터베이스 접근하는 코드를 어떻게 제공할 것인가에 대한 내용인데, 일단 서비스 자체도 잘못 나눈 것 같고, 공유서비스로 쓰는 것 자체도 잘 공감이 되진 않는다. 일반적이라면, 티켓이라는 MS 로 묶어서 운영할 것 같고, 각 생성, 배정, 완료에 대한 DB 액션은 repository 객체로 구현해서 사용할 것 같다.