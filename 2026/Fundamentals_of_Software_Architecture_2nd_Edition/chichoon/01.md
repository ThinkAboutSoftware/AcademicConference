# 따로 떼어놓기

## Chapter 02: 아키텍처 퀀텀

### 개요

- 개발은 라이브러리 문서, 최적의 알고리즘 등 다양한 베스트 프랙티스가 존재하지만, 아키텍처는 명확한 가이드가 없기 때문에 특정 아키텍처를 도입하려고 해도 세부적인 면을 파고들었을 때 난관에 봉착하기도 함
- 겉보기에는 우리 소프트웨어에 적절히 도입할 수 있을 것 같았는데, 막상 도입하려고 보니 다음과 같은 요소들이 눈에 띄는 것
  - 현재 구현된 소프트웨어에 아키텍처를 끼워맞추려 할 때 봉착하는 문제점
  - 미래에 높은 확률로 예상되는 부작용
  - 한빛전자 아키텍트들이 무조건적인 디커플링만으론 데이터 통신 시의 문제를 염두에 두는 것과 같음
- 무작정 좋아 보인다고 해서 바로 가져다 쓸 수 있는 게 없다
- 마이크로서비스가 대세가 되면서 소프트웨어의 복잡도가 늘어났고, 아키텍트들의 의사 결정을 더 까다롭게 만들었다
  - 마이크로서비스 아키텍처는 하나의 큰 어플리케이션을 독립적이고 작은 서비스들의 집합으로 분할하여 개발하는 스타일
  - 온갖 관심사들이 하나의 소프트웨어에 뭉쳐지면서 요소 파악이 어려워지고 구조가 복잡해졌기 때문
  - 독립적인 서비스를 어느 정도의 크기로 쪼갤 것인지부터 고려해야 함
- 복잡한 서비스에서는 내부적으로 서로 얽혀 있는 부분 (커플링) 을 파악하고, 변경을 가했을 때의 영향을 고려하여 트레이드오프를 분석

### 아키텍처 퀀텀

- 아키텍처 퀀텀: 독립적으로 분리 및 배포가 가능한 하나의 서비스 집합체
  - 마이크로서비스 아키텍처가 잘 도입되었다는 전제하에, 각 서비스들을 아키텍처 퀀텀으로 볼 수 있다
  - 적절히 구성된 아키텍처 퀀텀은 제품과 그 흐름을 효과적으로 이해하고, 각 부서간 소통에 도움을 준다
  - 아무리 서비스가 잘 격리되어 있어도 각 서비스들이 하나의 데이터베이스를 같이 바라볼 경우 독자적인 아키텍처 퀀텀으로 여기지 않는다
    - 퀀텀이 데이터베이스를 통해서 데이터를 주고받으면 안됨, 각 퀀텀간에는 별도의 통신이 필요 (비동기 통신 등)
  - 하나의 사용자 인터페이스를 여러 서비스들이 공유해도 안됨
    - 하나의 사용자 인터페이스 내에서 독자적으로 운용되는 컴포넌트들을 각각 바라볼 경우 아키텍처 퀀텀으로 분류할 수 있음

```
논의점? 궁금증?: '독자적으로 배포 가능한 서비스 집합' 이 아키텍처 퀀텀이기 때문에 데이터베이스 or 사용자 인터페이스가 분리되어 있지 않고 하나의 DB에 모든 서비스가 접근할 경우 아키텍처 퀀텀으로 볼 수 없다고 이해하면 되는 것일지? 2개 이상의 아키텍처 퀀텀들로 구성된 서비스의 예시가 무엇이 있을까
```

### 퀀텀 커플링 트레이드오프

- 기능 응집도: 구성 요소들이 비슷한 도메인과 구조로 잘 결합되어 있는지
  - 모놀리식 (소프트웨어가 하나의 구조? 서비스? 로 이루어져 있는 아키텍처) 의 경우 응집도가 매우 낮다
  - 높은 정적 커플링
- 통신: 서비스 간 데이터 주고받는 방식, 동기 | 비동기가 있음
  - 동기적 통신은 송신자가 수신자의 응답을 대기함
  - 비동기적 통신은 송신자가 응답과 관계없이 하던 일을 계속함 (ACK 시그널 정도만 받는듯)
- 일관성: 통신 시의 무결성 엄격함
- 조정: 통신 방식을 도입한 워크플로에서의 조정 필요성
- 통신, 일관성, 조정은 서로 영향을 주고받으므로 한 쪽을 택하면 다른 쪽으로 트레이드오프가 발생한다
  - 아키텍처 선택 시 중요한 지표
